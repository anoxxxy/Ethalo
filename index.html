<!DOCTYPE html>
<script type="text/javascript" src="./purify.js"></script>
<script type="text/javascript" src="./DDEABI.js"></script>
<script type="text/javascript" src="./ERC20.js"></script>
<script type="text/javascript" src="./crypto-sha256.js"></script>
<script type="text/javascript" src="./crypto-js.js"></script>
<script type="text/javascript" src="./bignumber.min.js"></script>
<script type="text/javascript" src="./sweetalert211.js"></script>
<script type="text/javascript" src="./cryptico.min.js"></script>
<script type="text/javascript" src="./axios.min.js"></script>
<script type="text/javascript" src="./web3.min.js"></script>
<script type="text/javascript" src="./jdenticon.min.js"></script>
<script type="text/javascript" src="./simple-scrollbar.min.js"></script>
<link rel="stylesheet" href="./open-sans.css">
<link rel="stylesheet" href="./simple-scrollbar.css">
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script type="text/javascript" src="./translate.js"></script>
    <link rel="icon" type="image/x-icon" href="./favicon.ico">
    <title t-id="1">BitBay Decentralized Markets</title>
    <style>
        .swal2-popup {
          background-color: #ededed; /* Background color */
          color: #000000; /* Text color */
          border: 2px solid #3d0064; /* Border color */
          border-radius: 4px; /* Border radius */
          font-size: 11px;
          font-family: 'Courier New', monospace; /* Custom font */
          font-weight: normal;
          z-index: 1000;
        }
        .swal2-title {
          color: #3d0064; /* Title text color */
        }
        .swal2-content {
          color: #3d0064; /* Content text color */
        }
        .swal2-confirm,
        .swal2-cancel {
          background-color: #ededed; /* Confirm and cancel button background color */
          color: #3d0064; /* Button text color */
        }
        /* Hover effect for buttons */
        .swal2-confirm:hover,
        .swal2-cancel:hover {
          background-color: #0086e3;
        }
        /* Icon color */
        .swal2-icon {
          color: #3d0064;
        }
        .swal2-range {
          background-color: #ededed; /* Set your desired background color */
          border: 2px solid #3d0064;
        }

        /* Customize the appearance of the scrollbar thumb (handle) */
        .simple-scrollbar .ss-scroll::-webkit-scrollbar-thumb {
          background-color: #555;
        }
        body {
          margin: 0;
          padding: 0;
          font-family: Arial, sans-serif;
          font-size: 14px;
        }
        html, body {
          direction: ltr;
          unicode-bidi: embed;
        }
        #languageSelect {
          padding: 10px;
          font-size: 16px;
        }
        #selectedFlag {
          width: 30px;
          height: 30px;
          margin-right: 5px;
        }
        .container {
            display: flex;
            flex-direction: row;
            height: 100vh;            
        }
        .sidebar {
            width: 75px;
            background: transparent;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 10px;
            padding-bottom: 30px;
        }
        .sidebar-background {
          position: absolute;
          width: 75px;
          height: 100%;
          padding-top: 10px;
          padding-bottom: 30px;
          background-image: url('./purple-gradient.png');
          z-index: -1;
        }
        .sidebar button {
            width: 50px;
            height: 50px;
            font-size: 10px;
            margin-top: 10px;
            margin-bottom: 20px;
            border: none;
            border-radius: 5px;
            background-color: #d5d4e2;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .sidebar button:hover {
            box-shadow: 0 0 10px #7c7c7c;
            background-color: rgba(255, 255, 255, 0.85);
        }
        .sidebar button img {
            margin-top: 10px;
            width: 20px;
            height: 20px;
        }
        .sidebar button span {
            line-height: 1; /* Set line-height to 1 to avoid vertical shifting */
        }
        .main {            
            flex: 1;
            padding: 20px;
            display: none;
        }
        .main.show {
            display: block;
        }
        .connectionstatus {
          font-size: 8.5px;
          display: none;
        }
        .header {
            height: 50px;
            background-color: #322c62;
            color: white;
            font-family: 'Open Sans', sans-serif;
            font-weight: 300;
            display: flex;
            flex-direction: row;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 2px 5px #7d71c3;
        }
        .header2 {
            height: 50px;
            background-color: #f2f2f2;
            display: flex;
            flex-direction: row;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 2px 5px #ccc;
        }
        .header2 a {
            text-decoration: none; /* Remove underlining */
            color: #333; /* Change link color */
            margin-right: 10px; /* Add some spacing between links */
            font-size: 8.5px;
        }
        /* Change link color on hover */
        .header2 a:hover {
            color: #007bff; /* Change link color on hover */            
        }
        .header h1 {
            font-size: 12px;
            margin: 0;
            margin-left: 10px;
            flex: 1;
        }
        .escrow-container {
          font-size: 10px;
        }
        .tabcontent {
          font-size: 10px;
        }
        @media screen and (min-width: 600px) {
          body .main.account * {
              font-size: 13px;
          }
          .header2 a {
            font-size: 11px;
            margin-right: 20px;
          }
          .connectionstatus {
            font-size: 8.5px;
            display: block;
          }
          .escrow-container {
            font-size: 13px;
          }
          .tabcontent {
            font-size: 13px;
          }
          .sidebar-background {
            position: absolute;
            width: 100px;
            height: 100%;
            padding-top: 10px;
            padding-bottom: 30px;
            background-image: url('./purple-gradient.png');
            z-index: -1;
          }
          .sidebar {
              width: 100px;
              background-color: transparent;
              display: flex;
              flex-direction: column;
              align-items: center;
              padding-top: 10px;
              padding-bottom: 30px;
          }
          .sidebar button {
              width: 80px;
              height: 80px;
              font-size: 13px;
              margin-bottom: 10px;
              border: none;
              border-radius: 5px;
              cursor: pointer;
              display: flex;
              flex-direction: column;
              align-items: center;
              text-align: center;
          }
          .sidebar button img {
              margin-top: 15px;
              width: 30px;
              height: 30px;
          }
        }
        @media screen and (min-width: 800px) {
          .header h1 {
            font-size: 20px; /* Adjust the font size for larger screens */
            font-weight: 600;
          }
          .header2 a {
            font-size: 14px;
            margin-right: 30px;
          }
          .connectionstatus {
            font-size: 12px;
            display: block;
          }
        }
        .header button {
            padding: 10px;
            background-color: #ccc;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
        }
        .connect {
            display: flex;
            flex-direction: row;
            align-items: center;
            margin-left: auto;
        }
        .connect button {
            background-color: #4caf50;
            color: #fff;
            margin-right: 10px;
        }
        .footer {
            position: fixed;
            left: 0;
            bottom: 0;
            height: 50px;
            width: 100%;
            background-color: #5c519e;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            box-shadow: 0 -2px 5px #322c62;
            z-index: 10;            
        }
        .footer img {
            width: 30px;
            height: 30px;
            margin: 0 10px;
            cursor: pointer;
        }
        .main.markets {
            min-height: calc(100% - 75); /* Subtract footer height */
            max-height: calc(100% - 75); /* Subtract footer height */
            overflow-y: auto; /* Enable vertical scrolling if content overflows */
            margin-bottom: 100px;
        }
        .main.offers {
            min-height: calc(100% - 75); /* Subtract footer height */
            max-height: calc(100% - 75); /* Subtract footer height */
            overflow-y: auto; /* Enable vertical scrolling if content overflows */
            margin-bottom: 100px;
        }
        .main.contracts {
            min-height: calc(100% - 75); /* Subtract footer height */
            max-height: calc(100% - 75); /* Subtract footer height */
            overflow-y: auto; /* Enable vertical scrolling if content overflows */
            margin-bottom: 100px;
        }
        .main.account {
            min-height: calc(100% - 75); /* Subtract footer height */
            max-height: calc(100% - 75); /* Subtract footer height */
            overflow-y: auto; /* Enable vertical scrolling if content overflows */
            margin-bottom: 100px;
        }
        .main.account * {
            font-size: 12px;
        }
        .main.about {
            min-height: calc(100% - 75); /* Subtract footer height */
            max-height: calc(100% - 75); /* Subtract footer height */
            overflow-y: auto; /* Enable vertical scrolling if content overflows */
            margin-bottom: 100px;
        }
        .main.markets::after {
          content: '';
          background: url('./bitbay-dynamic-peg-hero.png') center/cover;
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          opacity: 0.25; /* Adjust the opacity value as needed */
          z-index: -1;
        }
        .main.account::after {
          content: '';
          background: url('./free-balloon.png') no-repeat;
          position: absolute;
          top: -5%;
          left: 50%;
          right: 0;
          bottom: 0;
          opacity: 0.07; /* Adjust the opacity value as needed */
          z-index: -1;
          overflow-y: hidden;
        }
        .square-button {
          display: inline-block;
          border: 1px solid #3d0064;
          padding: 5px 5px;
          margin-bottom: 5px;
          border-radius: 4px; /* Make it square */
          background-color: #3498db; /* Set default background color */
          color: #ffffff; /* Set default text color */
          cursor: pointer;
          transition: background-color 0.3s, color 0.3s; /* Add transition effect */
        }

        .square-button:hover {
          background-color: #003357; /* Invert background color on hover */
          color: #dcdcdc; /* Invert text color on hover */
        }
        .square-button2 {
          display: inline-block;
          border: 1px solid #3d0064;
          padding: 5px 5px;
          margin-bottom: 5px;
          border-radius: 4px; /* Make it square */
          background-color: #ebebeb; /* Set default background color */
          color: #000000; /* Set default text color */
          cursor: pointer;
          transition: background-color 0.3s, color 0.3s; /* Add transition effect */
        }

        .square-button2:hover {
          background-color: #003357; /* Invert background color on hover */
          color: #dcdcdc; /* Invert text color on hover */
        }
    </style>
</head>
<body>
    <div class="header">
        <img src="bitbay.png" alt="Logo" height="20px" width="20px">
        <h1 t-id="2">BitBay Decentralized Markets</h1>&nbsp
        <img id="selectedFlag" src="default.png" alt="Selected Flag">
        <select id="languageSelect" style="margin-right: 15px; font-size: 10px; width: 100px;">
          <option value="default" disabled selected>Default</option>
        </select>
        <div class="connect">
            <button t-id="3" onclick="login()">Connect Metamask</button>
            <div id="connectionstatus" class="connectionstatus" t-id="4">Not connected</div>
        </div>
    </div>
    <div class="footer">
        <a href="https://bitbay.market" target="_blank"><img src="bitbay.png" text="BitBay"></a>
        <a href="https://t.me/bitbayofficial" target="_blank"><img src="telegram.png" alt="Telegram"></a>
        <a href="https://medium.com/bitbay-blog" target="_blank"><img src="./medium-1.png" alt="Medium"></a>
        <a href="https://github.com/bitbaymarket" target="_blank"><img src="./github-1.png" alt="Github"></a>
    </div>
    <div class="container">
      <div class="sidebar-background">
      </div>
      <div class="sidebar">
          <button onclick="showMain('markets')" id="marketsButton"><img src="markets.png" alt="Markets" style="display: block;"><span class="text" t-id="5">Markets</span></button>
          <button onclick="showMain('offers')" id="offersButton"><img src="ethalo.png" alt="Offers" style="display: block;"><span class="text" t-id="6">Offers</span></button>
          <button onclick="showMain('contracts')" id="contractsButton"><img src="contracts.png" alt="Contracts" style="display: block;"><span class="text" t-id="7">Contracts</span></button>
          <button onclick="showMain('account')" id="accountButton"><img src="account.png" alt="Account" style="display: block;"><span class="text" t-id="8">Account</span></button>
          <button onclick="showMain('about')" id="aboutButton"><img src="about.png" alt="About" style="display: block;"><span class="text" t-id="9">About</span></button>
      </div>
    <div class="main markets">
        <div class="header2">
            <a href="#" t-id="10" onclick="changeSearchText('goods')">Goods</a>
            <a href="#" t-id="11" onclick="changeSearchText('services')">Services</a>
            <a href="#" t-id="12" onclick="changeSearchText('barter')">Barter</a>
            <a href="#" t-id="13" onclick="changeSearchText('p2p-trading')">P2P Trading</a>
            <a href="#" t-id="14" onclick="changeSearchText('commodities')">Commodities</a>
        </div>
        <h2 t-id="15">Markets</h2>
        <div class="top-bar">
            <button onclick="createContract()" class="square-button" t-id="16">Create Contract/Offer</button>
            <div class="search">
                <img src="search.png" height="20px" width="20px" alt="Search">
                <input type="text" id="searchText" placeholder="Search" onkeyup="searchListings(this.value)">
                <button onclick="searchListings(getElementById('searchText').value, 1)" t-id="17">Search</button>
                &nbsp&nbsp<button id="favorites-button" onclick="searchFavorites()" style="background: transparent; border-style: none;"><span id="star-symbol" style="font-size: 20px;">&bigstar;</span><span id="favorites-text"></span></button>
                <div id="loadingStatus"></div>
                <div class="pagination">
                    <br>
                    <button onclick="previousPage()" t-id="18">Previous</button>
                    <button onclick="nextPage()" t-id="19">Next</button>
                    <select id="SortBy">
                      <option value="default" t-id="20">Sort: Default</option>
                      <option value="price-low" t-id="21">Sort: Best price</option>
                      <option value="price-high" t-id="22">Sort: High price</option>
                    </select>
                </div>
            </div>
        </div>
        <div class="listings">
            <!-- populated by JavaScript -->
        </div>
    </div>
    <div class="main offers">
        <h2 t-id="23">Offers</h2>
        <div id="myoffers" class="myoffers"></div>
    </div>
    <div class="main contracts">
        <h2 t-id="24">Contracts</h2>
        <div id="mycontracts" class="mycontracts"></div>
    </div>
    <div class="main account">
        <h2 t-id="25" style="font-size: 16px">Account</h2>
        <p id="account" t-id="26">Please connect metamask</p>
        <button onclick="deposit()" t-id="27">Deposit tokens</button>
        <button onclick="withdraw()" t-id="28">Withdraw tokens</button><br><br>
        <label for="myContactInfo" t-id="29">Contact Information(email/signal/telegram):</label><br>
        <input id="myContactInfo"></input><br><br>
        <label for="myPassword" t-id="44">Password(for encryption):</label><br>
        <input id="myPasswordInput" type="password"></input><br><br>
        <button onclick="registerData()" t-id="30">Register information to my address(contact/encryption/optional)</button><br>
        <div id="publicemail"></div><br><br>
        <label for="clearCompleted" t-id="31">Automatically clear completed contracts</label>
        <input id="clearCompleted" type="checkbox"></input><br><br>
        <label for="emailClient" t-id="50">Attempt to notify prospects through default email client(when applicable)</label>
        <input id="emailClient" type="checkbox" checked></input><br><br>
        <button onclick="RefreshContracts()" t-id="32">Refresh/restore previously cleared contracts</button><br><br>
        <label for="offerExpiration" t-id="33">Private offers expire: </label>
        <select id="offerExpiration">
          <option value="two-weeks" t-id="35">Two weeks</option>
          <option value="one-month" t-id="36">One month</option>
          <option value="never" t-id="34">Never</option>
        </select>
        <br><br>
        <button onclick="backupLocalStorage()" t-id="37">Backup cached site/user data</button>
        <button onclick="loadLocalStorage()" t-id="38">Load site/user data from file</button><br><br>
        <select id="connectMethod">
          <option value="0" t-id="39">Use default IPFS Pinata Gateway</option>
        </select>
        <br><br>
        <h2 t-id="45" style="font-size: 16px">Earn</h2>
        <p id="affiliateInfo" t-id="46">Not connected</p>
        <button onclick="copyAffiliateLink()" t-id="47">Copy affiliate link</button><br><br>
        <button onclick="changeAffiliate()" t-id="48">Change my affiliate</button><br><br>
        <button onclick="setCustomFee()" t-id="49">Set custom referral fee</button><br><br>
    </div>
    <div class="main about" style="background-image: src('./bitbay-dynamic-peg-hero.png');"> <!-- ss-container tag can be used for custom scrollers but it's not totally cross platform -->
        <div id="abount-container" style="width: 100%; max-width: 900px; border: 1px solid #3d0064; padding: 10px; margin-right: 15px; margin-bottom: 25px; align-items: center; display: block; margin-left: auto; margin-right: auto;">
        <h2 t-id="40" style="width: 100%; max-width: 900px; align-items: center; display: block; margin-left: auto; margin-right: auto;">About</h2>
        <p t-id="41" style="width: 100%; max-width: 900px; align-items: center; display: block; margin-left: auto; margin-right: auto;">Welcome to the world of unbreakable contracts. These are two party escrow(double deposit) contracts that cannot be broken and require no 3rd party arbiters. Both users place a customizable deposit along with a payment into a joint account. If the deal goes well they both sign off on it. If one party tries to defraud the other the deal will eventually expire and blow up making it so that nobody wins and theft is profitless. This forces the users to be honest and follow through with their agreements since they either win together or they lose together.</p><br><a href="https://www.youtube.com/watch?v=fge5inFWlkc"><img src="two-party-escrow.jpg" style="width: 100%; max-width: 900px; align-items: center; display: block; margin-left: auto; margin-right: auto;"></a><p t-id="42" style="width: 100%; max-width: 900px; align-items: center; display: block; margin-left: auto; margin-right: auto;">The markets themselves run on top of Solidity chains such as Ethereum and Polygon. Offers can range from goods, services, barter and p2p trading. Since this webpage is fully open source and runs on the client side, the user can also download this code from github and run it locally for even greater security. This protocol which was pioneered by BitHalo back in 2014 predated Ethereum and was the worlds first smart contracts. This is a web based interface for fully decentralized markets.</p><br><p t-id="43" style="width: 100%; max-width: 900px; align-items: center; display: block; margin-left: auto; margin-right: auto;">For selling goods, users will definitely want to consider a drop shipping service or a service that provides discount shipping to compete with the shipping rates typically found in major companies. To do this, you should sign up for a 3rd party shipping account which should allow you to save up to 75% in shipping in some cases. Sellers may also charge buyers for shipping while in escrow and buyers should be careful to make sure the amount doesn't exceed the deposits or that they buy the shipping label themselves. Users should try to keep in communication with each other through the escrow process and it's recommended to have a backup of your keys so both parties are protected during escrow. Although these markets could be moderated through AI(such as webgpt) and community driven moderation, users are entirely responsible for the risks of what they post and for their own escrows. With that in mind, it's strongly recommended to not post content that is illegal in the country you reside. For deals that involve cash users should do their own due dilligence and their own 'know your customer' if needed. It's in everyones best interest to use double deposit escrow to get rid of deception in the world of international commerce and services. It is an advantage when users administrate contracts themselves because arbiters are unable to know the truth of a deal ruling unfairly and can collude causing great losses and they also incur a greater cost. Users are forced to work with each other to achieve a desirable outcome. Users are also the ones who host the offers using IPFS. So it's good practice to run your own IPFS node to archive the markets. It's recommended that you register your contact information to the blockchain. This makes it guaranteed that counter-parties in the contract know how to contact you for any questions about the negotiations. The code may be run locally and can also be audited by visiting the github page where the code and website are hosted. This system is ownerless and entirely free to use. However, there is a setting that can be activated for affiliates/referrals which can range from 0-1%. In order to encourage users to engage with affiliates, the fee is burned if it is not paid to an affiliate. This helps market the system by giving users a way to earn. A user of the markets is automatically an affiliate if they complete 10 deals. That allows them to use the markets for free if they choose to(as they can be their own affiliate) and it allows them to send users to the website through an affiliate link. Visiting through a link registers the affiliate to that account when a deal is accepted and let's them benefit from that referral. Also, some sellers may offer a more attractive referral fee which should allow affiliates to net more by mutual consent. For more information on how BitBay works you may visit: </p><a href="https://bitbay.market" target="_blank" style="width: 100%; max-width: 900px; align-items: center; display: block; margin-left: auto; margin-right: auto;">https://bitbay.market</a>
        <div id="abount-container">
    </div>
</div>
<script>
    document.querySelectorAll('button').forEach(button => {
      if (!button.classList.length && !button.closest('.sidebar')) {
        button.classList.add('square-button2');
      }
    });
    function populateLanguageSelect() {
      const languageSelect = document.getElementById("languageSelect");

      langOptions.forEach((lang) => {
        const option = document.createElement("option");
        option.value = lang.substring(0, 2).toLowerCase();
        option.textContent = lang;
        
        // Create and append flag image
        const flagImg = document.createElement("img");
        flagImg.src = `${lang.toLowerCase()}.png`;
        flagImg.alt = lang;
        option.appendChild(flagImg);

        languageSelect.appendChild(option);
      });
      languageSelect.selectedIndex = 0;
    }

    document.getElementById("languageSelect").addEventListener('change', async function() {
        const languageSelect = document.getElementById("languageSelect");
        const selectedFlagImg = document.getElementById("selectedFlag");
        selectedFlagImg.src = languageSelect.options[languageSelect.selectedIndex].getElementsByTagName('img')[0].src;
        translateDocument(languageSelect.options[languageSelect.selectedIndex].value);
        await loadUser();
        await populateListings();
    });

    function translateThis(mytext) {
      const selectedLanguageCode = document.getElementById("languageSelect").value;
      if(selectedLanguageCode in languages) {
        if(mytext in languages[selectedLanguageCode]) {
          return languages[selectedLanguageCode][mytext];
        }
      }
      return mytext;
    }

    extractedCalls = {'en':{}};
    function extractTranslations() {
      // Get the entire HTML document
      const entireHTML = document.documentElement.outerHTML;

      // Define the regular expression for finding translateThis function calls
      const translateRegex = /translateThis\(['"](.*?)(?:"|')\)/gm;

      // Iterate over matches
      let match;
      while ((match = translateRegex.exec(entireHTML)) !== null) {
        const extractedText = match[1]; // Extracted text from the capturing group
        // Add the extracted text to extractedCalls under 'en'
        extractedCalls['en'][extractedText] = true;
      }

      // Now extractedCalls['en'] contains all the extracted texts
    }

    populateLanguageSelect();

    function translate(text, lang, x) {
        if(lang in languages && x in languages[lang]) {
            return languages[lang][x]["#"+lang];
        } else {
            return text;
        }
    }

    function translateDocument(lang) {
        document.querySelectorAll('[t-id]').forEach(element => {
            const tId = element.getAttribute('t-id');
            const nonTextContent = Array.from(element.childNodes).filter(node => node.nodeType !== 3);
            const textContent = element.textContent;
            languages[tId] = { "#e": textContent };

            // Translate the text content
            const translatedText = translate(textContent, lang, tId);

            // Update the text content
            element.textContent = translatedText;

            // Reinsert the non-text content
            nonTextContent.forEach(node => element.appendChild(node));
        });
    }

    var loadedFiles = {};
    // Open or create the IndexedDB database
    var request = indexedDB.open('fileDatabase', 1);

    // Setup the database structure if it doesn't exist
    request.onupgradeneeded = async function(event) {
      db = event.target.result;
      var objectStore = db.createObjectStore('files', { keyPath: 'hash' });
      objectStore.createIndex('hash', 'hash', { unique: true });
    };

    // Assign the database reference once it's successfully opened
    request.onsuccess = function (event) {
      return new Promise(async function (resolve) {
        db = event.target.result;

        // Initialize loadedFiles from IndexedDB
        var transaction = db.transaction(['files'], 'readonly');
        var objectStore = transaction.objectStore('files');

        objectStore.getAll().onsuccess = function (event) {
          loadedFiles = event.target.result.reduce(function(obj, file) {
            obj[file.hash] = file.data;
            return obj;
          }, {});

          resolve(); // Resolve the promise once the asynchronous operation is done
        };
      });
    };

    // Function to open the IndexedDB database
    async function openDatabase() {
      return new Promise(function(resolve, reject) {
        var request = indexedDB.open('fileDatabase', 1);

        request.onupgradeneeded = function(event) {
          db = event.target.result;
          var objectStore = db.createObjectStore('files', { keyPath: 'hash' });
          objectStore.createIndex('hash', 'hash', { unique: true });
        };

        request.onsuccess = function(event) {
          db = event.target.result;
          resolve();
        };

        request.onerror = function(event) {
          reject(event.target.error);
        };
      });
    }

    // Function to initialize loadedFiles from IndexedDB
    async function initializeLoadedFiles() {
      return new Promise(function(resolve, reject) {
        var transaction = db.transaction(['files'], 'readonly');
        var objectStore = transaction.objectStore('files');

        objectStore.getAll().onsuccess = function(event) {
          loadedFiles = event.target.result.reduce(function(obj, file) {
            obj[file.hash] = file.data;
            return obj;
          }, {});
          resolve();
        };

        transaction.onerror = function(event) {
          reject(event.target.error);
        };
      });
    }

    // Function to get file from IndexedDB
    async function getFile(hash) {
      return new Promise(function (resolve, reject) {
        if(hash=='') {
          resolve(['']);
        }
        // Check if the file hash is in loadedFiles
        if (!(hash in loadedFiles)) {
          // If not, fetch it from IndexedDB
          var transaction = db.transaction(['files'], 'readonly');
          var objectStore = transaction.objectStore('files');

          var request = objectStore.get(hash);

          request.onsuccess = async function (event) {
            var file = event.target.result;
            if (file) {
              loadedFiles[hash] = file.data;
              resolve(loadedFiles[hash]); // Resolve the promise with the file data
            } else {
              resolve(['']); //Image not found in IndexedDB
            }
          };

          request.onerror = async function (event) {
            resolve(['']); //event.target.error
          };
        } else {
          resolve(loadedFiles[hash]); // Resolve the promise with the cached file data
        }
      });
    }


    // Function to store image/file in IndexedDB
    async function storeFile(hash, data) {
      // Open a read-write transaction
      var transaction = db.transaction(['files'], 'readwrite');
      var objectStore = transaction.objectStore('files');
      // Put the file data into the object store
      objectStore.put({ hash: hash, data: data });
      loadedFiles[hash] = data;
    }

    async function storeFiles(files) {
      // Open a read-write transaction
      var transaction = db.transaction(['files'], 'readwrite');
      var objectStore = transaction.objectStore('files');

      for (var hash in files) {
        objectStore.put({ hash: hash, data: files[hash] });
      }
      loadedFiles = files;
    }

    function changeSearchText(newText) {
        document.getElementById('searchText').value = newText;
        searchListings(newText, 1);
    }

    document.getElementById('SortBy').addEventListener('change', function () {
        populateListings();
    });

    showMain('markets');
    var web3 = [];
    var DDEcontract = "";
    var DDEaddy = "";
    var myaccounts = "";
    var userpubkey = "";
    var userprivkey = "";
    var gasOptions = [{},{}];    
    var gasSetting = 1;
    var balances = {};
    var baseBalance = 0;
    var myContactInfo = document.getElementById("myContactInfo");
    var offerExpiration = document.getElementById("offerExpiration");
    var AESkey = Crypto.SHA256("shared key")
    var currentMarketsLength = 0;
    var gasPrice = "";
    var CurrentTimeStamp = new Date().getTime();
    var tokens = [
        {
            address: "0xdfFd57fa61eC2ad0fa260Fa8368ff7F2EEF4407E",
            token: "ETH",
            image: "eth.png",
            decimals: "18"
        },
        {
            address: "0xb3460166784fd07A022E51547379352De4E98dF5",
            token: "WALRUS",
            image: "walrus.png",
            decimals: "8"
        }
    ];
    var tokennames = {"0xdfFd57fa61eC2ad0fa260Fa8368ff7F2EEF4407E":"ETH","0xb3460166784fd07A022E51547379352De4E98dF5":"WALRUS"}
    web3 = new Web3("https://rpc.ankr.com/eth_goerli");
    DDEaddy = "0xcE36f7754abDc89B2e30bdfa91b151BC9799e342"; //Goerli testnet is default market view
    var referral = "0x0000000000000000000000000000000000000000";
    var baseFee = 0;
    var myFavorites = [];
    var DDEcontract2 = new web3.eth.Contract(DDEabi, DDEaddy);
    var marketOffers = {'indices':[], 'results':[]};
    //web3[0] = new Web3("https://cloudflare-eth.com");
    //web3[1] = new Web3("https://bsc-dataseed.binance.org");
    //web3[2] = new Web3("https://api-goerli.etherscan.io/");
    var isConnected = false;
    var showOrder = false;
    var notifyFavorites = localStorage.getItem(myaccounts + ":notifyFavorites");
    if(!notifyFavorites) {
      notifyFavorites = "0";
    }
    function getQueryParam(name) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(name);
    }

        // Detect language
    var qlang = getQueryParam('l') || 'en';  // Default to 'en' if not provided
    var referralCode = getQueryParam('r') || 'default';
    if(referralCode != 'default') {
        referral = referralCode;
        if (!web3.utils.isAddress(referral)) {
            referral = "0x0000000000000000000000000000000000000000";
        }
    }
    if (qlang !== 'en') {
        var languageSelect = document.getElementById('languageSelect');
        
        // Find the index of the option with the specified value
        var optionIndex = -1;
        for (var i = 0; i < languageSelect.options.length; i++) {
            if (languageSelect.options[i].value === qlang) {
                optionIndex = i;
                break;
            }
        }

        // If the option is found, change the selected index and trigger the "change" event
        if (optionIndex !== -1) {
            languageSelect.selectedIndex = optionIndex;
            var event = new Event('change');
            languageSelect.dispatchEvent(event);
        }
    }

    window.addEventListener('ethereum#initialized', login, {
        once: true,
    });

    window.addEventListener("load", async function() {
      if (window.ethereum) {
        // detect Metamask account change
        window.ethereum.on('accountsChanged', async function (newaccounts) {
          console.log('accountsChanges',newaccounts);
          defaultvars();
          await login();
        });
         // detect Network account change
        window.ethereum.on('chainChanged', async function(thenetworkId){
          console.log('chainChanged',thenetworkId);
          marketOffers = {'indices':[], 'results':[]};
          defaultvars();
          await login();
        });
      }
    });    
    defaultvars();
    function defaultvars() {
        DDEcontract = "";
        myaccounts = "";
        DDEaddy = "";
        balances = {};
        baseBalance = 0;
        gasPrice = "";
        document.getElementById("account").innerHTML = translateThis("Not connected.");
        document.getElementById("myContactInfo").value = '';
        document.getElementById("myoffers").innerHTML = ""; // clear the container first
        document.getElementById("mycontracts").innerHTML = ""; // clear the container first
        document.getElementById('publicemail').innerHTML = "";
        document.getElementById('myPasswordInput').innerHTML = "";
        offerExpiration.selectedIndex = 0;
        currentMarketsLength = 0;
        userpubkey = "";
        userprivkey = "";
        gasOptions = [{},{}];
        gasSetting = 1;
        baseFee = 0;
        myFavorites = [];
    }

    async function login() {
        if (window.ethereum) { //Note: for mobile this only works if the webpage has <head> tag
            console.log("connecting");
            await window.ethereum.request({method: 'eth_requestAccounts'});
            web3 = new Web3(window.ethereum);
            console.log("success");
            isConnected = true;
            document.getElementById("connectionstatus").innerHTML = translateThis("Connected.");
            await loadUser(1);
            await populateListings();
        } else {
            isConnected = false;
            document.getElementById("connectionstatus").innerHTML = translateThis("Not connected.");
        }
    }

    async function loadUser(login=0) {
        if (!isConnected) {
            return;
        }
        var myaccounts2 = await web3.eth.getAccounts();
        if (myaccounts2.length == 0) {
            document.getElementById("connectionstatus").innerHTML = translateThis("Please unlock Metamask so it can connect.");
            return;
        }
        currentChainId = DOMPurify.sanitize(await web3.eth.net.getId());
        var netname = "unknown";
        var netname2 = "ETH";
        await web3.eth.getGasPrice().then(function (theGasPrice) {            
            gasPrice = window.web3.utils.toWei(parseInt(parseInt(DOMPurify.sanitize(theGasPrice)) * 1.5).toString(), 'wei');
            if(parseInt(gasPrice) > 2500000000) {
                gasPrice = "2500000000";
            }
            if(parseInt(gasPrice) < 500000000) {
                gasPrice = "500000000";
            }
        });
        if (currentChainId == 5) {
            netname = "Goerli Testnet";
            netname2 = "ETH";
            DDEaddy = "0xcE36f7754abDc89B2e30bdfa91b151BC9799e342";     
            gasOptions[0] = {
              gasLimit: 4000000,
              gasPrice: null,
              maxPriorityFeePerGas: window.web3.utils.toWei('1.5', 'gwei'), // Max priority fee of 1.5 Gwei
              maxFeePerGas: window.web3.utils.toWei('1.6', 'gwei'), // Max base fee of 1.5 Gwei
            };
            gasOptions[1] = {
              gasLimit: 4000000,
              gasPrice: gasPrice
            };
            tokens = [
              {
                  address: "0xdfFd57fa61eC2ad0fa260Fa8368ff7F2EEF4407E",
                  token: "ETH",
                  image: "eth.png",
                  decimals: "18"
              },
              {
                  address: "0xb3460166784fd07A022E51547379352De4E98dF5",
                  token: "WALRUS",
                  image: "walrus.png",
                  decimals: "8"
              }
            ];
            tokennames = {"0xdfFd57fa61eC2ad0fa260Fa8368ff7F2EEF4407E":"ETH","0xb3460166784fd07A022E51547379352De4E98dF5":"WALRUS"}
        }
        if (netname == "unknown") {
            document.getElementById("connectionstatus").innerHTML = translateThis("Unsupported network");
            return;
        }
        document.getElementById("connectionstatus").innerHTML = translateThis("Connected to") + " " + netname;
        const metabutton = document.querySelector('[t-id="3"]');
        if (metabutton && window.innerWidth <= 800) {
            metabutton.textContent = translateThis('Connected');
        }
        myaccounts = DOMPurify.sanitize(myaccounts2[0]);
        var cached = await getContactInfo(myaccounts);
        document.getElementById("myContactInfo").value = cached;
        cached = await getExpirationInfo(myaccounts);
        var offerExpirationSelect = document.getElementById("offerExpiration");
        if (cached != '') {
            for (let i = 0; i < offerExpirationSelect.options.length; i++) {
              if (offerExpirationSelect.options[i].value === cached) {
                offerExpirationSelect.selectedIndex = i;
                break;
              }
            }
        } else {
            offerExpirationSelect.selectedIndex = 0;
        }
        loadAutoClearState();
        loadEmailClientState();
        const theFavorites =  localStorage.getItem(myaccounts + ":myFavorites");
        if(theFavorites) {
          myFavorites = JSON.parse(theFavorites);
        }
        checkFavorites();
        const userPWHash = localStorage.getItem(myaccounts + ":password");
        if(userPWHash) {
          const userPWHash2 = localStorage.getItem(myaccounts + ":savedpw");
          if(!userPWHash2) {
            await getUserPassword();
          } else {
            document.getElementById("myPasswordInput").value = userPWHash2;
            userprivkey=userPWHash2;
            for(var i=1; i<50000; i++) {
              userprivkey=Crypto.SHA256(userprivkey);
            }
            userprivkey = cryptico.generateRSAKey(userprivkey, 1024);
            userpubkey = cryptico.publicKeyString(userprivkey);
          }
        }
        const gasSetting2 = localStorage.getItem(myaccounts+":gasOption");        
        if(gasSetting2 && gasSetting2 == "1") {
          gasSetting = 1;
        }
        const currentBlockNumber = await web3.eth.getBlockNumber();
        const currentBlock = await web3.eth.getBlock(currentBlockNumber);
        CurrentTimeStamp = DOMPurify.sanitize(currentBlock.timestamp);
        DDEcontract = new web3.eth.Contract(DDEabi, DDEaddy);
        balances = {};
        var btext = [];
        for (var i = 0; i < tokens.length; i++) {
            await DDEcontract.methods.userBalance(myaccounts,tokens[i].address).call().then(function (liquid1) {            
                    balances[tokens[i].address]=({token:tokens[i].token, decimals: tokens[i].decimals, amount: DOMPurify.sanitize(liquid1)});
                    btext+="<br>"+balances[tokens[i].address].token+" <bdo>"+translateThis("balance deposited to markets:")+"</bdo> "+displayDecimals(tokens[i].address, balances[tokens[i].address].amount);
            });
        }
        reputation = [0,0,0];
        reputation = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract.methods.getCompleted(myaccounts).call())));
        if((parseInt(reputation[0]) + parseInt(reputation[1])) > 0) {
            btext+="<br><bdo>" + translateThis("Contracting success rate:") + "</bdo> " + (parseFloat(parseFloat(reputation[0]) / (parseFloat(reputation[0]) + parseFloat(reputation[1]))) * parseFloat(100)).toFixed(2) + "% (" + parseInt(reputation[0]) + "/" + (parseInt(reputation[0]) + parseInt(reputation[1])) + ")";
        }
        await window.web3.eth.getBalance(myaccounts, function(err, result1) {
            if (err) {
                console.log(err);
                return;
            } else {
                baseBalance = DOMPurify.sanitize(result1);//window.web3.utils.fromWei(result1, "ether");
                document.getElementById("account").innerHTML = "<bdo>" + DOMPurify.sanitize(translateThis("Current Network:") + "</bdo> " + netname + "<br>" + myaccounts + "<br>" + netname2 + " <bdo>" + translateThis("wallet balance:") + "</bdo> " + window.web3.utils.fromWei(baseBalance, "ether") + btext);
            }
        });
        try {
            var afee = DOMPurify.sanitize(await DDEcontract.methods.affiliateFee().call());
            var cfee = DOMPurify.sanitize(await DDEcontract.methods.customFee(myaccounts).call());
            var atext = "<bdo>" + translateThis("Base referral fee paid to affiliates:") + "</bdo> " + (afee / 100).toFixed(2) + "%";
            baseFee = afee;
            if(cfee != 0) {
              atext = "<bdo>" + translateThis("Custom referral fee paid to affiliates:") + "</bdo> " + (cfee / 100).toFixed(2) + "%";
            }            
            if(reputation[2] >= 10) {
              atext += "<br><bdo>" + translateThis("You are an affiliate! You may market this system using your affiliate link.") + "</bdo>";
            } else {
              var cooldown = DOMPurify.sanitize(await DDEcontract.methods.cooldown(myaccounts).call());
              if(cooldown != 0 && (cooldown - CurrentTimeStamp) > 0) {
                atext += "<br><bdo>" + translateThis("Cooldown between next deal to qualify as an affiliate:") + "</bdo> " + ((parseFloat(cooldown) - parseFloat(CurrentTimeStamp)) / 60 / 60 / 24).toFixed(2) + translateThis("(days)");
              } else {
                var threshold = DOMPurify.sanitize(await DDEcontract.methods.minimumFeeThreshold(tokens[0].address).call());
                atext += "<br><bdo>" + translateThis("Minimum qualifying fee on next deal to become affiliate:") + "</bdo> " + displayDecimals(tokens[0].address, threshold);
              }
              atext += "<br><bdo>" + translateThis("Qualifying contracts remaining until you can become an affiliate:") + "</bdo> " + (10 - reputation[2]);
            }
            var referral2 = DOMPurify.sanitize(await DDEcontract.methods.referral(myaccounts).call());
            if(referral2 == "0x0000000000000000000000000000000000000000" && referral == "0x0000000000000000000000000000000000000000") {
              atext += "<br><bdo>" + translateThis("No affiliate assigned! It's recommended to assign one so the fee is not burned.") + "</bdo>";
            }
            if(referral2 != "0x0000000000000000000000000000000000000000") {
              atext += "<br><bdo>" + translateThis("Current affiliate assigned to account:") + "</bdo> " + referral2;
            }
            if(referral != "0x0000000000000000000000000000000000000000") {
              var arep = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract.methods.getCompleted(referral).call())));
              if(arep[2]>=10) {
                atext += "<br><bdo>" + translateThis("Future affiliate assigned on next contract:") + "</bdo> " + referral;
              } else {
                atext += "<br><bdo>" + translateThis("Linked affiliate is not valid because they have not completed 10 qualified deals yet:") + "</bdo> " + referral;
              }
            }
            if(parseInt(reputation[0]) + parseInt(reputation[1]) == 0) {
              atext +=  "<br><br><bdo>" + translateThis("You are new to the markets! Welcome to BitBay.") + "</bdo>";
            } else {
              atext += "<br><br><bdo>" + translateThis("Contracting success rate:") + "</bdo> " + ((reputation[0] / (reputation[0] + reputation[1])) * 100).toFixed(2) + "%(" + reputation[0] + "/" + (parseInt(reputation[0]) + parseInt(reputation[1])) + ")";
            }
            document.getElementById("affiliateInfo").innerHTML = atext;
        } catch(e) {
            console.log(e);
        }
        var contact2 = '';
        var datalen = 0;
        var shortPublicKey = '';
        var datatext = '';
        try {
            datalen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(myaccounts, 3).call());
            if(datalen > 0) {
                contact2 = JSON.parse(DOMPurify.sanitize(await DDEcontract.methods.userdata(myaccounts, datalen-1).call()));
                if("mycontact" in contact2) {
                  datatext += "<bdo>" + translateThis("Registered contact information:") + "</bdo> " + contact2['mycontact'];
                }
                if("publickey" in contact2) {
                  if(datatext != '') {
                    datatext += '<br>';
                  }
                  shortPublicKey = contact2['publickey'].substring(0, 10) + '...<bdo><span id="showMore" style="color:blue">' + translateThis('(show more)') + '</span></bdo>';
                  datatext += "<bdo>" + translateThis("Public key(for encryption):") + "</bdo> " + shortPublicKey;
                  document.getElementById('publicemail').innerHTML = datatext;
                  document.getElementById('showMore').addEventListener('click', function() {
                    var datatext2 = '';
                    if("mycontact" in contact2) {
                      datatext2 += "<bdo>" + translateThis("Registered contact information:") + "</bdo> " + contact2['mycontact'];
                      datatext2 += '<br>';
                    }
                    document.getElementById('publicemail').innerHTML = datatext2 + "<bdo>" + translateThis("Public key(for encryption):") + "</bdo> " + contact2['publickey'];
                  });
                } else {
                  document.getElementById('publicemail').innerHTML = datatext;
                }
            } else {
                document.getElementById('publicemail').innerHTML = "";
            }
        } catch(e) {
            console.log(e);
        }
        if(shortPublicKey == '' && userpubkey != '') {
          shortPublicKey = userpubkey.substring(0, 10) + '...<bdo><span id="showMore" style="color:blue">' + translateThis('(show more)') + '</span></bdo>';
          datatext += "<bdo>" + translateThis("Public key(for encryption):") + "</bdo> " + shortPublicKey;
          document.getElementById('publicemail').innerHTML = datatext;
          document.getElementById('showMore').addEventListener('click', function() {
            var datatext2 = '';
            try {
              if("mycontact" in contact2) {
                datatext2 += "<bdo>" + translateThis("Registered contact information:") + "</bdo> " + contact2['mycontact'];
                datatext2 += '<br>';
              }
            } catch {              
            }
            document.getElementById('publicemail').innerHTML = datatext2 + "<bdo>" + translateThis("Public key(for encryption):") + "</bdo> " + userpubkey;
          });
        }
        if(login == 1) {
            await getUserAPI(currentChainId);
            await loadMarkets(1, 50);
        } else {
            await checkMarketUpdate();
        }
        await populateOffers();
    }

    async function showError(error) {
      if (error.message.includes("specified gasPrice but also included maxFeePerGas")) {
        await Swal.fire(translateThis("Web3 gas assignment failed. Will change to blockchain recommended gas options."));
        gasSetting = 1;
        localStorage.setItem(myaccounts+":gasOption", "1");
      } else if (error.message.includes("DDEcontract.methods is undefined")) {
        await Swal.fire(translateThis("Not connected."));
      } 
      else {
        await Swal.fire({title: translateThis("Error sending transaction"), text: error.message, icon: 'error', confirmButtonText: translateThis('OK')});
      }
    }

    function checkFavorites() {
      if(myFavorites.length > 0) {
        document.getElementById("star-symbol").style.color = "#ed5f00";
      } else {
        document.getElementById("star-symbol").style.color = "#000000";
      }
    }

    document.getElementById('favorites-button').addEventListener('mouseover', function() {
      document.getElementById('favorites-text').innerHTML = translateThis('Favorites');
      document.getElementById('favorites-text').style.color = 'black';
    });

    document.getElementById('favorites-button').addEventListener('mouseout', function() {
      document.getElementById('favorites-text').innerHTML = '';
    });

    myContactInfo.addEventListener('blur', async function(event) {
        await saveContactInfo(document.getElementById("myContactInfo").value);
    });

    function backupLocalStorage() {
      const localStorageData = JSON.stringify(localStorage);
      const blob = new Blob([localStorageData], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const anchor = document.createElement('a');
      anchor.href = url;
      anchor.download = window.prompt(translateThis('Choose a file name for the backup:'), 'localStorageBackup.json');
      anchor.click();
      URL.revokeObjectURL(url);
    }

    function loadLocalStorage() {
      const reader = new FileReader();
      reader.onload = function(event) {
        try {
          const fileData = JSON.parse(event.target.result);
          Object.keys(fileData).forEach(function(key) {
            localStorage.setItem(key, fileData[key]);
          });
          console.log('Local storage data overwritten with data from file.');
        } catch (error) {
          console.error('Error parsing file data:', error);
        }
      };
      reader.onerror = function(event) {
        console.error('Error loading file:', event.target.error);
      };
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';

      input.onchange = function(event) {
        const file = event.target.files[0];
        reader.readAsText(file);
      };
      // Trigger a click event on the input element to prompt the user to select a file
      input.click();
    }

    async function RefreshContracts() {
        if(myaccounts != '') {
            localStorage.setItem(myaccounts+":readmessages3", JSON.stringify({}));
            await populateOffers();
        }
    }

    async function saveContactInfo(text) {
        if(myaccounts != '') {
            localStorage.setItem(myaccounts+":contact", text);
        }
    }

    async function getContactInfo(account) {
        const cached = localStorage.getItem(account+":contact");
        if (cached) {
            return cached;
        } else {
            return '';
        }
    }

    const selectAPI = document.getElementById('connectMethod');    

    selectAPI.addEventListener('blur', async function(event) {
      await saveAPI();
    });

    async function saveAPI() {
        const myCurrentChainId = DOMPurify.sanitize(await web3.eth.net.getId());
        localStorage.setItem(myaccounts+myCurrentChainId+":api", document.getElementById('connectMethod').value);
        await getUserAPI(myCurrentChainId);
    }

    async function getUserAPI(mychainid) {
        mylen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(myaccounts, 4).call());
        const mySelectElement = document.getElementById('connectMethod');

        mySelectElement.innerHTML = '';
        const option1 = document.createElement('option');
        option1.value = 'a';
        option1.text = translateThis('Use default IPFS Pinata Gateway');
        mySelectElement.add(option1);

        // Add additional elements with values based on the size of mylen
        for (let i = 0; i < mylen; i++) {
          const option = document.createElement('option');
          option.value = i.toString();
          option.text = translateThis("Use gateway") + `#${i}`;
          mySelectElement.add(option);
        }

        var selectedAPI = "0";
        const cached = localStorage.getItem(myaccounts+mychainid+":api");        
        if (cached) {
            const index = Array.from(mySelectElement.options).findIndex(option => option.value === cached.toString());
            mySelectElement.selectedIndex = index;
            selectedAPI = cached.toString();
            if (selectedAPI == 'a') {
                selectedAPI = "0";
            }
        }
        await getAPI(selectedAPI);
    }

    offerExpiration.addEventListener('change', async function(event) {
        await saveExpirationInfo(document.getElementById("offerExpiration").value);
    });

    async function saveExpirationInfo(text) {
        if(myaccounts != '') {
            localStorage.setItem(myaccounts+":expiration", text);
        }
    }

    async function getExpirationInfo(account) {
        const cached = localStorage.getItem(account+":expiration");
        if (cached) {
            return cached;
        } else {
            return '';
        }
    }

    var autoClearCheckbox = document.getElementById("clearCompleted");

    autoClearCheckbox.addEventListener("change", () => {
      if(myaccounts != '') {
        localStorage.setItem(myaccounts + ":autoclear", autoClearCheckbox.checked);
      }
    });

    function loadAutoClearState() {
      const autoClearState = localStorage.getItem(myaccounts + ":autoclear");
      if (autoClearState === "true") {
        autoClearCheckbox.checked = true;
      } else {
        autoClearCheckbox.checked = false;
      }
    }

    var emailClient = document.getElementById("emailClient");

    emailClient.addEventListener("change", () => {
      if(myaccounts != '') {
        localStorage.setItem(myaccounts + ":emailclient", emailClient.checked);
      }
    });

    function loadEmailClientState() {
      const emailState = localStorage.getItem(myaccounts + ":emailclient");
      if (emailState === "true") {
        emailClient.checked = true;
      } else {
        emailClient.checked = false;
      }
    }

    document.getElementById("myPasswordInput").addEventListener('blur', async function () {
      const passwordValue = document.getElementById("myPasswordInput").value;
      if(myaccounts != '') {
        if (passwordValue.includes(' ') || passwordValue.length < 10) {
          await Swal.fire(translateThis('Password must not contain spaces and must be at least 10 characters long'));
          document.getElementById("myPasswordInput").value = '';
          return;
        }
        await Swal.fire({
          title: translateThis('Confirm Password'),
          input: 'password',
          inputPlaceholder: translateThis('Enter your password again'),
          showCancelButton: true,
          confirmButtonText: translateThis('Set Password'),
          cancelButtonText: translateThis('Cancel'),
          preConfirm: async (confirmedPassword) => {
            // Compare the entered password with the original password
            if (confirmedPassword === passwordValue || Crypto.SHA256(confirmedPassword) === passwordValue) {
              // Passwords match, proceed to set in localStorage
              var hashedPassword = confirmedPassword;
              hashedPassword = Crypto.SHA256(hashedPassword);
              userprivkey=hashedPassword;
              for(var i=1; i<50000; i++) {
                userprivkey=Crypto.SHA256(userprivkey);
              }
              userprivkey = cryptico.generateRSAKey(userprivkey, 1024);
              userpubkey = cryptico.publicKeyString(userprivkey);
              document.getElementById("myPasswordInput").value = hashedPassword;
              localStorage.setItem(myaccounts + ':password', Crypto.SHA256(hashedPassword+"1"));
              console.log('Password saved in localStorage:', Crypto.SHA256(hashedPassword+"1"));
              await Swal.fire({
                title: translateThis('Register Public Key'),
                text: translateThis('Would you like to register this public key to your account now? This is how users will know how to encrypt their offers to you.'),
                icon: 'question',
                showCancelButton: true,
                confirmButtonText: translateThis('Yes'),
                cancelButtonText: translateThis('No'),
              }).then(async (result) => {
                if (result.isConfirmed) {
                  await registerData();
                }
              });
              await Swal.fire({
                title: translateThis('Remember Password'),
                text: translateThis('Would you like your device to remember this password? It is convenient to remember it however it is more secure to type it every time you log in.'),
                icon: 'question',
                showCancelButton: true,
                confirmButtonText: translateThis('Yes'),
                cancelButtonText: translateThis('No'),
              }).then(async (result) => {
                if (result.isConfirmed) {
                  localStorage.setItem(myaccounts + ':savedpw', hashedPassword);
                }
              });      
            } else {
              await Swal.fire(translateThis('Passwords do not match'));
              document.getElementById("myPasswordInput").value = '';
            }
          }
        });
      } else {
        document.getElementById("myPasswordInput").value = '';
      }
    });

    async function getUserPassword() {
      const userPWHash = localStorage.getItem(myaccounts + ":password");
      const passwordValue = document.getElementById("myPasswordInput").value;
      if(userPWHash != Crypto.SHA256(passwordValue+"1") && userPWHash != Crypto.SHA256(Crypto.SHA256(passwordValue)+"1")) {
        await Swal.fire({
          title: translateThis('Confirm Password'),
          input: 'password',
          inputPlaceholder: translateThis('Please enter your password'),
          showCancelButton: true,
          confirmButtonText: translateThis('Confirm Password'),
          cancelButtonText: translateThis('Cancel'),
          preConfirm: async (confirmedPassword) => {
            // Compare the entered password with the original password
            if (Crypto.SHA256(Crypto.SHA256(confirmedPassword)+"1") === userPWHash) {
              // Passwords match, proceed to set in localStorage
              var hashedPassword = confirmedPassword;
              hashedPassword = Crypto.SHA256(hashedPassword);
              userprivkey=hashedPassword;
              for(var i=1; i<50000; i++) {
                userprivkey=Crypto.SHA256(userprivkey);
              }
              document.getElementById("myPasswordInput").value = hashedPassword;
              userprivkey = cryptico.generateRSAKey(userprivkey, 1024);
              userpubkey = cryptico.publicKeyString(userprivkey);
            } else {
              await Swal.fire({
                title: translateThis('Passwords do not match'),
                text: translateThis('Please also note that you will not be able to see details on any of your previous encrypted offers until the correct password is entered. Therefore, we do not recommend changing passwords. If you do, the public key registered to your account should also be updated. Please enter the password again on the account page.'),
                icon: 'error',
                customClass: {
                  popup: 'custom-font-size'
                },
                didOpen: () => {
                  // Style adjustments using JavaScript
                  const popup = document.querySelector('.swal2-popup.custom-font-size');
                  if (popup) {
                    popup.style.fontSize = '14px'; // Adjust the font size as needed
                  }
                }
              });
              document.getElementById("myPasswordInput").value = '';
            }
          }
        });
      }
    }

    async function registerData() {
      myemail = document.getElementById('myContactInfo').value;
      const { value: formValues } = await Swal.fire({
        title: '',
        html:
          '<input id="checkbox1" type="checkbox" name="registerEmail"> ' +
          '<label for="checkbox1">' + translateThis('Register email/contact information') + '</label><br>' +
          '<input id="checkbox2" type="checkbox" name="registerPublicKey"> ' +
          '<label for="checkbox2">' + translateThis('Register public key for privacy/encryption') + '</label>',
        focusConfirm: false,
        showCancelButton: true,
        preConfirm: () => {
          return {
            registerEmail: document.getElementById('checkbox1').checked,
            registerPublicKey: document.getElementById('checkbox2').checked
          };
        }
      });
      var myuserdata = {};
      // Output the selected values
      if (formValues) {
        if(formValues.registerEmail) {
          myuserdata.mycontact = myemail
        }
        if(formValues.registerPublicKey) {
          myuserdata.publickey = userpubkey;
          if(myuserdata.publickey == "") {
              Swal.fire(translateThis("Public key unknown."));
              return;
          }
        }
      }
      if(Object.keys(myuserdata).length === 0) {
        return;
      }
      if('mycontact' in myuserdata && myuserdata.mycontact == "") {
        await Swal.fire(translateThis("Email is blank, try again"));
        return;
      }
      try {
          await DDEcontract.methods.adduserdata(JSON.stringify(myuserdata)).send({"from":myaccounts,...gasOptions[gasSetting]});
          await Swal.fire(translateThis("Data added!"));
        } catch (error) {          
          console.error(error);
          await showError(error);
      }
    }

    async function copyAffiliateLink() {
      var currentUrl = window.location.href;
      if(currentUrl.includes('?')) {
        currentUrl = currentUrl.split('?')[0];
      }
      const urlWithSlash = currentUrl.endsWith('/') ? currentUrl : currentUrl + '/';
      const swalOptions = {};
      langOptions.forEach((lang) => {
        swalOptions[lang] = lang;
      });
      var arep = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract.methods.getCompleted(myaccounts).call())));
      if(arep[2]<10) {
        Swal.fire(translateThis("You have not completed 10 deals with the minimum threshold and requirements yet. Only then can you become an affiliate."));
        return;
      }
      // Ask the user to select a language
      await Swal.fire({
        title: translateThis('Select Language'),
        input: 'select',
        inputOptions: swalOptions,
        inputValue: 'English',
        inputPlaceholder: translateThis('Select a language'),
        showCancelButton: true,
        confirmButtonText: translateThis('Copy to Clipboard'),
        cancelButtonText: translateThis('Cancel'),
      }).then((result) => {
        if (result.isConfirmed) {
          const selectedLanguage = result.value.substring(0, 2).toLowerCase();
          const newUrl = `${urlWithSlash}?l=${selectedLanguage}&r=${myaccounts}`;
          // Create a text area for manual copying
          const textArea = document.createElement('textarea');
          textArea.value = newUrl;
          textArea.style.position = 'fixed'; // Make it invisible and fixed to avoid interference
          document.body.appendChild(textArea);
          textArea.select();
          try {
            // Attempt to execute the copy command
            document.execCommand('copy');

            // Show a success message
            Swal.fire({
              icon: 'success',
              title: translateThis('URL Copied'),
              text: translateThis('The modified URL has been copied to the clipboard.'),
            });
          } catch (err) {
            console.error('Copy command failed:', err);
            Swal.fire({
              icon: 'info',
              title: translateThis('Copy Manually'),
              text: translateThis('The modified URL is:') + '\n\n' + newUrl + '\n\n' + translateThis('Please copy it manually.'),
            });
          } finally {
            // Clean up: remove the temporary text area
            document.body.removeChild(textArea);
          }
        }
      });
    }
    async function changeAffiliate() {
      await Swal.fire({
        title: translateThis('Please enter preferred affiliate'),
        input: 'text',
        showCancelButton: true,
        confirmButtonText: translateThis('Submit'),
        cancelButtonText: translateThis('Cancel'),
        inputValidator: (value) => {
          if (!value) {
            return 'You need to enter something!';
          }
        },
      }).then(async (result) => {
        if (result.isConfirmed) {
          const affiliate = result.value;
          if (!web3.utils.isAddress(referral)) {              
              Swal.fire(translateThis("Address was not valid."));
              return;
          }
          var reputation = [0,0,0];
          reputation = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract.methods.getCompleted(affiliate).call())));
          if(reputation[2] >= 10) {
            try {
              await DDEcontract.methods.changeAffiliate(affiliate).send({"from":myaccounts,...gasOptions[gasSetting]});
              Swal.fire(translateThis("Success!"));
              referral = affiliate;
            } catch (e) {
              console.log(e);
              await showError(e);
              return;
            }
          } else {
            Swal.fire(translateThis("This person has not completed enough qualified deals yet."));
          }
        }
      });
    }
    async function setCustomFee() {
      await Swal.fire({
        title: translateThis('Set base affiliate fee'),
        text: translateThis('Please enter the percentage fee that you wish to offer to affiliates who help find customers for you.'),
        input: 'range',
        inputAttributes: {
          min: (baseFee / 100).toFixed(1),
          max: 50,
          step: 0.1,
          value: 0 // Set the initial value as needed
        },
        inputValue: (baseFee / 100).toFixed(1), // Set the initial value as needed
        showCancelButton: true,
        inputLabel: 'Percentage',
        preConfirm: (value) => {
        }
      }).then(async (result) => {
        if (result.isConfirmed) {
          var value = parseInt(result.value) * parseInt(100);
          try {
            await DDEcontract.methods.changeCustomFee(value).send({"from":myaccounts,...gasOptions[gasSetting]});
            Swal.fire(translateThis("Success!"));
          } catch (e) {
            console.log(e);
            await showError(e);
          }
        }
      });
    }

    async function postOfferData(text) {
        // Hash the text using web3 keccak
        const hash = web3.utils.keccak256(text);

        // Check if the hash is already stored in localStorage
        const cached = await getFile(hash);
        if (!Array.isArray(cached)) {
            return JSON.parse(cached).ipfsHash;
        }

        // If not, pin the text to Pinata IPFS and get the IPFS hash
        const ipfsHash = await pinToPinataIPFS(text);
        console.log("Offer posted to IPFS");
        console.log(ipfsHash);
        if(ipfsHash == "error") {
            return "error";
        }

        // Store the hashed text and IPFS hash in localStorage
        const data = JSON.stringify({ text: text, ipfsHash: ipfsHash });
        await storeFile(hash, data);
        await storeFile(ipfsHash, hash);

        return ipfsHash;
    }

    async function getOfferData(hash) {
        // Check if the hash is an IPFS hash or a text hash
        let ipfsHash = hash;
        var cached = '';
        var text = '';
        if (hash.length !== 46) { // IPFS hashes are 46 characters long
            // Look up the hash in localStorage
            cached = await getFile(hash);
            if (!Array.isArray(cached)) {
                text = JSON.parse(cached).text;
                return text;
            }
        } else {
            cached = await getFile(hash);
            if (!Array.isArray(cached)) {
                cached = await getFile(cached);
                if (!Array.isArray(cached)) {
                    text = JSON.parse(cached).text;
                    try {
                        const mytest = JSON.parse(text);
                        return text;
                    } catch {
                        console.log("Fetching data")
                    }                    
                }
            }
        }
        // Get the text from Pinata IPFS using the IPFS hash
        text = await retrieveFromPinataIPFS(ipfsHash);
        if(text == "error") {
            text = await retrieveFromIPFS(ipfsHash);
            if(text == "error") {
              return "error";
            }
        }

        // Hash the text using web3 keccak and check if it matches the stored text hash
        hash = web3.utils.keccak256(text);
        // Store the hashed text and IPFS hash in localStorage
        const data = JSON.stringify({ text: text, ipfsHash: ipfsHash });
        await storeFile(hash, data);
        await storeFile(ipfsHash, hash);
        return text;
    }

    var pinataApiKey = '';    
    var pinataSecretApiKey = '';
    var pinataGateway = 'https://azure-faithful-anteater-219.mypinata.cloud/ipfs/';
    var pinataToken = 'vgbqHzLAN_A5OI0suZED_RyzKacw5SfNjq25y45oB_CMVoOa1T4IfNrDJOkGysCP';
    // Function to post a file to Pinata IPFS
    async function pinToPinataIPFS (text) {
        const url = 'https://api.pinata.cloud/pinning/pinFILEToIPFS';

        const formData = new FormData();
        const blob = new Blob([text], { type: 'text/plain' });
        formData.append('file', blob, 'file.txt');
        try {
            const response = await axios.post(url, formData, {
                headers: {
                    'Content-Type': `multipart/form-data; boundary=${formData._boundary}`,
                    'pinata_api_key': pinataApiKey,
                    'pinata_secret_api_key': pinataSecretApiKey
                }
            });
            console.log(response.data.IpfsHash);
            return DOMPurify.sanitize(response.data.IpfsHash);
        } catch (error) {
            console.log(error);
            return 'error';
        }
    };

    var maxFileSize = (1024 * 1024) * 7;
    async function customFetch(url, maxSize, onProgress) {
      return new Promise((resolve, reject) => {
        let downloadedContent = ''; // Accumulate downloaded content
        fetch(url).then(response => {
          if (!response.ok) {
            reject(new Error(`Network response was not ok: ${response.statusText}`));
            return;
          }

          const reader = response.body.getReader();

          function read() {
            reader.read().then(({ done, value }) => {
              if (done) {
                resolve(downloadedContent);
                return;
              }

              // Check if the downloaded content exceeds the maxSize
              if (downloadedContent.length + value.length > maxSize) {
                reject(new Error('File size exceeds the maximum allowed size.'));
                return;
              }

              // Update downloaded content
              downloadedContent += new TextDecoder().decode(value);

              // Call the onProgress callback with the current progress
              onProgress(downloadedContent.length);

              // Continue reading the next chunk
              read();
            });
          }

          // Start reading the response stream
          read();
        }).catch(error => {
          reject(error);
        });
      });
    }

    // Function to retrieve a file from IPFS
    const retrieveFromIPFS = async (hash) => {
      var url = "https://ipfs.io/ipfs/"+hash;
      try {
        //const response = await fetch(url);
        const response = await customFetch(url, maxFileSize, progress => {
          //console.log(`Download progress: ${progress} bytes`);
          //Users may potentially be notified about download progress of files
        });
        //var result = await response.text();
        var result = DOMPurify.sanitize(response);
      } catch (error) {
        console.error(`Error during download: ${error.message}`);
        return "error";
      }
      return result;
    }
    const retrieveFromPinataIPFS = async (hash) => {
      var url = pinataGateway + hash;
      if(pinataGateway != "https://gateway.pinata.cloud/ipfs/") {
          if(pinataToken == '') {
              url = "https://gateway.pinata.cloud/ipfs/" + hash;
          } else {
              url += "?pinataGatewayToken=" + pinataToken;
          }
      }
      try {
        //const response = await fetch(url);
        const response = await customFetch(url, maxFileSize, progress => {
          //console.log(`Download progress: ${progress} bytes`);
          //Users may potentially be notified about download progress of files
        });
        //var result = await response.text();
        var result = DOMPurify.sanitize(response);
      } catch (error) {
        console.error(`Error during download: ${error.message}`);
        return "error";
      }
      return result;
    };

    async function checkMarketUpdate() {
      const ONE_HOUR_IN_MS = 900000; // 15 minutes in milliseconds
      const lastTimestamp = localStorage.getItem('lastTimestamp');
      var marketsLength = 0;
      await DDEcontract.methods.marketslength().call().then(async function (result) {
        marketsLength = DOMPurify.sanitize(result);
      });
      const currentTimestamp2 = new Date().getTime();

      if (!lastTimestamp) {
        localStorage.setItem('lastTimestamp', currentTimestamp2.toString());
      } else if (currentTimestamp2 - lastTimestamp >= ONE_HOUR_IN_MS) {
        localStorage.setItem('lastTimestamp', currentTimestamp2.toString());
        await loadMarkets(1, 50);
        currentMarketsLength = marketsLength;
        return;
      }

      if (parseInt(currentMarketsLength) !== parseInt(marketsLength)) {
        await loadMarkets(1, 50);
      }
    }    
    //Currently everything is loaded at once with a basic search. There is the option to post key words to the chain
    //although this could get expensive depending on the blockchain. Costs can be reduced by using a p2p search index.
    //Searches check different key words and then they can further check each listing for it's relevant key words.
    //When the markets get larger, searches can be randomized to vary what orders are shown.
    //AI such as WebGPT can be used for content filtration with settings tweaked by the user ideally. If the user doesn't have
    //the graphics card to moderate, they can call a list of volunteer services who run AI WebGPT to filter it(and maybe recommend tags)
    //for them based on their criteria. One way to enforce a search protocol is have those who post to markets do so from a separate contract.
    //This way they can also be the ones required to remove the search tags and the contract manages everything.
    async function loadMarkets(low = 1, high = 1, searchText = '') {        
        var DDEcontract3 = DDEcontract;
        if(DDEcontract == '') {
            DDEcontract3 = DDEcontract2;
        }
        var mlength = 1;
        await DDEcontract3.methods.marketslength().call().then(async function (result) {
            currentMarketsLength = DOMPurify.sanitize(result);
            mlength = result;
        });
        var index = 1;
        if(high > 1 && low != 0 && high <= mlength && low <= high) {
            index = low;
            mlength = high;
        }
        var jsondata = {};
        var sortHits = 0;
        marketOffers['results'] = [];
        if(showOrder == false) {
          var qpar = getQueryParam("o") || "default";
          if(qpar != "default") {
            searchText = "offer:" + qpar;
            document.getElementById('searchText').value = searchText;
          }
          showOrder = true;
        }
        if (searchText !== '') {
          if (Array.isArray(searchText)) {
            var expiredOffers = [];
            for (var myinx = 0; myinx < searchText.length; myinx++) {
              if(myinx == high) {
                break;
              }
              try {
                const hash = searchText[myinx];
                const offerID = DOMPurify.sanitize(await DDEcontract3.methods.userMarketID(hash).call());
                if (offerID == 0) {
                  expiredOffers.push(hash);
                } else {
                  jsondata = await getOrderHash(hash);
                  if(parseInt(jsondata.timelimit[1]) != 0) {
                    if(parseInt(jsondata.timelimit[1]) > parseInt(CurrentTimeStamp)) {
                      if(!marketOffers.hasOwnProperty(offerID)) {
                          marketOffers.indices.push(offerID);
                      }
                      marketOffers[offerID] = hash;
                      marketOffers[hash] = jsondata;
                      if(!marketOffers['results'].includes(hash)) {
                          marketOffers.results.push(hash);
                      }
                    } else {
                      expiredOffers.push(hash);
                    }
                  } else {
                    if(!marketOffers.hasOwnProperty(offerID)) {
                        marketOffers.indices.push(offerID);
                    }
                    marketOffers[offerID] = hash;
                    marketOffers[hash] = jsondata;
                    if(!marketOffers['results'].includes(hash)) {
                        marketOffers.results.push(hash);
                    }
                  }
                }
                await populateListings("", 2);
              } catch (e) {
                  console.log("Error loading offer: ",e);
              }
            }
            if(expiredOffers.length > 0) {
              for (var myinx = 0; myinx < expiredOffers.length; myinx++) {
                myFavorites.splice(myFavorites.indexOf(expiredOffers[myinx]),1);
              }
              localStorage.setItem(myaccounts + ':myFavorites', JSON.stringify(myFavorites));
            }
            await populateListings("", 2);
            return;
          } else if(searchText.includes("userStore:")){
            var expiredOffers = [];
            const userAddress = searchText.split("userStore:")[1].trim();
            var added = 0;
            try {
              var mylen = 0;
              if(!web3.utils.isAddress(userAddress)) {
              } else {
                mylen = DOMPurify.sanitize(await DDEcontract3.methods.getArrayLength(userAddress, 0).call());
                var cached = localStorage.getItem(userAddress+":userStoreCache");
                if (cached) {
                  expiredOffers = JSON.parse(cached);
                }
              }
              var validOffers = 0;
              for (var myinx = 0; myinx < mylen; myinx++) {
                if(validOffers == high) {
                  break;
                }
                if(expiredOffers.includes(myinx)) {
                  continue;
                }
                validOffers++;
                try {
                  const hash = DOMPurify.sanitize(await DDEcontract3.methods.openOffers(userAddress, myinx).call());
                  const offerID = DOMPurify.sanitize(await DDEcontract3.methods.userMarketID(hash).call());
                  if (offerID == 0) {
                    expiredOffers.push(myinx);
                    added = 1;
                  } else {
                    jsondata = await getOrderHash(hash);
                    if(parseInt(jsondata.timelimit[1]) != 0) {
                      if(parseInt(jsondata.timelimit[1]) > parseInt(CurrentTimeStamp)) {
                        if(!marketOffers.hasOwnProperty(offerID)) {
                            marketOffers.indices.push(offerID);
                        }
                        marketOffers[offerID] = hash;
                        marketOffers[hash] = jsondata;
                        if(!marketOffers['results'].includes(hash)) {
                            marketOffers.results.push(hash);
                        }
                      } else {
                        expiredOffers.push(myinx);
                        added = 1;
                      }
                    } else {
                        if(!marketOffers.hasOwnProperty(offerID)) {
                            marketOffers.indices.push(offerID);
                        }
                        marketOffers[offerID] = hash;
                        marketOffers[hash] = jsondata;
                        if(!marketOffers['results'].includes(hash)) {
                            marketOffers.results.push(hash);
                        }
                    }
                  }
                  await populateListings("", 2);
                } catch (e) {
                    console.log("Error loading offer: ",e);
                }
              }
              if(expiredOffers.length > 0 && added == 1) {
                localStorage.setItem(userAddress + ':userStoreCache', JSON.stringify(expiredOffers));
              }
            } catch (e) {
              console.log("Error loading offer: ",e);
            }
            await populateListings("", 2);
            return;
          } else if(searchText.includes("offer:")){
            const hash = searchText.split("offer:")[1].trim();
            try {
              const offerID = DOMPurify.sanitize(await DDEcontract3.methods.userMarketID(hash).call());
              if (offerID == 0) {
              } else {
                jsondata = await getOrderHash(hash);
                if(parseInt(jsondata.timelimit[1]) != 0) {
                  if(parseInt(jsondata.timelimit[1]) > parseInt(CurrentTimeStamp)) {
                    if(!marketOffers.hasOwnProperty(offerID)) {
                        marketOffers.indices.push(offerID);
                    }
                    marketOffers[offerID] = hash;
                    marketOffers[hash] = jsondata;
                    if(!marketOffers['results'].includes(hash)) {
                        marketOffers.results.push(hash);
                    }
                  }
                } else {
                  if(!marketOffers.hasOwnProperty(offerID)) {
                      marketOffers.indices.push(offerID);
                  }
                  marketOffers[offerID] = hash;
                  marketOffers[hash] = jsondata;
                  if(!marketOffers['results'].includes(hash)) {
                      marketOffers.results.push(hash);
                  }
                }
              }
            } catch (e) {
                console.log("Error loading offer: ",e);
            }
            await populateListings("", 2);
            return;
          } else {
            sortHits = 1;
            const keywords = searchText.split(/[,\s]+/); // Split by commas and one or more whitespace characters            
            await Promise.all(keywords.map(async keyword => {
                // Perform operations on each keyword
                if (keyword.length === 0) {
                    return; // Skip further execution for empty keyword
                }
                let keywordIndex = 0; // Declare a separate index for each keyword iteration
                let keywordLength = 0;
                await DDEcontract3.methods.taglength(keyword.toLowerCase()).call().then(async function (result) {
                    keywordIndex = 0;
                    keywordLength = parseInt(DOMPurify.sanitize(result));
                    if(high > 1 && low >= 0 && high <= keywordLength && low <= high) {
                        keywordIndex = low;
                        keywordLength = high;
                    }
                    for (keywordIndex; keywordIndex < keywordLength; keywordIndex++) {
                        try {
                            await DDEcontract3.methods.hashtag(keyword.toLowerCase(), keywordIndex).call().then(async function (hash) {
                                hash = DOMPurify.sanitize(hash);
                                if(hash == "0x0000000000000000000000000000000000000000000000000000000000000000") {
                                    return;
                                }
                                const offerID = DOMPurify.sanitize(await DDEcontract3.methods.userMarketID(hash).call());
                                if (offerID == 0) {
                                  return;
                                } 
                                if(hash in marketOffers) {
                                  if(!('searchTerms' in marketOffers[hash])) {
                                    marketOffers[hash]['searchTerms'] = [];
                                  }
                                  if(!marketOffers[hash]['searchTerms'].includes(keyword.toLowerCase())) {
                                      marketOffers[hash]['searchTerms'].push(keyword.toLowerCase())
                                  }
                                  jsondata = marketOffers[hash];
                                } else {
                                  if(!marketOffers.hasOwnProperty(offerID)) {
                                      marketOffers.indices.push(offerID);
                                  }
                                  marketOffers[offerID] = hash;
                                  jsondata = await getOrderHash(hash);
                                  if(parseInt(jsondata.timelimit[1]) != 0) {
                                      if(parseInt(jsondata.timelimit[1]) > parseInt(CurrentTimeStamp)) {
                                          marketOffers[hash] = jsondata;
                                      } else {
                                        return;
                                      }
                                  } else {
                                      marketOffers[hash] = jsondata;
                                  }
                                  if(!('searchTerms' in marketOffers[hash])) {
                                    marketOffers[hash]['searchTerms'] = [];
                                  }
                                  if(!marketOffers[hash]['searchTerms'].includes(keyword.toLowerCase())) {
                                      marketOffers[hash]['searchTerms'].push(keyword.toLowerCase())
                                  }
                                }
                                if(!marketOffers['results'].includes(hash)) {
                                    marketOffers.results.push(hash);
                                }
                            });
                            await populateListings("", 1);
                        } catch (e) {
                            console.log("Error loading offer: ",e);
                        }
                    }
                });
            }));
            if(marketOffers.results.length==0) {
                await populateListings(searchText);
            } else {
                await populateListings("", 1);
            }
            return;
          }
        } else {
            var searchThis = [];
            for (index; index < mlength; index++) {
                searchThis = [];
                try {
                    await DDEcontract3.methods.markets(index).call().then(async function (hash) {
                        hash = DOMPurify.sanitize(hash);
                        jsondata = await getOrderHash(hash);
                        if(parseInt(jsondata.timelimit[1]) != 0) {
                            if(parseInt(jsondata.timelimit[1]) > parseInt(CurrentTimeStamp)) {
                                if(!marketOffers.hasOwnProperty(index)) {
                                    marketOffers.indices.push(index);
                                }
                                marketOffers[index] = hash;
                                if(hash in marketOffers) {
                                    searchThis = marketOffers[hash]['searchTerms'];
                                }
                                marketOffers[hash] = jsondata;
                                marketOffers[hash]['searchTerms'] = searchThis;
                            } else {
                              return;
                            }
                        } else {
                            if(!marketOffers.hasOwnProperty(index)) {
                                marketOffers.indices.push(index);
                            }
                            marketOffers[index] = hash;
                            if(hash in marketOffers) {
                                searchThis = marketOffers[hash]['searchTerms'];
                            }
                            marketOffers[hash] = jsondata;
                            marketOffers[hash]['searchTerms'] = searchThis;
                        }
                        if(!marketOffers['results'].includes(hash)) {
                            marketOffers.results.push(hash);
                        }
                    });
                    await populateListings();
                } catch (e) {
                    console.log("Error loading offer: ",e);
                }
            }
        }
        if(DDEcontract == '') {
            await populateListings("", sortHits);
        }
    }

    function sortByHits() {
      marketOffers['results'].sort((hashA, hashB) => {
        const hitsA = marketOffers[hashA]['searchTerms'].length;
        const hitsB = marketOffers[hashB]['searchTerms'].length;
        return hitsB - hitsA; // Sort in descending order based on the number of hits
      });
    }
    function sortByAmountHigh() {
      marketOffers['results'].sort((hashA, hashB) => {
        const amountA = marketOffers[hashA]['amount'];
        const amountB = marketOffers[hashB]['amount'];
        return amountB - amountA; // Sort in descending order based on the 'amount' key
      });
    }
    function sortByAmountLow() {
      marketOffers['results'].sort((hashA, hashB) => {
        const amountA = marketOffers[hashA]['amount'];
        const amountB = marketOffers[hashB]['amount'];
        return amountA - amountB; // Sort in ascending order based on the 'amount' key
      });
    }

    async function getOrderHash(hash) {
        var jsondata = {};
        var DDEcontract3 = DDEcontract;
        if(DDEcontract == '') {
            DDEcontract3 = DDEcontract2;
        }
        await DDEcontract3.methods.getContract(DOMPurify.sanitize(hash)).call().then(async function (data) {
          var text = '';
          try {
            text = await getOfferData(DOMPurify.sanitize(data.message));
            //if(text=="error") {
            //  return false
            //}
            try {
              var testdata = JSON.parse(text);
              if('recipient' in testdata && 'sender' in testdata) {
                var cached = await getFile(Crypto.SHA256(text));
                if (!Array.isArray(cached)) {
                  text = cached;
                } else {
                  if(DOMPurify.sanitize(data.sender) == myaccounts) {
                    var message = cryptico.decrypt(testdata['sender'].cipher, userprivkey).plaintext;
                    console.log(message)
                    var padding = message.split("#*#*#")[1];
                    if(padding.length > 30) {
                      text = message.split("#*#*#")[0];
                    } else {
                      throw new Error("Not enough padding");
                    }
                  } else if(DOMPurify.sanitize(data.recipient) == myaccounts) {
                    var message = cryptico.decrypt(testdata['recipient'].cipher, userprivkey).plaintext;
                    var padding = message.split("#*#*#")[1];
                    if(padding.length > 30) {
                      text = message.split("#*#*#")[0];
                    } else {
                      throw new Error("Not enough padding");
                    }
                  }
                }
              }
            } catch (e) {
              console.log(e);
              console.log("Decryption failed");
            }
          } catch (e) {
            console.log(e);
          }
          jsondata = {
            sender: DOMPurify.sanitize(data.sender),
            recipient: DOMPurify.sanitize(data.recipient),
            token: DOMPurify.sanitize(data.token),
            referred: DOMPurify.sanitize(data.referred),
            amount: DOMPurify.sanitize(data.amount),
            depositSender: DOMPurify.sanitize(data.depositSender),
            depositRecipient: DOMPurify.sanitize(data.depositRecipient),
            quantity: [
              DOMPurify.sanitize(data.quantity[0]),
              DOMPurify.sanitize(data.quantity[1]),
            ],
            rfee: DOMPurify.sanitize(data.rfee),
            timelimit: [
              DOMPurify.sanitize(data.timelimit[0]),
              DOMPurify.sanitize(data.timelimit[1]),
              DOMPurify.sanitize(data.timelimit[2]),
            ],
            status: [
              DOMPurify.sanitize(data.status[0]),
              DOMPurify.sanitize(data.status[1]),
            ],
            message:DOMPurify.sanitize(text)
          };
          try {
              var reputation = [0,0,0];
              if(jsondata.sender != "0x0000000000000000000000000000000000000000") {
                reputation = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract3.methods.getCompleted(jsondata.sender).call())));
                jsondata.reputationSender = reputation;
              }
              if(jsondata.recipient != "0x0000000000000000000000000000000000000000") {
                reputation = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract3.methods.getCompleted(jsondata.recipient).call())));
                jsondata.reputationRecipient = reputation;
              }
          } catch (e) {
              console.log("Error loading reputation data");
          }
          try {
              jsondata.tags = [];
              jsondata.tags = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract3.methods.getTags(hash).call())));
          } catch (e) {
              console.log("Error loading tags");
          }
          if(text != '') {
              try {
                  var messageData = JSON.parse(jsondata.message);
                  if('recipient' in messageData && 'cipher' in messageData.recipient) {
                    jsondata.image = [''];
                    jsondata.message = DOMPurify.sanitize(text);
                    jsondata.contact = '';
                  } else {
                    var myimg = Array.isArray(messageData.image) ? messageData.image : [''];
                    storeFile(Crypto.SHA256(JSON.stringify(myimg)), myimg);
                    jsondata.image = Crypto.SHA256(JSON.stringify(myimg));
                    jsondata.message = messageData.message;
                    jsondata.contact = messageData.contact;
                  }
              } catch (e) {
                  console.log("Error loading data");
                  jsondata.image = [''];
                  jsondata.message = DOMPurify.sanitize(text);
                  jsondata.contact = '';
              }
          } else {
              jsondata.image = [''];
              jsondata.message = '';
          }
          jsondata.hash = hash;
        });
        return jsondata;
    }
    lastNotified = 0;
    async function populateOffers() {
      var list = document.createElement("ul");
      var readMessages = JSON.parse(localStorage.getItem(myaccounts+":readmessages")) || {};
      var notifications = JSON.parse(localStorage.getItem(myaccounts+":notifications")) || {};
      var mylen = 0;
      var notify = 0;
      var myhash = '';
      try {
        mylen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(myaccounts, 0).call());
      } catch(error) {
        console.log(error);
      }
      for (var i = 0; i < mylen; i++) {
        if (readMessages[i]) {
          continue;
        }
        try {
          const offerHash = DOMPurify.sanitize(await DDEcontract.methods.openOffers(myaccounts, i).call());
          const offerID = DOMPurify.sanitize(await DDEcontract.methods.userMarketID(offerHash).call());
          if (offerID == 0) {
            readMessages[i] = true;
            localStorage.setItem(myaccounts+":readmessages", JSON.stringify(readMessages));
            continue;
          }
          const offerData = await getOrderHash(offerHash);
          if(parseInt(offerData.timelimit[1]) != 0) {
            if(parseInt(offerData.timelimit[1]) <= parseInt(CurrentTimeStamp)) {
              if(offerData.sender != "0x0000000000000000000000000000000000000000" && offerData.recipient != "0x0000000000000000000000000000000000000000") {
                readMessages[i] = true;
                localStorage.setItem(myaccounts+":readmessages", JSON.stringify(readMessages));
                continue;
              }
            }
          }
          const li = document.createElement("listElement");
          const counterpartyAddress = offerData.sender === myaccounts ? offerData.recipient : offerData.sender;
          const counterpartyLabel = counterpartyAddress === "0x0000000000000000000000000000000000000000" ? translateThis("Market Offer") : counterpartyAddress;
          const svgString = jdenticon.toSvg(offerHash, 25);
          const base64String = btoa(svgString);
          const dataUrl = `data:image/svg+xml;base64,${base64String}`;
          var offerHashDisp = offerHash;
          if(window.innerWidth < 550) {
            offerHashDisp = offerHashDisp.substring(0, 32) + '...';
          }
          li.innerHTML = `
            <div><bdo>` + translateThis('Order hash:') + `</bdo> <img src="${dataUrl}" width="25" height="25"></img> ${offerHashDisp}</div>
            <div><bdo>` + translateThis('Counter-Party Address:') + `</bdo> ${counterpartyLabel}</div>
            <div><bdo>` + translateThis('Token:') + `</bdo> ${offerData.token}</div>
            <div><bdo>` + translateThis('Amount:') + `</bdo> ${displayDecimals(offerData.token, offerData.amount)}</div>
            <div><bdo>` + translateThis('Quantity:') + `</bdo> ${parseInt(offerData.quantity[0])}` + translateThis('(Total)') + ` - ${parseInt(offerData.quantity[1])}` + translateThis('(Maximum)') + `</div>
            <div><bdo>` + translateThis('Time Limit:') + `</bdo> ${parseInt(offerData.timelimit[0]) / (60 * 60 * 24 * 7)} ` + translateThis('weeks') + `</div>
            <div><bdo>` + translateThis('Message:') + `</bdo> ${offerData.message.slice(0, 20)}...</div><br>
          `;
          myhash = web3.utils.keccak256(li.innerHTML);
          if(offerHash in notifications) {
            if(notifications[offerHash] != myhash) {
                notifications[offerHash] = myhash;
                notify = 1;
            }
          } else {
            notifications[offerHash] = myhash;
            notify = 1;
          }
          li.onclick = function() {
            document.getElementById("offersButton").style.backgroundColor = "#f2f2f2";
            showListing(offerData, 1);
          };
          list.appendChild(li);
        } catch (error) {
          console.log(error);
        }
      }
      if(notify == 1) {
        document.getElementById("offersButton").style.backgroundColor = "silver";
      }
      localStorage.setItem(myaccounts+":notifications", JSON.stringify(notifications));
      notify = 0;
      notifications = JSON.parse(localStorage.getItem(myaccounts+":notifications2")) || {};
      var list2 = document.createElement("ul");
      readMessages = JSON.parse(localStorage.getItem(myaccounts+":readmessages2")) || {};
      try {
        mylen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(myaccounts, 1).call());
      } catch(error) {
        console.log(error);
      }
      for (i = 0; i < mylen; i++) {
        if (readMessages[i]) {
          continue;
        }
        try {
          const offerHash2 = DOMPurify.sanitize(await DDEcontract.methods.privateOffers(myaccounts, i).call());
          const offerData2 = await getOrderHash(offerHash2);
          if(offerData2.message.includes('"recipient":') && offerData2.message.includes('"cipher":') && offerData2.message.includes('"status":')) {
            const testThis = JSON.parse(offerData2.message)
            if('recipient' in testThis && 'cipher' in testThis.recipient && parseInt(new Date().getTime()/1000) > lastNotified + 300) {
              lastNotified = parseInt(new Date().getTime()/1000);
              await Swal.fire(translateThis("Decryption error! Please attempt to decrypt your order manually with the correct password."));
            }
          }
          if (offerData2.status[0] > 0 && offerData2.status[1] > 0) {
            readMessages[i] = true;
            localStorage.setItem(myaccounts+":readmessages2", JSON.stringify(readMessages));
            continue;
          }
          if(parseInt(offerData2.timelimit[1]) != 0) {
            if(parseInt(offerData2.timelimit[1]) <= parseInt(CurrentTimeStamp)) {
              readMessages[i] = true;
              localStorage.setItem(myaccounts+":readmessages2", JSON.stringify(readMessages));
              continue;
            }
          }
          const li2 = document.createElement("listElement");
          const counterpartyAddress2 = offerData2.sender === myaccounts ? offerData2.recipient : offerData2.sender;
          const counterpartyLabel2 = counterpartyAddress2;
          const svgString2 = jdenticon.toSvg(offerHash2, 25);
          const base64String2 = btoa(svgString2);
          const dataUrl2 = `data:image/svg+xml;base64,${base64String2}`;
          var offerHashDisp2 = offerHash2;
          if(window.innerWidth < 550) {
            offerHashDisp2 = offerHashDisp2.substring(0, 32) + '...';
          }
          li2.innerHTML = `
            <div><bdo>` + translateThis('Order hash:') + `</bdo> <img src="${dataUrl2}" width="25" height="25"></img> ${offerHashDisp2}</div>
            <div><bdo>` + translateThis('Counter-Party Address:') + `</bdo> ${counterpartyLabel2}</div>
            <div><bdo>` + translateThis('Token:') + `</bdo> ${offerData2.token}</div>
            <div><bdo>` + translateThis('Amount:') + `</bdo> ${displayDecimals(offerData2.token, offerData2.amount)}</div>
            <div><bdo>` + translateThis('Quantity:') + `</bdo> ${parseInt(offerData2.quantity[0])}</div>
            <div><bdo>` + translateThis('Time Limit:') + `</bdo> ${parseInt(offerData2.timelimit[0]) / (60 * 60 * 24 * 7)} ` + translateThis('weeks') + `</div>
            <div><bdo>` + translateThis('Message:') + `</bdo> ${offerData2.message.slice(0, 20)}...</div><br>
          `;          
          myhash = web3.utils.keccak256(li2.innerHTML);
          if(offerHash2 in notifications) {
            if(notifications[offerHash2] != myhash) {
                notifications[offerHash2] = myhash;
                notify = 1;
            }
          } else {
            notifications[offerHash2] = myhash;
            notify = 1;
          }
          offerData2.index = i;
          if(myaccounts == offerData2.sender && offerData2.status[0] == 1) {
            li2.onclick = function() {
              document.getElementById("offersButton").style.backgroundColor = "#f2f2f2";
              showListing(offerData2, 1);
            };
            list.appendChild(li2);
          }
          if(myaccounts == offerData2.sender && offerData2.status[0] == 0) {
            li2.onclick = function() {
              document.getElementById("offersButton").style.backgroundColor = "#f2f2f2";
              showListing(offerData2, 2);
            };
            list2.appendChild(li2);
          }
          if(myaccounts == offerData2.recipient && offerData2.status[1] == 1) {
            li2.onclick = function() {
              document.getElementById("offersButton").style.backgroundColor = "#f2f2f2";
              showListing(offerData2, 1);
            };
            list.appendChild(li2);
          }
          if(myaccounts == offerData2.recipient && offerData2.status[1] == 0) {
            li2.onclick = function() {
              document.getElementById("offersButton").style.backgroundColor = "#f2f2f2";
              showListing(offerData2, 2);
            };
            list2.appendChild(li2);
          }
        } catch (error) {
          console.log(error);
        }
      }
      if(notify == 1) {
        document.getElementById("offersButton").style.backgroundColor = "silver";
      }
      localStorage.setItem(myaccounts+":notifications2", JSON.stringify(notifications));
      notify = 0;
      notifications = JSON.parse(localStorage.getItem(myaccounts+":notifications3")) || {};
      const offersContainer = document.getElementById("myoffers");
      offersContainer.innerHTML = ""; // clear the container first
      offersContainer.classList.add("offers-container");

      const sentOffersHeader = document.createElement("div");
      sentOffersHeader.classList.add("offers-header");
      sentOffersHeader.textContent = translateThis("Sent Offers");
      //offersContainer.appendChild(sentOffersHeader);
      list.setAttribute("style", "border: 1px solid black; padding: 1rem; margin-bottom: 1rem; cursor: pointer; background-color: #f8f8f8;");
      //offersContainer.appendChild(list);

      const receivedOffersHeader = document.createElement("div");
      receivedOffersHeader.classList.add("offers-header");
      receivedOffersHeader.textContent = translateThis("Received Offers");
      //offersContainer.appendChild(receivedOffersHeader);
      list2.setAttribute("style", "border: 1px solid black; padding: 1rem; margin-bottom: 1rem; cursor: pointer; background-color: #f8f8f8;");
      //offersContainer.appendChild(list2);

      const sentContainer = document.createElement("div");
      sentContainer.id = "senttab";
      sentContainer.classList.add("tabcontent");
      sentContainer.appendChild(sentOffersHeader);
      sentContainer.appendChild(list);

      const receivedContainer = document.createElement("div");
      receivedContainer.id = "receivedtab";
      receivedContainer.classList.add("tabcontent");
      receivedContainer.appendChild(receivedOffersHeader);
      receivedContainer.appendChild(list2);

      const tabContainer = document.createElement("div");
      tabContainer.innerHTML = `
        <div class="offers-tab-container">
          <button class="tablinks" onclick="openTab(event, 'senttab')">` + translateThis('Sent Offers') + `</button>
          <button class="tablinks" onclick="openTab(event, 'receivedtab')">` + translateThis('Received Offers') + `</button>
          <br><br>
        </div>
      `;
      tabContainer.appendChild(sentContainer);
      tabContainer.appendChild(receivedContainer);
      offersContainer.appendChild(tabContainer);

      var list3 = document.createElement("ul");
      readMessages = JSON.parse(localStorage.getItem(myaccounts+":readmessages3")) || {};
      try {
        mylen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(myaccounts, 2).call());
      } catch(error) {
        console.log(error);
      }
      for (i = 0; i < mylen; i++) {
        if (readMessages[i]) {
          continue;
        }
        try {
          const offerHash3 = DOMPurify.sanitize(await DDEcontract.methods.escrows(myaccounts, i).call());
          const offerData3 = await getOrderHash(offerHash3);
          if (offerData3.status[0] == 4 || offerData3.status[1] == 4) {
            if (autoClearCheckbox.checked) {
                readMessages[i] = true;
                localStorage.setItem(myaccounts+":readmessages3", JSON.stringify(readMessages));
                continue;
            }
          }
          const li3 = document.createElement("listElement");
          const counterpartyAddress3 = offerData3.sender === myaccounts ? offerData3.recipient : offerData3.sender;
          const counterpartyLabel3 = counterpartyAddress3;
          const svgString3 = jdenticon.toSvg(offerHash3, 25);
          const base64String3 = btoa(svgString3);
          const dataUrl3 = `data:image/svg+xml;base64,${base64String3}`;

          const currentBlockNumber = await web3.eth.getBlockNumber();
          const currentBlock = await web3.eth.getBlock(currentBlockNumber);
          const blockTimestamp = DOMPurify.sanitize(currentBlock.timestamp);
          const timeRemaining = (parseFloat(parseInt(offerData3.timelimit[0]) - parseInt(blockTimestamp)) / parseFloat(60 * 60 * 24)).toFixed(2);
          var offerHashDisp3 = offerHash3;
          if(window.innerWidth < 550) {
            offerHashDisp3 = offerHashDisp3.substring(0, 32) + '...';
          }
          li3.innerHTML = `
            <div><bdo>` + translateThis('Order hash:') + `</bdo> <img src="${dataUrl3}" width="25" height="25"></img> ${offerHashDisp3}</div>
            <div><bdo>` + translateThis('Counter-Party Address:') + `</bdo> ${counterpartyLabel3}</div>
            <div><bdo>` + translateThis('Token:') + `</bdo> ${offerData3.token}</div>
            <div><bdo>` + translateThis('Amount:') + `</bdo> ${displayDecimals(offerData3.token, offerData3.amount)}</div>
            <div><bdo>` + translateThis('Quantity:') + `</bdo> ${parseInt(offerData3.quantity[0])}</div>
            <div><bdo>` + translateThis('Time Until Funds Expire:') + `</bdo> ${timeRemaining} ` + translateThis('days') + `</div>
          `;
          offerData3.timeRemaining = timeRemaining;
          var escrowInfo = '';
          if (offerData3.status[0] != 4 && offerData3.status[1] != 4) {
              if(parseFloat(timeRemaining) < parseFloat(2)) {
                escrowInfo += "<div>" + translateThis('WARNING: Funds are about to expire. Resolve the escrow with your counter-party or all funds risk being burned.') + "</div>";
              }
              if(parseFloat(timeRemaining) <= parseFloat(0)) {
                escrowInfo += "<div>" + translateThis("The time limit has expired and the funds have been burned. This contract is no longer available.") + "</div>";
                offerData3.expired = 2;
              }
          }
          var skipthis = 0;
          if(offerData3.timelimit[0] == offerData3.timelimit[1] && offerData3.timelimit[1] == offerData3.timelimit[2]) {
            skipthis = 1;
          }
          if(offerData3.timelimit[1] != 0 && skipthis != 1) {            
            const timeExtension = Math.abs(parseFloat(parseInt(offerData3.timelimit[1]) - parseInt(offerData3.timelimit[0])) / parseFloat(60 * 60 * 24)).toFixed(2);
            escrowInfo += "<div>" + translateThis("Sender has requested a time extension for: ") + timeExtension + " " + translateThis("days") + "</div>";
          }
          if(offerData3.timelimit[2] != 0 && skipthis != 1) {            
            const timeExtension2 = Math.abs(parseFloat(parseInt(offerData3.timelimit[2]) - parseInt(offerData3.timelimit[0])) / parseFloat(60 * 60 * 24)).toFixed(2);
            escrowInfo += "<div>" + translateThis("Recipient has requested a time extension for: ") + timeExtension2 + " " + translateThis("days") + "</div>";
          }
          if (skipthis == 1) {
            escrowInfo += "<div>" + translateThis("Time extension granted.") + "</div>";
          }
          if (offerData3.status[0] == 2) {
            if(myaccounts == offerData3.sender) {
                escrowInfo += "<div>" + translateThis("Completion request sent!") + "</div>";
            } else {
                escrowInfo += "<div>" + translateThis("Completion request received!") + "</div>";
            }
          }
          if (offerData3.status[0] == 3) {
            if(myaccounts == offerData3.sender) {
                escrowInfo += "<div>" + translateThis("Completion request received!") + "</div>";
            } else {
                escrowInfo += "<div>" + translateThis("Completion request sent!") + "</div>";
            }
          }
          if (offerData3.status[1] == 2) {
            if(myaccounts == offerData3.sender) {
                escrowInfo += "<div>" + translateThis("Cancellation request sent!") + "</div>";
            } else {
                escrowInfo += "<div>" + translateThis("Cancellation request received!") + "</div>";
            }
          }
          if (offerData3.status[1] == 3) {
            if(myaccounts == offerData3.sender) {
                escrowInfo += "<div>" + translateThis("Cancellation request received!") + "</div>";
            } else {
                escrowInfo += "<div>" + translateThis("Cancellation request sent!") + "</div>";
            }
          }
          if (offerData3.status[0] == 4 || offerData3.status[1] == 4) {
            if(offerData3.status[0] == 4) {
                escrowInfo += "<div>" + translateThis("Contract completed!") + "</div>";;
            }
            if(offerData3.status[1] == 4) {
                escrowInfo += "<div>" + translateThis("Contract cancelled!") + "</div>";;
            }
            offerData3.expired = 1;
          }
          offerData3.escrowInfo = escrowInfo;
          li3.innerHTML += escrowInfo;
          li3.innerHTML += `<div>` + translateThis("Message:") + `${offerData3.message.slice(0, 20)}...</div><br>`
          const lineToExcludeRegex = new RegExp("<div>" + translateThis("Time Until Funds Expire:") + ".*" + translateThis("days") + "</div>");
          const inputString = li3.innerHTML.replace(lineToExcludeRegex, '');
          myhash = web3.utils.keccak256(inputString);
          if(offerHash3 in notifications) {
            if(notifications[offerHash3] != myhash) {
                notifications[offerHash3] = myhash;
                notify = 1;
            }
          } else {
            notifications[offerHash3] = myhash;
            notify = 1;
          }
          offerData3.index = i;          
          li3.onclick = function() {
            document.getElementById("contractsButton").style.backgroundColor = "#f2f2f2";
            showListing(offerData3, 4);
          };
          list3.appendChild(li3);          
        } catch (error) {
          console.log(error);
        }
      }
      if(notify == 1) {
        document.getElementById("contractsButton").style.backgroundColor = "silver";
      }
      localStorage.setItem(myaccounts+":notifications3", JSON.stringify(notifications));
      const escrowContainer = document.getElementById("mycontracts");
      escrowContainer.innerHTML = ""; // clear the container first
      escrowContainer.classList.add("escrow-container");

      const escrowOffersHeader = document.createElement("div");
      escrowOffersHeader.classList.add("escrow-header");
      escrowOffersHeader.textContent = translateThis("Active contracts");
      escrowContainer.appendChild(escrowOffersHeader);
      list3.setAttribute("style", "border: 1px solid black; padding: 1rem; margin-bottom: 1rem; cursor: pointer; background-color: #f8f8f8;");
      escrowContainer.appendChild(list3);
    }
    function openTab(evt, tabName) {
      // Declare all variables
      let i, tabcontent, tablinks;
      // Get all elements with class="tabcontent" and hide them
      tabcontent = document.getElementsByClassName("tabcontent");
      for (i = 0; i < tabcontent.length; i++) {
        tabcontent[i].style.display = "none";
      }
      // Get all elements with class="tablinks" and remove the class "active"
      tablinks = document.getElementsByClassName("tablinks");
      for (i = 0; i < tablinks.length; i++) {
        tablinks[i].classList.remove("active");
      }
      // Show the current tab, and add an "active" class to the button that opened the tab
      document.getElementById(tabName).style.display = "block";
      evt.currentTarget.classList.add("active");
    }

    function showMain(menu) {
        // hide all main divs
        var mains = document.querySelectorAll('.main');
        for (var i = 0; i < mains.length; i++) {
            mains[i].classList.remove('show');
        }

        // show the main div for the selected menu
        var main = document.querySelector('.main.' + menu);
        main.classList.add('show');
    }
    //**************MARKETS TAB//**************
    // global variables for pagination
    var currentPage = 1;
    var listingsPerPage = 10;

    async function populateListings(searchText = "", sortHits = 0) {
        if(sortHits == 1) {
            sortByHits();
        } else {
            var sortBy = document.getElementById("SortBy").value;
            if(sortBy == "price-low") {
                sortByAmountLow();
            }
            if(sortBy == "price-high") {
                sortByAmountHigh();
            } 
        }
        var listingsDiv = document.querySelector('.main.markets .listings');
        listingsDiv.innerHTML = '';

        var startIndex = (currentPage - 1) * listingsPerPage;
        var endIndex = startIndex + listingsPerPage;
        if (endIndex > marketOffers.indices.length) {
            endIndex = marketOffers.indices.length;
        }
        searchText = searchText.toLowerCase();
        if (searchText !== "") {
            endIndex = marketOffers.indices.length;
        }
        var shown = 0;
        var offer;
        var myhashes = {};

        var gridContainer = document.createElement('div');
        gridContainer.classList.add('listings-grid');

        for (var i = startIndex; i < endIndex; i++) {
            if (shown == listingsPerPage) {
                break;
            }
            if (!marketOffers.hasOwnProperty(marketOffers.indices[i])) {
                continue;
            }
            if (parseInt(marketOffers.indices[i]) >= parseInt(currentMarketsLength)) {
                continue;
            }
            if (searchText !== "") {
                if (i < marketOffers.results.length) {
                    offer = marketOffers[marketOffers.results[i]];
                } else {
                    offer = marketOffers[marketOffers[marketOffers.indices[i]]];
                }
                const keywords = searchText.split(/[,\s]+/);
                let foundKeyword = false;

                for (const keyword of keywords) {
                    if (keyword.length === 0) {
                        continue;
                    }
                    if (offer.message.toLowerCase().includes(keyword.toLowerCase())) {
                        foundKeyword = true;
                        break;
                    }
                    try {
                        if (offer['searchTerms'].includes(keyword.toLowerCase())) {
                            foundKeyword = true;
                            break;
                        }
                    } catch {
                        continue;
                    }
                }
                if (!foundKeyword) {
                    continue;
                }
            } else {
                if(marketOffers.results.length > 0 || sortHits == 2) {
                    if (i < marketOffers.results.length) {
                        offer = marketOffers[marketOffers.results[i]];
                    } else {
                        if(sortHits == 2) {
                          continue;
                        }
                        offer = marketOffers[marketOffers[marketOffers.indices[i]]];
                    }
                } else {
                    offer = marketOffers[marketOffers[marketOffers.indices[i]]];
                }
            }
            if (offer.hash in myhashes) {
                continue;
            } else {
                myhashes[offer.hash] = 1;
            }
            var gridItem = document.createElement('div');
            gridItem.classList.add('listing-grid-item');
            var tempimg = '';
            var myimg = await getFile(offer.image);
            if (myimg.length > 0 && myimg != '' && myimg[0] != '') {
                tempimg = '<img src="' + myimg[0] + '" alt="./blank-image.jpg">';
            } else {
                tempimg = '<img src="./blank-image.jpg" alt="">';
            }
            gridItem.innerHTML = `
                <div class="listing-image">${tempimg}</div>
                <div class="listing-details">
                    <div class="token">` + '<bdo class="theText">' + translateThis("Currency:") + '</bdo>'  + ` ${tokennames[offer.token]}</div>
                    <div class="amount">` + '<bdo class="theText">' + translateThis("Amount:") + '</bdo>'  + ` ${displayDecimals(offer.token, offer.amount)}</div>
                    <div class="message">` + '<bdo class="theText">' + translateThis("Details:") + '</bdo>' + ` ${offer.message.slice(0, 20) + (offer.message.length > 20 ? "..." : "")}</div>
                </div>
            `;

            // create a closure to bind the offer variable to the onclick function
            (function (offer) {
                gridItem.onclick = function () {
                    showListing(offer);
                };
            })(offer);

            gridContainer.appendChild(gridItem);
            shown++;
        }

        listingsDiv.appendChild(gridContainer);

        // Inject CSS styles into a style tag
        var style = document.createElement('style');
        style.textContent = `
            .listings-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(210px, 1fr));
                grid-gap: 20px;
            }

            .listing-grid-item {
                border: 1px solid #ccc;
                text-align: center;
                background-color: white;
            }

            .listing-image img {
                max-width: 200px;
                height: auto;
            }
        `;
        document.head.appendChild(style);
    }

    function displayDecimals(token, amountString) {
        var formattedAmount = '';
        for (var i = 0; i < tokens.length; i++) {
            if(tokens[i].address == token) {
                const length = amountString.length;

                if (length <= tokens[i].decimals) {
                  const zerosToAdd = tokens[i].decimals - length;
                  amountString = '0'.repeat(zerosToAdd) + amountString;
                }
                const position = length - tokens[i].decimals;
                formattedAmount = amountString.substring(0, position) + '.' + amountString.substring(position);
                // Remove leading zeros
                formattedAmount = formattedAmount.replace(/^0+/, '');
                // If the string starts with a '.', prepend '0'
                formattedAmount = formattedAmount.replace(/^\./, '0.');
                // Remove trailing zeros
                formattedAmount = formattedAmount.replace(/0+$/, '');
                // If the string ends with a '.', remove it
                formattedAmount = formattedAmount.replace(/\.$/, '');                
                break;
            }
        }
        return formattedAmount || '0';
    }

    // function for searching the listings
    async function searchListings(searchText, deep=0) {
        // filter the marketOffers array based on the searchText
        // and update the currentPage to 1
        currentPage = 1;
        if(deep == 1) {
            document.getElementById("loadingStatus").innerHTML = translateThis("Loading...");
            await loadMarkets(0, 50, searchText);
            document.getElementById("loadingStatus").innerHTML = "";
        } else {
          await populateListings(searchText);
        }
    }

    async function searchFavorites() {
      document.getElementById("loadingStatus").innerHTML = translateThis("Loading...");
      await loadMarkets(0, 50, myFavorites);
      document.getElementById("loadingStatus").innerHTML = "";
    }

    // function for showing the next page of listings
    async function nextPage() {
        if (currentPage < Math.ceil(marketOffers.indices.length / listingsPerPage)) {
            currentPage++;
            await populateListings();
        } else {
            document.getElementById("loadingStatus").innerHTML = translateThis("Loading...");
            await loadMarkets(marketOffers.indices.length, marketOffers.indices.length + 50);
            document.getElementById("loadingStatus").innerHTML = ""
            currentPage++;
            await populateListings();
        }
    }

    // function for showing the previous page of listings
    async function previousPage() {
        if (currentPage > 1) {
            currentPage--;
            await populateListings();
        }
    }
    populateListings();

    // Function to show the details popup for a listing
    async function showListing(listing, mode=0) {
      if(notifyFavorites == "0" && mode == 0) {
        await Swal.fire({
          icon: 'info',
          title: translateThis('Welcome'),
          text: translateThis('Welcome to the markets. As you browse you may choose to add orders to your favorites list by clicking the star. This may function as a useful cart or history for deals you wish to revisit. Please review the amount, currency, deposits, time limit and deal structure carefully before accepting. Always attempt to remain in close contact with your counter-party to ensure success. With that said enjoy using one of the safest escrows in the world!'),
        });
        notifyFavorites = "1";
        localStorage.setItem(myaccounts+":notifyFavorites", notifyFavorites);
      }
      if(listing.message.includes('"recipient":') && listing.message.includes('"cipher":') && listing.message.includes('"status":')) {
        await Swal.fire({
          title: translateThis('Encrypted listing'),
          text: translateThis('It seems like you did not have the decryption key for this order. Would you like to enter the password to decrypt it now?'),
          showCancelButton: true,
          confirmButtonText: translateThis('Yes'),
          cancelButtonText: translateThis('No'),
          icon: 'question',
        }).then(async (result) => {
          if (result.isConfirmed) {
            var thisText = listing.message;
            try {
              userprivkey2='';
              await Swal.fire({
                title: translateThis('Confirm Password'),
                input: 'password',
                inputPlaceholder: translateThis('Please enter decryption password'),
                showCancelButton: true,
                confirmButtonText: translateThis('Confirm Password'),
                cancelButtonText: translateThis('Cancel'),
                preConfirm: async (confirmedPassword) => {
                  var hashedPassword = confirmedPassword;
                  hashedPassword = Crypto.SHA256(hashedPassword);
                  userprivkey2=hashedPassword;
                  for(var i=1; i<50000; i++) {
                    userprivkey2=Crypto.SHA256(userprivkey2);
                  }
                  userprivkey2 = cryptico.generateRSAKey(userprivkey2, 1024);
                }
              });
              var testdata = JSON.parse(thisText);
              var successful = 0;
              if(DOMPurify.sanitize(listing.sender) == myaccounts) {
                var message = cryptico.decrypt(testdata['sender'].cipher, userprivkey2).plaintext;
                var padding = message.split("#*#*#")[1];
                if(padding.length > 30) {
                  thisText = message.split("#*#*#")[0];
                  successful = 1;
                } else {
                  throw new Error("Not enough padding");
                }
              } else if(DOMPurify.sanitize(listing.recipient) == myaccounts) {
                var message = cryptico.decrypt(testdata['recipient'].cipher, userprivkey2).plaintext;
                var padding = message.split("#*#*#")[1];
                if(padding.length > 30) {
                  thisText = message.split("#*#*#")[0];
                  successful = 1;
                } else {
                  throw new Error("Not enough padding");
                }
              }
              if(successful == 0) {
                throw new Error("Failed");
              }
              var messageData = JSON.parse(thisText);
              var myimg = Array.isArray(messageData.image) ? messageData.image : [''];
              storeFile(Crypto.SHA256(JSON.stringify(myimg)), myimg);
              storeFile(Crypto.SHA256(listing.message), thisText);
              listing.image = Crypto.SHA256(JSON.stringify(myimg));
              listing.message = messageData.message;
              listing.contact = messageData.contact;
            } catch (e) {
              console.log(e);
              console.log("Decryption failed");
              await Swal.fire(translateThis("Decryption failed"));
            }
          }
        });
      }
      const popupContainer = document.createElement('div');      
      popupContainer.classList.add('popup-container');

      const popup = document.createElement('div');
      popup.classList.add('popup');      

      const closeButton = document.createElement('span');
      closeButton.innerHTML = '&times;';
      closeButton.classList.add('close-button');
      closeButton.onclick = function() { popupContainer.remove(); };

      const imageContainer = document.createElement('div');
      imageContainer.classList.add('image-container');
      const leftArrow = document.createElement('span');
      leftArrow.innerHTML = '&#10094;';
      leftArrow.classList.add('arrow', 'left-arrow');
      leftArrow.onclick = function() { plusSlides(-1); };
      const rightArrow = document.createElement('span');
      rightArrow.innerHTML = '&#10095;';
      rightArrow.classList.add('arrow', 'right-arrow');
      rightArrow.onclick = function() { plusSlides(1); };
      let slideIndex = 1;

      function plusSlides(n) {
        showSlides(slideIndex += n);
      }

      function showSlides(n) {
        const slides = document.getElementsByClassName('popup-image');
        if (n > slides.length) {
          slideIndex = 1;
        }
        if (n < 1) {
          slideIndex = slides.length;
        }
        for (let i = 0; i < slides.length; i++) {
          slides[i].style.display = 'none';
        }
        slides[slideIndex - 1].style.display = 'block';
      }
      const imageList = document.createElement('ul');
      const arrowsContainer = document.createElement('div');
      var myimgs = await getFile(listing.image);
      if(myimgs.length > 0) {          
          imageList.classList.add('image-list');
          imageList.style.listStyle = 'none'; // remove the dot
          imageList.onclick = function() { plusSlides(1); };
          for (let i = 0; i < myimgs.length; i++) {
            const li = document.createElement('li');
            const img = document.createElement('img');
            img.src = myimgs[i];
            img.classList.add('popup-image');
            li.appendChild(img);
            imageList.appendChild(li);
          }
          
          arrowsContainer.classList.add('arrows-container');
          arrowsContainer.style.position = 'relative';
          leftArrow.style.position = 'absolute';
          leftArrow.style.top = '50%';
          leftArrow.style.left = '0';
          leftArrow.style.transform = 'translateY(-50%)';

          rightArrow.style.position = 'absolute';
          rightArrow.style.top = '50%';
          rightArrow.style.right = '0';
          rightArrow.style.transform = 'translateY(-50%)';

          arrowsContainer.appendChild(leftArrow);
          arrowsContainer.appendChild(rightArrow);

          imageContainer.appendChild(imageList);
          imageContainer.appendChild(arrowsContainer);
      }
      const details = document.createElement('div');
      details.classList.add('popup-details');
      
      function copyToClipboard(mytext) {
        const tempInput = document.createElement('input');
        document.body.appendChild(tempInput);
        tempInput.value = mytext;
        tempInput.select();
        document.execCommand('copy');
        document.body.removeChild(tempInput);
        Swal.fire(translateThis('Address copied to clipboard!'));
      }

      const sender = document.createElement('p');
      var text = "<bdo>" + translateThis("Sender:") + "</bdo> ";
      if(listing.sender == "0x0000000000000000000000000000000000000000") {
        if(myaccounts != listing.recipient) {
            text = translateThis("You are the one paying/sending the funds.");
        } else {
            text = translateThis("You are the one receiving the funds.");
        }
        sender.innerHTML = "<br>" + text;
      } else {        
        sender.innerHTML = "<br>" + text;
        const senderContainer = document.createElement('span');
        const senderTextSpan = document.createElement('span');
        senderTextSpan.style.fontSize = '12px';
        senderTextSpan.textContent = listing.sender;
        senderTextSpan.style.cursor = 'pointer';
        senderTextSpan.style.textDecoration = 'underline';

        const copyButton = document.createElement('button');
        copyButton.textContent = '📄';
        copyButton.onclick = function() {
          copyToClipboard(listing.sender);
        };

        senderTextSpan.onclick = function() {
          Swal.fire({
            title: translateThis('Show listings'),
            text: translateThis('Would you like to see more listings from this user?'),
            showCancelButton: true,
            confirmButtonText: translateThis('Yes'),
            cancelButtonText: translateThis('No'),
            icon: 'question',
          }).then(async (result) => {
            if (result.isConfirmed) {
              popupContainer.remove();
              showMain('markets');
              document.getElementById("searchText").value="userStore:"+listing.sender;
              loadMarkets(0, 50, "userStore:"+listing.sender);
            }
          });
        };

        senderContainer.appendChild(senderTextSpan);
        senderContainer.appendChild(document.createTextNode('\u00A0'));
        senderContainer.appendChild(copyButton);
        sender.appendChild(senderContainer);
      }

      const recipient = document.createElement('p');
      var text2 = "<bdo>" + translateThis("Recipient:") + "</bdo> ";
      if(listing.recipient == "0x0000000000000000000000000000000000000000") {
        if(myaccounts != listing.sender) {
            text2 = translateThis("You are the one receiving the funds.");            
        } else {
            text2 = translateThis("You are the one paying/sending the funds.");
        }
        recipient.innerHTML = text2;
      } else {
          recipient.innerHTML = text2;
          const recipientContainer = document.createElement('span');
          const recipientTextSpan = document.createElement('span');
          recipientTextSpan.style.fontSize = '12px';
          recipientTextSpan.textContent = listing.recipient;
          recipientTextSpan.style.cursor = 'pointer';
          recipientTextSpan.style.textDecoration = 'underline';
          const copyButton = document.createElement('button');
          copyButton.textContent = '📄';
          copyButton.onclick = function() {
            copyToClipboard(listing.recipient);
          };
          recipientTextSpan.onclick = function() {
            Swal.fire({
              title: translateThis('Show listings'),
              text: translateThis('Would you like to see more listings from this user?'),
              showCancelButton: true,
              confirmButtonText: translateThis('Yes'),
              cancelButtonText: translateThis('No'),
              icon: 'question',
            }).then(async (result) => {
              if (result.isConfirmed) {
                popupContainer.remove();
                showMain('markets');
                document.getElementById("searchText").value="userStore:"+listing.recipient;
                loadMarkets(0, 50, "userStore:"+listing.recipient);
              }
            });
          };
          recipientContainer.appendChild(recipientTextSpan);
          recipientContainer.appendChild(document.createTextNode('\u00A0'));
          recipientContainer.appendChild(copyButton);
          recipient.appendChild(recipientContainer);
      }

      const token = document.createElement('p');
      token.innerHTML = "<bdo>" + translateThis('Token:') + '</bdo> ' + tokennames[listing.token];

      const amount = document.createElement('p');
      amount.innerHTML = "<bdo>" + translateThis('Amount:') + '</bdo> ' + displayDecimals(listing.token,listing.amount);      

      if(listing.rfee != 0) {
        var theFee = document.createElement('p');
        theFee.innerHTML = "<bdo>" + translateThis('Referral fee(estimated):') + '</bdo> ' + (listing.rfee / 100).toFixed(2) + "%";
      }
      if(listing.referred != "0x0000000000000000000000000000000000000000") {
        var theReferred = document.createElement('p');
        const theReferredTextSpan = document.createElement('span');
        theReferredTextSpan.style.fontSize = '12px';
        theReferredTextSpan.textContent = listing.referred;
        theReferred.innerHTML = "<bdo>" + translateThis('Referral address:') + '</bdo> ';
        theReferred.appendChild(theReferredTextSpan);
      }
      if(listing.tags && listing.tags.length != 0) {
        var theTags = document.createElement('p');
        theTags.innerHTML = translateThis('Tags:') + ' ' + listing.tags.join(', ');
      }

      const depositSender = document.createElement('p');
      depositSender.innerHTML = "<bdo>" + translateThis('Deposit Sender:') + '</bdo> ' + displayDecimals(listing.token,listing.depositSender);
      
      const depositRecipient = document.createElement('p');
      depositRecipient.innerHTML = "<bdo>" + translateThis('Deposit Recipient:') + '</bdo> ' + displayDecimals(listing.token,listing.depositRecipient);
      
      const quantity = document.createElement('p');
      quantity.innerHTML = "<bdo>" + translateThis('Quantity:') + '</bdo> ' + parseInt(listing.quantity[0]);
      if(listing.sender == "0x0000000000000000000000000000000000000000" || listing.recipient == "0x0000000000000000000000000000000000000000" ) {
        quantity.innerHTML = "<bdo>" + translateThis('Quantity:') + '</bdo> ' + parseInt(listing.quantity[0]) + "<bdo>" + translateThis('(Total)') + '</bdo> - ' + parseInt(listing.quantity[1]) + "<bdo>" + translateThis('(Maximum)') + "</bdo>";
      }
      
      const timelimit = document.createElement('p');
      timelimit.innerHTML = "<bdo>" + translateThis('Time limit:') + '</bdo> ' + Math.floor(parseInt(listing.timelimit[0]) / (60 * 60 * 24 * 7)) + ' ' + "<bdo>" + translateThis('weeks') + "</bdo>";

      const message = document.createElement('p');
      message.innerHTML = '<br><bdo>' + translateThis('Details:') + '</bdo><br>' + listing.message;
      if (typeof listing.contact !== 'undefined') {
          message.innerHTML += '<br><br><bdo>' + translateThis('Contact information:') + '</bdo><br>' + listing.contact;
      }
      var contact2 = '';
      var datalen = 0;
      var reputation = [0,0,0];
      if(myaccounts != listing.recipient && listing.recipient != "0x0000000000000000000000000000000000000000" && DDEcontract != '') {
        try {
            datalen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(listing.recipient, 3).call());
            if(datalen > 0) {
              contact2 = JSON.parse(DOMPurify.sanitize(await DDEcontract.methods.userdata(listing.recipient, datalen-1).call()));
              if(typeof contact2 === 'object' && 'mycontact' in contact2) {
                if(listing.contact != contact2['mycontact']) {
                    message.innerHTML += '<br><br><bdo>' + translateThis('Recipients contact information:') + '</bdo><br>' + contact2['mycontact'];
                }
              }
            }
            reputation = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract.methods.getCompleted(listing.recipient).call())));
            if(reputation[0] == 0 && reputation[1] == 0) {
              message.innerHTML += '<br><br>' + translateThis('Recipient is a new user of the markets.') + '<br>';
            } else {
              message.innerHTML += '<br><br>' + translateThis('Recipients success rate:') + '<br><bdo>' + translateThis('Completed:') + '</bdo> ' + reputation[0] + '<br><bdo>' + translateThis('Failed:') + '</bdo> ' + reputation[1];
            }
        } catch(e) {
            console.log(e);
        }
      }
      if(myaccounts != listing.sender && listing.sender != "0x0000000000000000000000000000000000000000" && DDEcontract != '') {
        try {
            datalen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(listing.sender, 3).call());
            if(datalen > 0) {
              contact2 = JSON.parse(DOMPurify.sanitize(await DDEcontract.methods.userdata(listing.sender, datalen-1).call()));
              if(typeof contact2 === 'object' && 'mycontact' in contact2) {
                if(listing.contact != contact2['mycontact']) {
                    message.innerHTML += '<br><br><bdo>' + translateThis('Senders contact information:') + '</bdo><br>' + contact2['mycontact'];
                }
              }
            }
            reputation = JSON.parse(DOMPurify.sanitize(JSON.stringify(await DDEcontract.methods.getCompleted(listing.sender).call())));
            if(reputation[0] == 0 && reputation[1] == 0) {
              message.innerHTML += '<br><br>' + translateThis('Sender is a new user of the markets.') + '<br>';
            } else {
              message.innerHTML += '<br><br>' + translateThis('Senders success rate:') + '<br><bdo>' + translateThis('Completed:') + '</bdo> ' + reputation[0] + '<br><bdo>' + translateThis('Failed:') + '</bdo> ' + reputation[1];
            }
        } catch(e) {
            console.log(e);
        }
      }

      const buttonContainer = document.createElement('div');
      buttonContainer.classList.add('button-container');

      if(mode == 0 || mode == 2) {
          const acceptButton = document.createElement('button');
          acceptButton.innerHTML = translateThis('Accept offer');
          acceptButton.onclick = () => {acceptOffer(listing); popupContainer.remove();};

          const counterButton = document.createElement('button');
          counterButton.innerHTML = translateThis('Counter-offer');
          counterButton.onclick = () => {counterOffer(listing); popupContainer.remove();};

          buttonContainer.appendChild(acceptButton);
          if(parseInt(listing.status[0]) != 2 && parseInt(listing.status[0]) != 3) {
            buttonContainer.appendChild(counterButton);
          }
      }
      if(mode == 1) {
          if(listing.sender == "0x0000000000000000000000000000000000000000" || listing.recipient == "0x0000000000000000000000000000000000000000" ) {
            const quantityButton = document.createElement('button');
            quantityButton.innerHTML = translateThis('Update Quantity');
            quantityButton.onclick = async () => {await updateQuantity(listing); popupContainer.remove();};
            buttonContainer.appendChild(quantityButton);
            const feeButton = document.createElement('button');
            feeButton.innerHTML = translateThis('Edit referral fee');
            feeButton.onclick = async () => {await updateFee(listing); popupContainer.remove();};
            buttonContainer.appendChild(feeButton);
          }
          const cancelButton = document.createElement('button');
          cancelButton.innerHTML = translateThis('Cancel offer');
          cancelButton.onclick = async () => {await cancelOffer(listing); popupContainer.remove();};
          buttonContainer.appendChild(cancelButton);
      }
      if(mode == 2) {
          const cancelButton = document.createElement('button');
          cancelButton.innerHTML = translateThis('Cancel offer');
          cancelButton.onclick = async () => {await cancelOffer(listing, 1); popupContainer.remove();};
          buttonContainer.appendChild(cancelButton);
      }
      if(mode == 3) {
          imageContainer.style.display = 'none';
          arrowsContainer.style.display = 'none';
          const confirmButton = document.createElement('button');
          confirmButton.innerHTML = translateThis('Confirm');
          confirmButton.id = 'confirmButton';
          buttonContainer.appendChild(confirmButton);
          const cancelButton = document.createElement('button');
          cancelButton.innerHTML = translateThis('Cancel');
          cancelButton.id = 'cancelButton';
          buttonContainer.appendChild(cancelButton);
      }
      if(mode == 4) {
          if(listing.expired == 1 || listing.expired == 2) {
              const clearButton = document.createElement('button');
              clearButton.innerHTML = translateThis('Clear Contract');
              clearButton.id = 'clearButton';
              buttonContainer.appendChild(clearButton);
              clearButton.onclick = async function() {
                var returnThis = 0;
                if(listing.expired == 2 && listing.status[0] < 5) {
                    Swal.fire({
                      title: translateThis('Contract destroyed'),
                      text: translateThis('It seems like this deal timed out. If this was due to any disagreement then before you clear the order would you like to report the result to the blockchain for reputation tracking?'),
                      showCancelButton: true,
                      confirmButtonText: translateThis('Yes'),
                      cancelButtonText: translateThis('No'),
                      icon: 'question',
                    }).then(async (result) => {
                      if (result.isConfirmed) {
                        try {
                          await DDEcontract.methods.expireEscrow(listing.hash, myaccounts).send({"from":myaccounts,...gasOptions[gasSetting]});
                          await Swal.fire(translateThis("Transaction result registered!"));
                          popupContainer.remove();
                          returnThis=1;
                        } catch (error) {
                          console.error(error);
                          await showError(error);
                        }
                      }
                    });
                }
                if(returnThis==1) {
                  return;
                }
                const readMessages = JSON.parse(localStorage.getItem(myaccounts+":readmessages3")) || {};
                readMessages[listing.index] = true;
                localStorage.setItem(myaccounts+":readmessages3", JSON.stringify(readMessages));
                await loadUser();
                popupContainer.remove();
              };
          } else {
              var skipthis = 0;
              if(listing.timelimit[0] == listing.timelimit[1] && listing.timelimit[1] == listing.timelimit[2]) {
                skipthis = 1
              }
              if(listing.timelimit[1] != 0 && skipthis != 1) {
                if(myaccounts != listing.sender) {
                  const acceptTime = document.createElement('button');
                  acceptTime.innerHTML = translateThis('Accept Time Extension Request');
                  acceptTime.id = 'acceptTime';
                  acceptTime.onclick = async function() {
                    try {
                      await DDEcontract.methods.requestExtension(listing.hash, myaccounts, listing.timelimit[1]).send({"from":myaccounts,...gasOptions[gasSetting]});
                      await Swal.fire(translateThis("Time extended!"));
                      await loadUser();
                      popupContainer.remove();
                    } catch (error) {
                      console.error(error);
                      await showError(error);
                    }
                  }
                  buttonContainer.appendChild(acceptTime);
                }
              }
              if(listing.timelimit[2] != 0 && skipthis != 1) {
                if(myaccounts == listing.sender) {
                  const acceptTime = document.createElement('button');
                  acceptTime.innerHTML = translateThis('Accept Time Extension Request');
                  acceptTime.id = 'acceptTime';
                  acceptTime.onclick = async function() {
                    try {
                      await DDEcontract.methods.requestExtension(listing.hash, myaccounts, listing.timelimit[2]).send({"from":myaccounts,...gasOptions[gasSetting]});
                      await Swal.fire(translateThis("Time extended!"));
                      await loadUser();
                      popupContainer.remove();
                    } catch (error) {
                      console.error(error);
                      await showError(error);
                    }
                  }
                  buttonContainer.appendChild(acceptTime);
                }
              }
              const extendTime = document.createElement('button');
              extendTime.innerHTML = translateThis('Request Time Extension');
              extendTime.id = 'extendTime';
              extendTime.onclick = async function() {
                  try {
                      const dialog = document.createElement("div");
                      dialog.innerHTML = `
                        <div>` + translateThis('Please enter the number of days you wish to extend:') + `<br></div>
                          <input id="new-time" type="number" min="1"></input><br><br>
                        <div>
                          <button id="confirm-btn">` + translateThis('Confirm') + `</button>&nbsp;&nbsp;
                          <button id="cancel-btn">` + translateThis('Cancel') + `</button>
                        </div>
                      `;
                      dialog.style.display = "block";
                      dialog.style.position = "fixed";
                      dialog.style.zIndex = 999;
                      dialog.style.backgroundColor = "white";
                      dialog.style.padding = "20px";
                      dialog.style.borderRadius = "10px";
                      dialog.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.3)";
                      dialog.style.top = "50%";
                      dialog.style.left = "50%";
                      dialog.style.transform = "translate(-50%, -50%)";

                      document.body.appendChild(dialog);

                      const confirmBtn = dialog.querySelector("#confirm-btn");
                      const cancelBtn = dialog.querySelector("#cancel-btn");
                      cancelBtn.addEventListener("click", async () => {
                        dialog.remove();
                      });

                      confirmBtn.addEventListener("click", async () => {                        
                        const newtime = parseInt(listing.timelimit[0]) + parseInt(parseInt(dialog.querySelector("#new-time").value) * 24 * 60 * 60);
                        dialog.remove();
                        await DDEcontract.methods.requestExtension(listing.hash, myaccounts, newtime).send({"from":myaccounts,...gasOptions[gasSetting]});
                        await Swal.fire(translateThis("Time extension requested!"));
                        await loadUser();
                        popupContainer.remove();
                      });
                  } catch (error) {
                    console.error(error);
                    await showError(error);
                  }
              }
              buttonContainer.appendChild(extendTime);
              const cancelButton = document.createElement('button');
              cancelButton.innerHTML = translateThis('Cancel Contract');
              cancelButton.id = 'cancelButton';
              cancelButton.onclick = async function() {
                try {
                  if(myaccounts == listing.sender) {
                    if(listing.status[1] == 2) {
                      await Swal.fire(translateThis("Contract cancellation request was already sent!"));
                      return;
                    }
                  } else {
                    if(listing.status[1] == 3) {
                      await Swal.fire(translateThis("Contract cancellation request was already sent!"));
                      return;
                    }
                  }
                  await DDEcontract.methods.cancelEscrow(listing.hash, myaccounts).send({"from":myaccounts,...gasOptions[gasSetting]});
                  if(listing.status[1] == 1) {
                    await Swal.fire(translateThis("Contract cancellation request sent!"));
                  } else {
                    await Swal.fire(translateThis("Contract cancelled!"));
                  }
                  await loadUser();
                  popupContainer.remove();
                } catch (error) {
                  console.error(error);
                  await showError(error);
                }
              }
              buttonContainer.appendChild(cancelButton);
              const confirmButton = document.createElement('button');
              confirmButton.innerHTML = translateThis('Complete Contract');
              confirmButton.id = 'confirmButton';
              confirmButton.onclick = async function() {
                try {
                  if(myaccounts == listing.sender) {
                    if(listing.status[0] == 2) {
                      await Swal.fire(translateThis("Contract completion request was already sent!"));
                      return;
                    }
                  } else {
                    if(listing.status[0] == 3) {
                      await Swal.fire(translateThis("Contract completion request was already sent!"));
                      return;
                    }
                  }
                  await DDEcontract.methods.completeEscrow(listing.hash, myaccounts).send({"from":myaccounts,...gasOptions[gasSetting]});
                  if(listing.status[1] == 1) {
                    await Swal.fire(translateThis("Contract completion request sent!"));
                  } else {
                    await Swal.fire(translateThis("Contract completed!"));
                  }
                  await loadUser();
                  popupContainer.remove();
                } catch (error) {
                  console.error(error);
                  await showError(error);
                }
              }
              buttonContainer.appendChild(confirmButton);
          }
      }

      details.appendChild(sender);
      details.appendChild(recipient);
      details.appendChild(token);
      details.appendChild(amount);
      details.appendChild(depositSender);
      details.appendChild(depositRecipient);
      details.appendChild(quantity);
      details.appendChild(timelimit);
      if(listing.rfee != 0) {
        details.appendChild(theFee);
      }
      if(listing.referred != "0x0000000000000000000000000000000000000000") {
        details.appendChild(theReferred);
      }
      if(listing.tags && listing.tags.length != 0) {
        details.appendChild(theTags);
      }

      if(mode == 4) {
        timelimit.innerHTML = "<bdo>" + translateThis('Time Until Funds Expire:') + '</bdo> ' + listing.timeRemaining + ' <bdo>' + translateThis('days') + "</bdo>";
        const extra = document.createElement('p');
        extra.innerHTML = '<br><bdo>' + translateThis('Notifications:') + '</bdo><br>' + listing.escrowInfo;
        details.appendChild(extra)
      }
      message.style.whiteSpace = 'normal';
      details.appendChild(message);

      const topBar = document.createElement('div');
      if(mode == 0 && (listing.sender=="0x0000000000000000000000000000000000000000" || listing.recipient=="0x0000000000000000000000000000000000000000" )) {
        const starButton = document.createElement('span');
        starButton.style.fontSize = "20px";
        starButton.innerHTML = '&star;';
        starButton.classList.add('favorites-button2');
        starButton.style.left = 10;
        starButton.style.color = "#000000";
        if(myFavorites.includes(listing.hash)) {
          starButton.style.color = "#ed5f00";
          starButton.innerHTML = '&bigstar;';
        }
        starButton.onclick = function() {
          if(myFavorites.includes(listing.hash)) {
            myFavorites.splice(myFavorites.indexOf(listing.hash),1);
            starButton.innerHTML = '&star;';
            starButton.style.color = "#000000";
          } else {
            myFavorites.push(listing.hash);
            starButton.innerHTML = '&bigstar;';
            starButton.style.color = "#ed5f00";
          }
          checkFavorites();
          localStorage.setItem(myaccounts + ':myFavorites', JSON.stringify(myFavorites));
        };
        starButton.addEventListener('mouseover', function() {
          this.style.cursor = 'pointer';
        });
        starButton.addEventListener('mouseout', function() {
          this.style.cursor = 'auto';
        });
        topBar.appendChild(starButton);

        const linkButton = document.createElement('span');
        linkButton.style.fontSize = "20px";
        linkButton.innerHTML = '&nbsp&nbsp&#128279;';
        linkButton.classList.add('favorites-button3');
        linkButton.style.left = 50;
        linkButton.style.color = "#000000";
        linkButton.addEventListener('mouseover', function() {
          this.style.cursor = 'pointer';
        });
        linkButton.addEventListener('mouseout', function() {
          this.style.cursor = 'auto';
        });
        linkButton.onclick = function() {
          var currentURL = new URL(window.location.href);
          var newUrl = window.location.href;
          // Check if the current URL already has queries
          if (newUrl.indexOf('?') !== -1) {
            if (currentURL.searchParams.has('o')) {
              currentURL.searchParams.set('o', encodeURIComponent(listing.hash));
              newUrl = currentURL.href;
            } else {
              newUrl += '&o=' + encodeURIComponent(listing.hash);
            }
          } else {
            // If there are no queries, add the first query
            newUrl = newUrl.endsWith('/') ? newUrl : newUrl + '/';            
            newUrl += '?o=' + encodeURIComponent(listing.hash);
          }
          // Create a text area for manual copying
          const textArea = document.createElement('textarea');
          textArea.value = newUrl;
          textArea.style.position = 'fixed'; // Make it invisible and fixed to avoid interference
          document.body.appendChild(textArea);
          textArea.select();
          try {
            // Attempt to execute the copy command
            document.execCommand('copy');

            // Show a success message
            Swal.fire({
              icon: 'success',
              title: translateThis('URL Copied'),
              text: translateThis('The modified URL has been copied to the clipboard.'),
            });
          } catch (err) {
            console.error('Copy command failed:', err);
            Swal.fire({
              icon: 'info',
              title: translateThis('Copy Manually'),
              text: translateThis('The modified URL is:') + '\n\n' + newUrl + '\n\n' + translateThis('Please copy it manually.'),
            });
          } finally {
            // Clean up: remove the temporary text area
            document.body.removeChild(textArea);
          }
        };
        topBar.appendChild(linkButton);
      }
      topBar.appendChild(closeButton);
      popup.appendChild(topBar);
      popup.appendChild(imageContainer);
      details.style.whiteSpace = 'nowrap';
      details.style.marginRight = '10px'; 
      details.style.marginLeft = '10px'; 
      popup.appendChild(details);
      popup.appendChild(buttonContainer);
      popupContainer.appendChild(popup);

      document.body.appendChild(popupContainer);

      // Add CSS rules
      const style = document.createElement('style');
      style.type = 'text/css';
      style.innerHTML = `
        .popup-container {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.4);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 999;
        }

        .popup {
          position: relative;
          background-color: white;
          padding: 20px;
          max-width: 600px;
          max-height: 90%;
          overflow-y: auto;
        }

        .popup-image {
          display: block;
          margin: 0 auto;
          max-width: 200px;
          max-height: 200px;
          object-fit: contain;
          margin-bottom: 10px;
        }

        .popup-details p {
          margin: 5px 0;
        }

        .button-container {
          display: flex;
          justify-content: center;
          margin-top: 20px;
        }

        .button-container button {
          margin: 0 10px;
          padding: 10px;
          border-radius: 5px;
          border: none;
          cursor: pointer;
        }

        .button-container button:hover {
          background-color: #F5F5F5;
        }

        .close-button {
          position: absolute;
          top: 10px;
          right: 10px;
          font-size: 28px;
          font-weight: bold;
          cursor: pointer;
        }
      `;
      document.head.appendChild(style);
      //SimpleScrollbar.initEl(popup);

      if(myimgs.length !== 0) {
        showSlides(1);
      }
      if(mode == 3) {
        return new Promise(resolve => {
          const confirmButton = buttonContainer.querySelector("#confirmButton");
          const cancelButton = buttonContainer.querySelector("#cancelButton");          

          confirmButton.addEventListener("click", () => {
            popupContainer.remove();
            resolve(true);
          });

          cancelButton.addEventListener("click", () => {
            popupContainer.remove();
            resolve(false);
          });
        });
      }
    }

    async function deposit() {
      // Create the popup container
      const popupContainer = document.createElement('div');
      popupContainer.classList.add('popup-container');
      //popupContainer.onclick = function() { popupContainer.remove(); };

      const popup = document.createElement('div');
      popup.classList.add('popup');

      const closeButton = document.createElement('span');
      closeButton.innerHTML = '&times;';
      closeButton.classList.add('close-button');
      closeButton.onclick = function() { popupContainer.remove(); };

      // Create the form element
      var form = document.createElement('form');
      form.classList.add('popup-form');
      form.innerHTML = `
        <h2>` + translateThis('Deposit tokens to your balance') + `</h2>
        <div class="form-group">
          <label for="token-select">` + translateThis('Select token:') + `</label>
          <select id="token-select" name="token-select"></select>
        </div>
        <div class="form-group">
          <label for="amount-input">` + translateThis('Amount:') + `</label>
          <input type="number" step="0.00000001" min="0.00000001" id="amount-input" name="amount-input" required>
        </div>
        <div class="form-group">
          <button type="submit" class="btn">` + translateThis('Deposit') + `</button>
        </div>
      `;

      // Populate the token select dropdown
      var tokenSelect = form.querySelector('#token-select');
      for (var i = 0; i < tokens.length; i++) {
        var option = document.createElement('option');
        option.value = i;
        option.text = tokens[i].token;
        tokenSelect.appendChild(option);
      }

      // Add the form submit event listener
      form.addEventListener('submit', async function(event) {
        event.preventDefault();

        var selectedIndex = parseInt(tokenSelect.value);
        var token = tokens[selectedIndex].token;
        var tokenAddress = tokens[selectedIndex].address;
        var decimals = parseInt(tokens[selectedIndex].decimals);
        var amount = parseFloat(document.getElementById('amount-input').value);

        if (token === "ETH") {
          // If the selected token is ETH, deposit WETH instead
          try {
            var value = web3.utils.toWei(amount.toString(), 'ether');
            await DDEcontract.methods.depositWETH().send({"from":myaccounts,"value":value,...gasOptions[gasSetting]});
            await Swal.fire(translateThis("Deposit success!"));
            await loadUser();
            popupContainer.remove();
          } catch (error) {
            console.error(error);
            await showError(error);
          }
        } else {
          // If the selected token is not ETH, deposit the selected token
          try {
            var tokenContract = new web3.eth.Contract(ERC20abi, tokenAddress);
            var allowance = DOMPurify.sanitize(await tokenContract.methods.allowance(myaccounts, DDEaddy).call());
            var value = (new BigNumber(amount.toString()).times(new BigNumber(10).pow(decimals))).toString()

            if (web3.utils.toBN(allowance).lt(web3.utils.toBN(value))) {
              await Swal.fire(translateThis("Waiting for approval..."));
              await tokenContract.methods.approve(DDEaddy, web3.utils.toHex(web3.utils.toBN(2).pow(web3.utils.toBN(256)).sub(web3.utils.toBN(1)))).send({"from":myaccounts,...gasOptions[gasSetting]});
            }

            await DDEcontract.methods.deposit(tokenAddress, value).send({"from":myaccounts,...gasOptions[gasSetting]});
            await Swal.fire(translateThis("Deposit success!"));
            await loadUser();
            popupContainer.remove();
          } catch (error) {
            console.error(error);
            await showError(error);
          }
        }
      });

      // Append the form to the popup container
      popupContainer.appendChild(popup);
      popup.appendChild(form);
      popup.appendChild(closeButton);

      // Append the popup container to the page body
      document.body.appendChild(popupContainer);

      // Add CSS rules
      const style = document.createElement('style');
      style.type = 'text/css';
      style.innerHTML = `
        .popup-container {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.4);
          display: flex;
          justify-content: center;
          align-items: center;
        }

        .popup {
          position: relative;
          background-color: white;
          padding: 20px;
          max-width: 600px;
          max-height: 80%;
          overflow-y: auto;
        }

        .close-button {
          position: absolute;
          top: 10px;
          right: 10px;
          font-size: 28px;
          font-weight: bold;
          cursor: pointer;
        }
      `;
      document.head.appendChild(style);
    }

    async function withdraw() {
      // Create the popup container
      const popupContainer = document.createElement('div');
      popupContainer.classList.add('popup-container');
      //popupContainer.onclick = function() { popupContainer.remove(); };

      const popup = document.createElement('div');
      popup.classList.add('popup');

      const closeButton = document.createElement('span');
      closeButton.innerHTML = '&times;';
      closeButton.classList.add('close-button');
      closeButton.onclick = function() { popupContainer.remove(); };

      // Create the form element
      var form = document.createElement('form');
      form.classList.add('popup-form');
      form.innerHTML = `
        <h2>` + translateThis('Withdraw tokens from your balance') + `</h2>
        <div class="form-group">
          <label for="token-select">` + translateThis('Select token:') + `</label>
          <select id="token-select" name="token-select"></select>
        </div>
        <div class="form-group">
          <label for="amount-input">` + translateThis('Amount:') + `</label>
          <input type="number" step="0.00000001" min="0.00000001" id="amount-input" name="amount-input" required>
        </div>
        <div class="form-group">
          <button type="submit" class="btn">` + translateThis('Withdraw') + `</button>
        </div>
      `;

      // Populate the token select dropdown
      var tokenSelect = form.querySelector('#token-select');
      for (var i = 0; i < tokens.length; i++) {
        var option = document.createElement('option');
        option.value = i;
        option.text = tokens[i].token;
        tokenSelect.appendChild(option);
      }

      // Add the form submit event listener
      form.addEventListener('submit', async function(event) {
          event.preventDefault();
          var selectedIndex = parseInt(tokenSelect.value);
          var tokenAddress = tokens[selectedIndex].address;
          var decimals = parseInt(tokens[selectedIndex].decimals);
          var amount = parseFloat(document.getElementById('amount-input').value);          
          var value = (new BigNumber(amount.toString()).times(new BigNumber(10).pow(decimals))).toFixed(0);
          try {
            await DDEcontract.methods.withdraw(tokenAddress, value).send({"from":myaccounts,...gasOptions[gasSetting]});
            await Swal.fire(translateThis("Withdraw success!"));
            await loadUser();
            popupContainer.remove();
          } catch (error) {
            console.error(error);
            await showError(error);
          }
      });

      // Append the form to the popup container
      popupContainer.appendChild(popup);
      popup.appendChild(form);
      popup.appendChild(closeButton);

      // Append the popup container to the page body
      document.body.appendChild(popupContainer);

      // Add CSS rules
      const style = document.createElement('style');
      style.type = 'text/css';
      style.innerHTML = `
        .popup-container {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.4);
          display: flex;
          justify-content: center;
          align-items: center;
        }

        .popup {
          position: relative;
          background-color: white;
          padding: 20px;
          max-width: 600px;
          max-height: 80%;
          overflow-y: auto;
        }

        .close-button {
          position: absolute;
          top: 10px;
          right: 10px;
          font-size: 28px;
          font-weight: bold;
          cursor: pointer;
        }
      `;
      document.head.appendChild(style);
    }

    async function resizeImage(file) {
      // Check if the file is an image
      if (!file.type.startsWith('image/')) {
        return null;
      }

      // Load the image data into an image object
      const img = new Image();

      const base64 = await new Promise((resolve) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
      });

      img.src = base64;

      // Wait for the image to load
      await new Promise((resolve) => {
        img.onload = resolve;
      });

      // Check if the image is too large
      const maxSize = 100 * 1024; // 100 KB
      const size = img.width * img.height * 3; // 3 bytes per pixel
      if (size <= maxSize) {
        return img.src;
      }

      // Resize the image using the Canvas API
      const canvas = document.createElement('canvas');
      const scale = Math.sqrt(maxSize / size);
      canvas.width = img.width * scale;
      canvas.height = img.height * scale;
      canvas.getContext('2d').drawImage(img, 0, 0, canvas.width, canvas.height);
      return canvas.toDataURL(file.type, 0.8); // Reduce quality to reduce size
    }

    async function createContract(publicoffer=true, counterdata={}) {
        // Create the popup container
        const popupContainer = document.createElement('div');
        popupContainer.classList.add('popup-container');
        //popupContainer.onclick = function() { popupContainer.remove(); };

        const popup = document.createElement('div');
        popup.classList.add('popup');

        const closeButton = document.createElement('span');
        closeButton.innerHTML = '&times;';
        closeButton.classList.add('close-button');
        closeButton.onclick = function() { popupContainer.remove(); };

        var myterms = [];
        var expiration = 0;

        // Create the form element
        var form = document.createElement('form');
        form.classList.add('popup-form');
        form.innerHTML = `<div id="createContractModal" class="modal">
          <div class="modal-content">
            <h2>` + translateThis('Create Contract') + `</h2>
            <form id="createContractForm">
              <label for="contractType">` + translateThis('Contract Type') + `:</label>
              <select id="contractType">
                <option value="public">` + translateThis('Public Offer') + `</option>
                <option value="private">` + translateThis('Private Offer') + `</option>
              </select><br><span class="vertical-spacer"></span>
              <div id="counterPartyAddressField" style="display:none;">
                <label for="counterPartyAddress">` + translateThis('Counter-Party Address:') + `</label>
                <input type="text" id="counterPartyInput">
              </div><br><span class="vertical-spacer"></span>
              <label for="senderReceiver">` + translateThis('Sender or Receiver:') + `</label>
              <select id="senderReceiver">
                <option value="receiver">` + translateThis("I'm the one receiving the funds") + `</option>
                <option value="sender">` + translateThis("I'm the one sending the funds") + `</option>                
              </select><br><span class="vertical-spacer"></span>
              <label for="order-quantity">` + translateThis('Quantity:') + `</label>
              <input type="number" id="order-quantity" min="1" value="1" style="width: 75px;">
              <label for="order-maximum">` + translateThis('Maximum:') + `</label>
              <input type="number" id="order-maximum" min="1" value="1" style="width: 75px;"><br><span class="vertical-spacer"></span>
              </select><br><span class="vertical-spacer"></span>
              <label for="token">` + translateThis('Token:') + `</label>
              <select id="token-select">
                <!-- options added dynamically through javascript -->
              </select><br><span class="vertical-spacer"></span>
              <label for="amount">` + translateThis('Amount:') + `</label>
              <input type="number" id="amount-input" min="0" step="0.00000001"><br><span class="vertical-spacer"></span>
              <label for="depositSettings">` + translateThis('Deposit Settings:') + `</label>
              <select id="depositSettings">
                <option value="recommended">` + translateThis('Use recommended deposit settings') + `</option>
                <option value="custom">` + translateThis('Custom deposits') + `</option>
              </select><br><span class="vertical-spacer"></span>
              <div id="senderDepositField" style="display:none;">
                <label for="senderDeposit">` + translateThis('Sender Deposit:') + `</label>
                <input type="number" id="sender-deposit-input" min="0" step="0.00000001">
              </div><br><span class="vertical-spacer"></span>
              <div id="receiverDepositField" style="display:none;">
                <label for="receiverDeposit">` + translateThis('Receiver Deposit:') + `</label>
                <input type="number" id="recipient-deposit-input" min="0" step="0.00000001">
              </div><br><span class="vertical-spacer"></span>
              <label for="timeLimit">` + translateThis('Time Limit (in weeks):') + `</label>
              <input type="number" id="timeLimit" min="1" value="4"><br><span class="vertical-spacer"></span>
              <p id="timeLimitWarning" style="display:none;">` + translateThis('Notice: Fast expiration times can cause users to lose funds if they lose access to their computers. The default time of one month or longer is recommended for this reason.') + `</p><br><span class="vertical-spacer"></span>
              <label for="contractDetails">` + translateThis('Contract Details:') + `</label><br><span class="vertical-spacer"></span>
              <textarea id="contractDetails"></textarea><br><span class="vertical-spacer"></span>
              <label for="contractImage">` + translateThis('Contract Images:') + `</label>
              <input type="file" id="contractImage" multiple><br><br><span class="vertical-spacer"></span>
              <button type="button" id="changefile" style="display:none;">` + translateThis('Change Images') + `</button>
              <label for="contactInfo">` + translateThis('Contact Information(email/chat):') + `</label><br><span class="vertical-spacer"></span>
              <input id="contactInfo"></textarea><br><span class="vertical-spacer"></span>
              <label for="key-words" id="key-label">` + translateThis('Search key words(optional):') + `</label>
              <button type="button" id="key-words">` + translateThis('Add search terms') + `</button><br><span class="vertical-spacer"></span>
              <label for="allowcounters" id="allowcounterslabel">` + translateThis('Allow counter offers') + `  </label>
              <input type="checkbox" id="allowcounters"><br><span class="vertical-spacer"></span>
              <label for="autoaccept" id="autoacceptlabel">` + translateThis('Automatically accept matching offers') + `  </label>
              <input type="checkbox" id="autoaccept"><br><br><span class="vertical-spacer"></span>
              <button type="submit">` + translateThis('Submit') + `</button>
            </form>
          </div>
        </div>
        `;

        // Populate the token select dropdown
        var tokenSelect = form.querySelector('#token-select');
        for (var i = 0; i < tokens.length; i++) {
            var option = document.createElement('option');
            option.value = i;
            option.text = tokens[i].token;
            tokenSelect.appendChild(option);
        }

        form.querySelector("#contactInfo").value = document.getElementById("myContactInfo").value;

        // Get necessary DOM elements
        var contractType = form.querySelector('#contractType');
        var counterPartyAddressField = form.querySelector('#counterPartyAddressField');
        var depositSelect = form.querySelector('#depositSettings');
        var senderDepositInput = form.querySelector('#senderDepositField');
        var recipientDepositInput = form.querySelector('#receiverDepositField');
        var imageInput = form.querySelector('#contractImage');
        var auto = form.querySelector('#autoaccept');
        var allowcounters = form.querySelector('#allowcounters');
        var adjusttime = form.querySelector('#timeLimit');
        var addWord = form.querySelector("#key-words");
        var addWordLabel = form.querySelector("#key-label");

        // Hide counterparty input initially
        counterPartyAddressField.style.display = 'none';

        // Hide deposit inputs initially
        senderDepositInput.style.display = 'none';
        recipientDepositInput.style.display = 'none';

        auto.addEventListener('change', async() => {
          if (auto.checked) {
            await Swal.fire({
              icon: 'info',
              title: translateThis('Autoaccept'),
              text: translateThis('Please be aware when you automatically accept deals you must occassionally check the software to make sure you are aware of when deals enter escrow just in case the counter-party does not alert you. This way losses do not occur and deals will not expire.'),
            });
          }
        });

        // Event listener for type select
        contractType.addEventListener('change', () => {
          if (contractType.value === 'private') {
            counterPartyAddressField.style.display = 'block';
            auto.style.display = 'none';
            document.getElementById("autoacceptlabel").style.display = 'none';
            allowcounters.style.display = 'none';
            document.getElementById("allowcounterslabel").style.display = 'none';
            myterms = [];
            addWord.style.display = 'none';
            addWordLabel.style.display = 'none';
          } else {
            counterPartyAddressField.style.display = 'none';
            auto.style.display = 'block';
            document.getElementById("autoacceptlabel").style.display = 'block';
            allowcounters.style.display = 'block';
            document.getElementById("allowcounterslabel").style.display = 'block';
            addWord.style.display = 'block';
            addWordLabel.style.display = 'block';
          }
        });

        adjusttime.addEventListener('change', () => {
            if(adjusttime.value<4) {
                timeLimitWarning.style.display = 'block';
            } else {
                timeLimitWarning.style.display = 'none';
            }
        });

        // Event listener for deposit select
        depositSelect.addEventListener('change', () => {
          if (depositSelect.value === 'custom') {
            senderDepositInput.style.display = 'block';
            recipientDepositInput.style.display = 'block';
          } else {
            senderDepositInput.style.display = 'none';
            recipientDepositInput.style.display = 'none';
          }
        });
        var image = [];
        // Event listener for image input
        imageInput.addEventListener('change', async () => {
          if(imageInput.files.length > 10) {
            await Swal.fire(translateThis("Please add less than the maximum of 10 images"));
            return false;
          }
          for (let i = 0; i < imageInput.files.length; i++) {
            const file = imageInput.files[i];
            const myimage = await resizeImage(file);
            if (myimage) {
              image.push(myimage);
            } else {
              console.warn(`File ${file.name} is not an image`);
            }
          }
        });

        if(Object.keys(counterdata).length !== 0) {
          form.querySelector('#contractType').selectedIndex = 1;
          counterPartyAddressField.style.display = 'block';
          auto.style.display = 'none';
          allowcounters.style.display = 'none';
          if(myaccounts === counterdata.recipient) {
            form.querySelector("#senderReceiver").selectedIndex = 0;
            form.querySelector("#counterPartyInput").value = counterdata.sender;
          } else {
            form.querySelector("#senderReceiver").selectedIndex = 1;
            form.querySelector("#counterPartyInput").value = counterdata.recipient;
          }
          form.querySelector("#order-quantity").value = 1;
          form.querySelector("#amount-input").value = displayDecimals(counterdata.token, counterdata.amount);
          if(counterdata.amount == counterdata.depositSender && counterdata.amount == counterdata.depositRecipient) {
            form.querySelector("#depositSettings").selectedIndex = 0;
          } else {
            form.querySelector("#depositSettings").selectedIndex = 1;
            senderDepositInput.style.display = 'block';
            recipientDepositInput.style.display = 'block';
            form.querySelector("#sender-deposit-input").value = displayDecimals(counterdata.token, counterdata.depositSender);
            form.querySelector("#recipient-deposit-input").value = displayDecimals(counterdata.token, counterdata.depositRecipient);
          }
          form.querySelector("#timeLimit").value = parseInt(counterdata.timelimit[0]) / (60 * 60 * 24 * 7);
          form.querySelector("#contractDetails").value = counterdata.message;
          var selectedIndex = -1;

          for (var inx = 0; inx < tokens.length; inx++) {
            if (tokens[inx].address === counterdata.token) {
              selectedIndex = inx;
              break;
            }
          }

          if (selectedIndex !== -1) {
            tokenSelect.selectedIndex = selectedIndex;
          } else {
            await Swal.fire(translateThis('Token not found in default coin list!'));
            popupContainer.remove();
            return;
          }
          image = await(getFile(counterdata.image));
          form.querySelector("#contractImage").style.display = 'none';
          const changefile = form.querySelector("#changefile")
          changefile.style.display = 'block';
          changefile.onclick = () => { 
            changefile.style.display = 'none';
            form.querySelector("#contractImage").style.display = 'block';
            image = [];
          }
        }

        addWord.onclick = async function() {
            myterms = await addWords(myterms);
        }

        // Add the form submit event listener
        form.addEventListener('submit', async function(event) {
          event.preventDefault();
          // Get form values
          var counterPartyInput = document.getElementById("counterPartyInput").value;
          var sender = "0x0000000000000000000000000000000000000000";
          var recipient = "0x0000000000000000000000000000000000000000";
          const currentBlockNumber = await web3.eth.getBlockNumber();
          const currentBlock = await web3.eth.getBlock(currentBlockNumber);
          const blockTimestamp = DOMPurify.sanitize(currentBlock.timestamp);
          if (contractType.value === 'private') {
                sender = counterPartyInput;
                recipient = myaccounts;
                var offerExpirationSelect = document.getElementById("offerExpiration");
                var selectedValue = offerExpirationSelect.value;
                if (selectedValue === "never") {
                  expiration = 0; // Set the time limit to 0 seconds for "Never" option
                } else if (selectedValue === "two-weeks") {
                  expiration = parseInt(blockTimestamp + (2 * 7 * 24 * 60 * 60)); // Set the time limit to 2 weeks in seconds
                } else if (selectedValue === "one-month") {
                  expiration = parseInt(blockTimestamp + (30 * 24 * 60 * 60)); // Set the time limit to 1 month in seconds
                }
          } else {
                expiration = 0;
                recipient = myaccounts;
          }
          var senderReceiver = document.getElementById("senderReceiver").value;
          var quantity = parseInt(document.getElementById('order-quantity').value);
          var maximum = parseInt(document.getElementById('order-maximum').value);
          var amount = document.getElementById("amount-input").value;
          var depositType = form.querySelector("#depositSettings").value;
          var depositSender = document.getElementById("sender-deposit-input").value;
          var depositRecipient = document.getElementById("recipient-deposit-input").value;
          var timeLimit = document.getElementById("timeLimit").value;
          var contactinfo = document.getElementById("contactInfo").value;
          var message = JSON.stringify({message: document.getElementById("contractDetails").value, contact: contactinfo, image: image});
          if (contactinfo != '') {
            document.getElementById("myContactInfo").value = contactinfo;
            await saveContactInfo(contactinfo);
          }          
          if(message == "error") {
            await Swal.fire(translateThis("Error posting IPFS data, please try again later"));
            return false;
          }
          if (amount === "") {
            await Swal.fire(translateThis("Please enter the amount"));
            return false;
          }
          if (depositType === "custom") {
            if (depositSender === "" || depositRecipient === "") {
              await Swal.fire(translateThis("Please enter the custom deposits"));
              return false;
            }
          }
          if (timeLimit === "") {
            await Swal.fire(translateThis("Please enter the time limit"));
            return false;
          }
          timeLimit = parseInt(timeLimit);
          if (timeLimit === 0) {
            await Swal.fire(translateThis("Time limit must be greater than zero"));
          }
          if (document.getElementById("contractDetails").value === "") {
            await Swal.fire(translateThis("Please enter the description"));
            return false;
          }
          var sender2 = (senderReceiver === "receiver" ? sender : recipient);
          var recipient2 = (senderReceiver === "receiver" ? recipient : sender);
          var selectedIndex = parseInt(tokenSelect.value);
          var tokenAddress = tokens[selectedIndex].address;
          var decimals = parseInt(tokens[selectedIndex].decimals);

          amount = (new BigNumber(amount.toString()).times(new BigNumber(10).pow(decimals))).toFixed(0);
          depositSender = (depositType === "recommended" ? amount : (new BigNumber(depositSender.toString()).times(new BigNumber(10).pow(decimals))).toFixed(0));
          depositRecipient = (depositType === "recommended" ? amount : (new BigNumber(depositRecipient.toString()).times(new BigNumber(10).pow(decimals))).toFixed(0));
          var style = 0;
          if(publicoffer) {
            if(document.getElementById("autoaccept").checked == false) {
              style = 1;
            } else {
              style = 0;
            }
            if(document.getElementById("allowcounters").checked == false) {
              style += 2;
            }
          }
          var multiplier = 1;
          if(style == 0 || style == 2) {
            multiplier = maximum;
            if(maximum > quantity) {
              multiplier = quantity;
            }
          }
          if(myaccounts == sender2) {
            if (web3.utils.toBN(balances[tokenAddress].amount).lt(web3.utils.toBN(amount).add(web3.utils.toBN(depositSender)).mul(web3.utils.toBN(multiplier)))) {
                await Swal.fire(translateThis("You don't have enough funds if someone were to accept this offer. Please deposit funds first before proceeding."));
                return false;
            }
          }
          if(myaccounts == recipient2) {
            if (web3.utils.toBN(balances[tokenAddress].amount).lt(web3.utils.toBN(depositRecipient).mul(web3.utils.toBN(multiplier)))) {
                await Swal.fire(translateThis("You don't have enough funds if someone were to accept this offer. Please deposit funds first before proceeding."));
                return false;
            }
          }
          var datalen = 0;
          var contact2 = '';
          var otherparty = '';
          try {
              if(myaccounts == sender2) {
                otherparty = recipient2;
              } else {
                otherparty = sender2;
              }
              var returnThis = 0;
              if(otherparty != "0x0000000000000000000000000000000000000000") {
                datalen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(otherparty, 3).call());
                if(datalen > 0) {
                  contact2 = JSON.parse(DOMPurify.sanitize(await DDEcontract.methods.userdata(otherparty, datalen-1).call()));
                  if('publickey' in contact2 && userprivkey != '') {
                    var paddedMessage = message + "#*#*#" + (new Date().getTime()) + Crypto.SHA256(new Date().getTime());
                    if(myaccounts == sender2) {
                      message = JSON.stringify({'recipient':cryptico.encrypt(paddedMessage, contact2['publickey'], userprivkey),'sender':cryptico.encrypt(paddedMessage, userpubkey, userprivkey)});
                    }
                    if(myaccounts == recipient2) {
                      message = JSON.stringify({'sender':cryptico.encrypt(paddedMessage, contact2['publickey'], userprivkey),'recipient':cryptico.encrypt(paddedMessage, userpubkey, userprivkey)});
                    }
                    console.log(message)
                  } else if ('publickey' in contact2 && userprivkey == '') {
                    await Swal.fire({
                      title: translateThis('Encrypt offer'),
                      text: translateThis('Your counterparty has listed a key for encryption. If you would like your order be encrypted you should set a password for your account. Would you like to do that before proceeding?'),
                      icon: 'question',
                      showCancelButton: true,
                      confirmButtonText: translateThis('Yes'),
                      cancelButtonText: translateThis('No'),
                    }).then((result) => {
                      if (result.isConfirmed) {
                        popupContainer.remove();
                        returnThis = 1;
                        return;
                      }
                    });
                  }
                }
              }
              if(returnThis == 1) {
                return false;
              }
          } catch(e) {
              console.log(e);
          }
          const byteLength = new TextEncoder().encode(message).length;
          if (byteLength > parseInt(maxFileSize * .97)) {
            await Swal.fire(translateThis("Message exceeds maximum byte size:") + " " + maxFileSize);
            return false;
          }
          var result = await postOfferData(message);
          if(result == "error") {
            await Swal.fire(translateThis("Error posting message data to IPFS."));
            return false;
          }
          if(result.length > 100) {
            await Swal.fire(translateThis("Error message length was unusually long. Please check IPFS hash result."));
            return false;
          }
          message = result;
          // Construct data object
          const data = {
            sender: sender2,
            recipient: recipient2,
            token: tokenAddress,
            amount: amount,
            depositSender: depositSender,
            depositRecipient: depositRecipient,
            quantity: [quantity.toString(), maximum.toString()],
            timelimit: parseInt(timeLimit * 7 * 24 * 60 * 60),
            message: message
          };
          data2 = JSON.parse(JSON.stringify(data));
          data2.image = [];
          data2.message = "IPFS link: " + data2.message;
          data2.timelimit = [data2.timelimit];
          data2.rfee = baseFee;
          data2.referred = referral;
          if(Object.keys(counterdata).length !== 0) {
            data2.referred = counterdata.referred;
            if(myaccounts == sender2) {
              data2.referred = referral;
              const rfee2 = parseInt(DOMPurify.sanitize(await DDEcontract.methods.customFee(otherparty).call()));
              if(rfee2 > baseFee) {
                data2.rfee = rfee2;
              }
              style = 4;
            }
          }
          //if(Object.keys(counterdata).length !== 0) {
          //  data2.amount *= quantity;
          //  data2.depositSender *= quantity;
          //  data2.depositRecipient *= quantity;
          //}          
          console.log(data2);
          //May eventually want to check for duplicate contract hash submission
          var result = await showListing(data2, 3)
          if(result == false) {
            popupContainer.remove();
            return;
          }
          try {
              var returnThis2 = false;
              if(publicoffer) {
                if(myterms.length == 0) {
                  await Swal.fire({
                    title: translateThis('Hashtags'),
                    text: translateThis('You did not include any keywords. Without these it could make your offer hard to find. It is recommended to add some keywords related to your open offer. Would you like to submit your offer without keywords?'),
                    icon: 'question',
                    showCancelButton: true,
                    confirmButtonText: translateThis('Yes'),
                    cancelButtonText: translateThis('No'),
                  }).then((result) => {
                    if(!result.isConfirmed) {
                      popupContainer.remove();
                      returnThis2 = true;
                      return;
                    }
                  });
                }
              }
              if(returnThis2) {
                return;
              }
              var cHash = web3.utils.keccak256(web3.utils.encodePacked({value: data.sender, type: 'address'},{value: data.recipient, type: 'address'},{value: data.token, type: 'address'},{value: data.amount, type: 'uint256'},{value: data.depositSender, type: 'uint256'},{value: data.depositRecipient, type: 'uint256'},{value: data.timelimit.toString(), type: 'uint256'},{value: expiration.toString(), type: 'uint256'},{value: data.message, type: 'string'},{value: blockTimestamp, type: 'uint256'}));
              console.log(cHash);
              if(DOMPurify.sanitize(await DDEcontract.methods.initialized(cHash).call()) == "true") {
                await Swal.fire(translateThis("Duplicate contract detected! This contract has already been created in the past. Please modify the description slightly so it may be submitted again."));
                popupContainer.remove();
                return;
              }
              // Call solidity function to create contract
              await DDEcontract.methods.createContract(
                data.sender,
                [data.recipient, data2.referred],
                data.token,
                data.amount,
                data.depositSender,
                data.depositRecipient,
                data.quantity,
                [data.timelimit.toString(), expiration.toString()],
                style,
                data.message,
                myterms
              ).send({"from":myaccounts,...gasOptions[gasSetting]});
                await Swal.fire(translateThis("Contract creation success!"));
                await loadUser();
                if(emailClient.checked && sender2 != "0x0000000000000000000000000000000000000000" && recipient2 != "0x0000000000000000000000000000000000000000" && contact2 != '' && typeof contact2 === 'object' && 'mycontact' in contact2 && contact2['mycontact'].includes("@")) {
                  Swal.fire({
                    title: translateThis('Notify Counterparty'),
                    text: translateThis('Would you like to email the counterparty to notify them of your offer?'),
                    icon: 'question',
                    showCancelButton: true,
                    confirmButtonText: translateThis('Yes'),
                    cancelButtonText: translateThis('No'),
                  }).then((result) => {
                    if (result.isConfirmed) {
                      var emailSubject = encodeURIComponent('You have received an offer on the BitBay marketplace');
                      var emailBody = encodeURIComponent(translateThis('Hello, this email was automatically composed to let you know that I have sent you an offer on the BitBay marketplace. For safety reasons, do not click any links from this email however you may log in to the official website on your own. Also for your safety, please only contact users at the email officially registered to their contracts. If you have any questions about my offer please let me know. Thank you and have a nice day.'));
                      const mailtoLink = `mailto:${contact2['mycontact']}?subject=${emailSubject}&body=${emailBody}`;
                      window.location.href = mailtoLink;
                    }
                  });
                }
                popupContainer.remove();
              } catch (error) {
                console.error(error);
                await showError(error);
          }
        });

        // Append the form to the popup container
        popupContainer.appendChild(popup);
        popup.appendChild(form);
        popup.appendChild(closeButton);

        // Append the popup container to the page body
        document.body.appendChild(popupContainer);

        // Add CSS rules
        const style = document.createElement('style');
        style.type = 'text/css';
        style.innerHTML = `
        .popup-container {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.4);
          display: flex;
          justify-content: center;
          align-items: center;
        }

        .popup {
          position: relative;
          background-color: white;
          padding: 20px;
          max-width: 600px;
          max-height: 80%;
          overflow-y: auto;
        }

        .close-button {
          position: absolute;
          top: 10px;
          right: 10px;
          font-size: 28px;
          font-weight: bold;
          cursor: pointer;
        }

        .vertical-spacer {
          display: inline-block;
          height: 2px;
        }
        `;
        document.head.appendChild(style);
    }

    async function addWords(theterms = "") {
      return new Promise((resolve) => {
        const dialog = document.createElement("div");
        var addedTerms = [];

        // Predefined list of popular key words
        const popularKeywords = ["goods", "services", "barter", "crypto", "real-estate", "electronics", "metals"];

        dialog.innerHTML = `
          <div>` + translateThis('Please enter some key words so users can find your order easier:') + `<br></div>
            <input id="hashtag" type="text"></input><button id="add-btn">` + translateThis('Add') + `</button><br><br>
          <div id="term-list"></div>
          <br>
          <div>          
            <div>` + translateThis('Popular key words:') + `</div>            
            <div id="popular-keywords"></div>
            <br>
            <button id="confirm-btn">` + translateThis('Confirm') + `</button>&nbsp;&nbsp;
            <button id="cancel-btn">` + translateThis('Cancel') + `</button>
          </div>
        `;
        dialog.style.display = "block";
        dialog.style.position = "fixed";
        dialog.style.zIndex = 999;
        dialog.style.backgroundColor = "white";
        dialog.style.padding = "20px";
        dialog.style.borderRadius = "10px";
        dialog.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.3)";
        dialog.style.top = "50%";
        dialog.style.left = "50%";        
        dialog.style.transform = "translate(-50%, -50%)";

        document.body.appendChild(dialog);

        const termList = dialog.querySelector("#term-list");
        const confirmBtn = dialog.querySelector("#confirm-btn");
        const cancelBtn = dialog.querySelector("#cancel-btn");
        const addBtn = dialog.querySelector("#add-btn");
        const popularKeywordsContainer = dialog.querySelector("#popular-keywords");

        // Display the added terms list
        function displayAddedTerms() {
          termList.innerHTML = "";
          addedTerms.forEach(term => {
            const termElement = document.createElement("div");
            termElement.textContent = term;
            termList.appendChild(termElement);
          });
        }

        if(theterms != "") {
          addedTerms = theterms;
          displayAddedTerms();
        }

        termList.addEventListener('click', function (event) {
            if (event.target.tagName === 'DIV') {
                const termToRemove = event.target.textContent.trim();
                const termIndex = addedTerms.indexOf(termToRemove);
                if (termIndex !== -1) {
                    addedTerms.splice(termIndex, 1);
                    displayAddedTerms();
                }
            }
        });

        // Add a term to the list when Add button is clicked
        addBtn.addEventListener("click", async () => {
          const hashtagInput = dialog.querySelector("#hashtag");
          const term = hashtagInput.value.toLowerCase().trim();
          if (term.includes(" ") || term.includes(",")) {
            await Swal.fire(translateThis("Key words should not contain spaces or commas"));
            return;
          }
          const encoder = new TextEncoder();
          const utf8Bytes = encoder.encode(term);
          const byteLength = utf8Bytes.length;
          if (byteLength > 32) {
            await Swal.fire(translateThis("String exceeds limit of 32 bytes"));
            return;
          }
          if (term !== "") {
            if (!addedTerms.includes(term)) {
                addedTerms.push(term);
                displayAddedTerms();
            }
            hashtagInput.value = "";
          }
        });

        // Add a popular keyword to the list when a bubble button is clicked
        popularKeywords.forEach(keyword => {
          const keywordButton = document.createElement("button");
          keywordButton.textContent = keyword;
          keywordButton.addEventListener("click", async () => {
            if (addedTerms.length < 11) {
              if (!addedTerms.includes(keyword.toLowerCase())) {
                addedTerms.push(keyword.toLowerCase());
                displayAddedTerms();
              }
            } else {
              await Swal.fire(translateThis('The maximum number of keywords is 10'));
            }
          });
          popularKeywordsContainer.appendChild(keywordButton);
        });

        // Remove the dialog when Cancel button is clicked
        cancelBtn.addEventListener("click", async () => {
          dialog.remove();
        });

        // Resolve the promise with the added terms when Confirm button is clicked
        confirmBtn.addEventListener("click", async () => {
          dialog.remove();
          resolve(addedTerms);
        });
      });
    }
    async function readFileAsDataURL(file) {
      return new Promise((resolve, reject) => {
        let reader = new FileReader();
        reader.onload = () => {
          resolve(reader.result.split(',')[1]);
        };
        reader.readAsDataURL(file);
      });
    }

    async function acceptOffer(listing) {
        try {
              mylisting = JSON.parse(JSON.stringify(listing));
              var quantity = 1;
              var accepttimelimit = 0;
              var offerExpirationSelect = document.getElementById("offerExpiration");
              var selectedValue = offerExpirationSelect.value;
              const currentBlockNumber = await web3.eth.getBlockNumber();
              const currentBlock = await web3.eth.getBlock(currentBlockNumber);
              const blockTimestamp = DOMPurify.sanitize(currentBlock.timestamp);
              if (selectedValue === "never") {
                accepttimelimit = 0; // Set the time limit to 0 seconds for "Never" option
              } else if (selectedValue === "two-weeks") {
                accepttimelimit = parseInt(blockTimestamp + (2 * 7 * 24 * 60 * 60)); // Set the time limit to 2 weeks in seconds
              } else if (selectedValue === "one-month") {
                accepttimelimit = parseInt(blockTimestamp + (30 * 24 * 60 * 60)); // Set the time limit to 1 month in seconds
              }
              if(mylisting.sender == "0x0000000000000000000000000000000000000000" || mylisting.recipient == "0x0000000000000000000000000000000000000000" ) {
                const offerID = DOMPurify.sanitize(await DDEcontract.methods.userMarketID(mylisting.hash).call());
                if(offerID == 0) {
                  await Swal.fire(translateThis("Offer no longer available!"));
                  return;
                }
                if(listing.status[0]==0 || listing.status[1]==0) {
                  const dialog = document.createElement("div");
                  dialog.innerHTML = `
                    <div>` + translateThis('Please enter the quantity you wish to purchase:') + `<br></div>
                      <input id="new-quantity" type="number" min="1"></input><br><br>
                    <div>
                      <button id="confirm-btn">` + translateThis('Confirm') + `</button>&nbsp;&nbsp;
                      <button id="cancel-btn">` + translateThis('Cancel') + `</button>
                    </div>
                  `;
                  dialog.style.display = "block";
                  dialog.style.position = "fixed";
                  dialog.style.zIndex = 999;
                  dialog.style.backgroundColor = "white";
                  dialog.style.padding = "20px";
                  dialog.style.borderRadius = "10px";
                  dialog.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.3)";
                  dialog.style.top = "50%";
                  dialog.style.left = "50%";
                  dialog.style.transform = "translate(-50%, -50%)";

                  document.body.appendChild(dialog);

                  const confirmBtn = dialog.querySelector("#confirm-btn");
                  const cancelBtn = dialog.querySelector("#cancel-btn");
                  cancelBtn.addEventListener("click", async () => {
                    dialog.remove();
                  });

                  confirmBtn.addEventListener("click", async () => {
                    quantity = parseInt(document.getElementById('new-quantity').value);
                    if(quantity > parseInt(mylisting.quantity[0]) || quantity > parseInt(mylisting.quantity[1])) {
                      await Swal.fire(translateThis("Quantity exceeds what is available!"));
                      return;
                    }
                    dialog.remove();
                    mylisting.quantity[0] = quantity.toString();
                    var counterparty = mylisting.sender;
                    if(mylisting.sender == "0x0000000000000000000000000000000000000000") {
                        counterparty = mylisting.recipient;
                    }
                    var counterbalance = "";
                    await DDEcontract.methods.userBalance(counterparty,mylisting.token).call().then(function (bal) {            
                            counterbalance = DOMPurify.sanitize(bal);
                    });
                    if(mylisting.sender == "0x0000000000000000000000000000000000000000") {
                      if (web3.utils.toBN(balances[mylisting.token].amount).lt(web3.utils.toBN(mylisting.amount).add(web3.utils.toBN(mylisting.depositSender)).mul(web3.utils.toBN(quantity)))) {
                          await Swal.fire(translateThis("You don't have enough funds. Please deposit funds first before proceeding."));
                          return false;
                      }
                      if (web3.utils.toBN(counterbalance).lt(web3.utils.toBN(mylisting.depositRecipient).mul(web3.utils.toBN(quantity)))) {
                          await Swal.fire(translateThis("The counter-party does not have enough funds in their account to proceed. Please notify the counter-party."));
                          return false;
                      }
                    }
                    if(mylisting.recipient == "0x0000000000000000000000000000000000000000") {
                      if (web3.utils.toBN(balances[mylisting.token].amount).lt(web3.utils.toBN(mylisting.depositRecipient).mul(web3.utils.toBN(quantity)))) {
                          await Swal.fire(translateThis("You don't have enough funds. Please deposit funds first before proceeding."));
                          return false;
                      }
                      if (web3.utils.toBN(counterbalance).lt(web3.utils.toBN(mylisting.amount).add(web3.utils.toBN(mylisting.depositSender)).mul(web3.utils.toBN(quantity)))) {
                          await Swal.fire(translateThis("The counter-party does not have enough funds in their account to proceed. Please notify the counter-party."));
                          return false;
                      }
                    }
                    var datalen = 0;
                    var contact2 = '';
                    try {
                        datalen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(counterparty, 3).call());
                        if(datalen > 0) {
                            contact2 = JSON.parse(DOMPurify.sanitize(await DDEcontract.methods.userdata(counterparty, datalen-1).call()));
                        }
                    } catch(e) {
                        console.log(e);
                    }
                    //If one wants to show a grand total
                    //mylisting.amount *= quantity;
                    //mylisting.depositSender *= quantity;
                    //mylisting.depositRecipient *= quantity;
                    var result = await showListing(mylisting, 3)
                    if(result == false) {
                      return;
                    }
                    if (!web3.utils.isAddress(referral)) {
                        referral = "0x0000000000000000000000000000000000000000";
                    }
                    await DDEcontract.methods.acceptOffer(
                      mylisting.hash,
                      quantity.toString(),
                      accepttimelimit.toString(),
                      referral
                    ).send({"from":myaccounts,...gasOptions[gasSetting]});
                      await Swal.fire(translateThis("Contract accepted!"));
                      await loadUser();
                      if(emailClient.checked && contact2 != '' && typeof contact2 === 'object' && 'mycontact' in contact2 && contact2['mycontact'].includes("@")) {
                        Swal.fire({
                          title: translateThis('Notify Counterparty'),
                          text: translateThis('Would you like to email the counterparty to notify them of your offer?'),
                          icon: 'question',
                          showCancelButton: true,
                          confirmButtonText: translateThis('Yes'),
                          cancelButtonText: translateThis('No'),
                        }).then((result) => {
                          if (result.isConfirmed) {
                            var emailSubject = encodeURIComponent(translateThis('Your offer on BitBay markets was accepted'));
                            var emailBody = encodeURIComponent(translateThis('Hello, this email was automatically composed to let you know that I have accepted your offer on the BitBay marketplace. For safety reasons, do not click any links from this email however you may log in to the official website on your own. Also for your safety, please only contact users at the email officially registered to their contracts. If you have any questions about our contract please let me know. Thank you and have a nice day.'));
                            const mailtoLink = `mailto:${contact2['mycontact']}?subject=${emailSubject}&body=${emailBody}`;
                            window.location.href = mailtoLink;
                          }
                        });
                      }
                  });
                }
              } else {
                quantity = mylisting.quantity[0];
                var counterparty = mylisting.sender;
                if(mylisting.sender == myaccounts) {
                    counterparty = mylisting.recipient;
                }
                var counterbalance = "";
                await DDEcontract.methods.userBalance(counterparty,mylisting.token).call().then(function (bal) {            
                        counterbalance = DOMPurify.sanitize(bal);
                });
                if(mylisting.sender == myaccounts) {
                  if (web3.utils.toBN(balances[mylisting.token].amount).lt(web3.utils.toBN(mylisting.amount).add(web3.utils.toBN(mylisting.depositSender)).mul(web3.utils.toBN(quantity)))) {
                      await Swal.fire(translateThis("You don't have enough funds. Please deposit funds first before proceeding."));
                      return false;
                  }
                  if (web3.utils.toBN(counterbalance).lt(web3.utils.toBN(mylisting.depositRecipient).mul(web3.utils.toBN(quantity)))) {
                      await Swal.fire(translateThis("The counter-party does not have enough funds in their account to proceed. Please notify the counter-party."));
                      return false;
                  }
                }
                if(mylisting.recipient == myaccounts) {
                  if (web3.utils.toBN(balances[mylisting.token].amount).lt(web3.utils.toBN(mylisting.depositRecipient).mul(web3.utils.toBN(quantity)))) {
                      await Swal.fire(translateThis("You don't have enough funds. Please deposit funds first before proceeding."));
                      return false;
                  }
                  if (web3.utils.toBN(counterbalance).lt(web3.utils.toBN(mylisting.amount).add(web3.utils.toBN(mylisting.depositSender)).mul(web3.utils.toBN(quantity)))) {
                      await Swal.firetranslateThis(("The counter-party does not have enough funds in their account to proceed. Please notify the counter-party."));
                      return false;
                  }
                }
                var datalen = 0;
                var contact2 = '';
                try {
                    datalen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(counterparty, 3).call());
                    if(datalen > 0) {
                        contact2 = JSON.parse(DOMPurify.sanitize(await DDEcontract.methods.userdata(counterparty, datalen-1).call()));
                    }
                } catch(e) {
                    console.log(e);
                }
                //If one wants to show a grand total
                //mylisting.amount *= quantity;
                //mylisting.depositSender *= quantity;
                //mylisting.depositRecipient *= quantity;
                var result = await showListing(mylisting, 3)
                if(result == false) {
                  return;
                }
                if (!web3.utils.isAddress(referral)) {
                    referral = "0x0000000000000000000000000000000000000000";
                }
                await DDEcontract.methods.acceptOffer(
                  mylisting.hash,
                  quantity.toString(),
                  accepttimelimit.toString(),
                  referral
                ).send({"from":myaccounts,...gasOptions[gasSetting]});
                  await Swal.fire(translateThis("Contract accepted!"));
                  await loadUser();
                  if(emailClient.checked && contact2 != '' && typeof contact2 === 'object' && 'mycontact' in contact2 && contact2['mycontact'].includes("@")) {
                    Swal.fire({
                      title: translateThis('Notify Counterparty'),
                      text: translateThis('Would you like to email the counterparty to notify them of your offer?'),
                      icon: 'question',
                      showCancelButton: true,
                      confirmButtonText: translateThis('Yes'),
                      cancelButtonText: translateThis('No'),
                    }).then((result) => {
                      if (result.isConfirmed) {
                        var emailSubject = encodeURIComponent(translateThis('Your offer on BitBay markets was accepted'));
                        var emailBody = encodeURIComponent(translateThis('Hello, this email was automatically composed to let you know that I have accepted your offer on the BitBay marketplace. For safety reasons, do not click any links from this email however you may log in to the official website on your own. Also for your safety, please only contact users at the email officially registered to their contracts. If you have any questions about our contract please let me know. Thank you and have a nice day.'));
                        const mailtoLink = `mailto:${contact2['mycontact']}?subject=${emailSubject}&body=${emailBody}`;
                        window.location.href = mailtoLink;
                      }
                    });
                  }
              }
        } catch (error) {
            console.error(error);
            await showError(error);
        }
    }
    async function counterOffer(listing) {
        await createContract(false, listing);
    }
    async function cancelOffer(listing, hide=0) {
      if(hide == 1) {
          const dialog = document.createElement("div");
          dialog.innerHTML = `
            <div>` + translateThis('Would you like to hide this offer or cancel it?') + '<br>' + translateThis('Hiding just removes it from the list.') + '<br>' + translateThis('Cancelling will also notify the other party.') + `<br><br></div>
            <div>
              <button id="hide-btn">` + translateThis('Hide') + `</button>&nbsp;&nbsp;
              <button id="cancel-btn">` + translateThis('Cancel') + `</button>
            </div>
          `;
          dialog.style.display = "block";
          dialog.style.position = "fixed";
          dialog.style.zIndex = 999;
          dialog.style.backgroundColor = "white";
          dialog.style.padding = "20px";
          dialog.style.borderRadius = "10px";
          dialog.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.3)";
          dialog.style.top = "50%";
          dialog.style.left = "50%";
          dialog.style.transform = "translate(-50%, -50%)";

          document.body.appendChild(dialog);

          const hideBtn = dialog.querySelector("#hide-btn");
          const cancelBtn = dialog.querySelector("#cancel-btn");

          hideBtn.addEventListener("click", async () => {
            var readMessages = JSON.parse(localStorage.getItem(myaccounts+":readmessages2")) || {};
            readMessages[listing.index] = true;
            localStorage.setItem(myaccounts+":readmessages2", JSON.stringify(readMessages));            
            await loadUser();
            dialog.remove();
          });

          cancelBtn.addEventListener("click", async () => {
            try {
              dialog.remove();
              await DDEcontract.methods.cancelPrivateOffer(
                listing.hash,
                myaccounts
              ).send({"from":myaccounts,...gasOptions[gasSetting]});
              await Swal.fire(translateThis("Contract removed!"));
              await loadUser();
            } catch (error) {
              console.error(error);
              await showError(error);
            }
          });
      } else {
          try {
                if(listing.sender == "0x0000000000000000000000000000000000000000" || listing.recipient == "0x0000000000000000000000000000000000000000" ) {
                  await DDEcontract.methods.removeMarketOffer(
                    listing.hash,
                    myaccounts
                  ).send({"from":myaccounts,...gasOptions[gasSetting]});
                  await Swal.fire(translateThis("Contract removed!"));
                  await loadUser();
                } else {
                  await DDEcontract.methods.cancelPrivateOffer(
                    listing.hash,
                    myaccounts
                  ).send({"from":myaccounts,...gasOptions[gasSetting]});
                  await Swal.fire(translateThis("Contract removed!"));
                  await loadUser();
                }
            } catch (error) {
                console.error(error);
                await showError(error);
            }
      }      
    }
    async function updateQuantity(listing) {
      const dialog = document.createElement("div");
      dialog.innerHTML = `
        <div>` + translateThis('Please enter the updated quantity:') + `<br></div>
          <label for="new-quantity">` + translateThis('Total Supply:') + ` </label>
          <input id="new-quantity" type="number" min="1"></input><br><br>
          <label for="new-maximum">` + translateThis('Maximum:') + ` </label>
          <input id="new-maximum" type="number" min="1"></input><br><br>
        <div>
          <button id="confirm-btn">` + translateThis('Confirm') + `</button>&nbsp;&nbsp;
          <button id="cancel-btn">` + translateThis('Cancel') + `</button>
        </div>
      `;
      dialog.style.display = "block";
      dialog.style.position = "fixed";
      dialog.style.zIndex = 999;
      dialog.style.backgroundColor = "white";
      dialog.style.padding = "20px";
      dialog.style.borderRadius = "10px";
      dialog.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.3)";
      dialog.style.top = "50%";
      dialog.style.left = "50%";
      dialog.style.transform = "translate(-50%, -50%)";

      document.body.appendChild(dialog);

      const confirmBtn = dialog.querySelector("#confirm-btn");
      const cancelBtn = dialog.querySelector("#cancel-btn");

      cancelBtn.addEventListener("click", async () => {
        dialog.remove();
        return;
      });

      confirmBtn.addEventListener("click", async () => {
        try {
              var quantity = parseInt(document.getElementById('new-quantity').value);
              if(quantity == 0) {
                dialog.remove();
                await Swal.fire(translateThis("Quantity can not be changed to zero!"));
                return;
              }
              var quantity1 = parseInt(document.getElementById('new-maximum').value);
              if(quantity1 == 0) {
                dialog.remove();
                await Swal.fire(translateThis("Quantity can not be changed to zero!"));  
                return;
              }
              await DDEcontract.methods.updateQuantity(
                listing.hash,
                [quantity.toString(), quantity1.toString()]
              ).send({"from":myaccounts,...gasOptions[gasSetting]});
                dialog.remove();
                await Swal.fire(translateThis("Quantity updated!"));
                await loadUser();
                return;
        } catch (error) {
            console.error(error);
            await showError(error);
        }
        dialog.remove();
      });
    }

    async function updateFee(listing) {
      await Swal.fire({
        title: translateThis('Set order fee'),
        text: translateThis('Please enter the percentage fee that you wish to offer to affiliates for this order.'),
        input: 'range',
        inputAttributes: {
          min: (baseFee / 100).toFixed(1),
          max: 50,
          step: 0.1,
          value: 0 // Set the initial value as needed
        },
        inputValue: (baseFee / 100).toFixed(1), // Set the initial value as needed
        showCancelButton: true,
        inputLabel: 'Percentage',
        preConfirm: (value) => {
        }
      }).then(async (result) => {
        if (result.isConfirmed) {
          var value = parseInt(result.value) * parseInt(100);
          try {
            await DDEcontract.methods.changeReferralFee(listing.hash,value).send({"from":myaccounts,...gasOptions[gasSetting]});
            Swal.fire(translateThis("Success!"));
            await loadUser();
          } catch (error) {
            console.log(error);
            await showError(error);
          }
        }
      });
    }

    async function addAPI(text) {
        var data = CryptoJS.AES.encrypt(JSON.stringify(text), AESkey).toString();
        console.log(data)
        try {
            await DDEcontract.methods.adddata(data).send({"from":myaccounts,...gasOptions[gasSetting]});
            await Swal.fire(translateThis("Data added!"));
          } catch (error) {
            console.error(error);
            await showError(error);
        }
    }
    async function getAPI(index) {
        await DDEcontract.methods.publicdata(index).call().then(function (data) {
                data=JSON.parse(DOMPurify.sanitize(CryptoJS.AES.decrypt(data, AESkey).toString(CryptoJS.enc.Utf8)));
                if (data.length === 2) { //using public gateway
                    pinataApiKey = data[0];
                    pinataSecretApiKey = data[1];
                    pinataGateway = 'https://gateway.pinata.cloud/ipfs/';
                } else {
                    if (!Array.isArray(data)) {
                        data = JSON.parse(data);
                    }
                    if(data.length === 3) {
                        pinataApiKey = data[0];
                        pinataSecretApiKey = data[1];
                        pinataGateway = data[2];
                    } else {
                        pinataApiKey = data[0];
                        pinataSecretApiKey = data[1];
                        pinataGateway = data[2];
                        pinataToken = data[3];
                    }
                }
        });
    }
    setInterval(loadUser, 90000);
    loadMarkets(1, 50);
    //Notes:
    //It's an interesting idea to let users post an API key for GPT so that new offers can be curated
    //Having users who iterate all contracts and collect all the tags to share with other users on front end
    //A page that looks like "craigs list/classified ads" to browse all the key words and tags
    //Instructions on how to set up an IPFS node and letting the system synchronize with multiple nodes
    //Having it so users can set up blockchain nodes and let other users access/poll multiple nodes at once through API(like electrum)
    //Making it so users can exchange market data using something like gundb or webrtc/torrent protocols
</script>
</body>
</html>