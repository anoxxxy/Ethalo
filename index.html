<!DOCTYPE html>
<script type="text/javascript" src="./purify.js"></script>
<script type="text/javascript" src="./DDEABI.js"></script>
<script type="text/javascript" src="./ERC20.js"></script>
<script type="text/javascript" src="./crypto-sha256.js"></script>
<script type="text/javascript" src="./crypto-js.js"></script>
<script type="text/javascript" src="./bignumber.min.js"></script>
<script type="text/javascript" src="./sweetalert211.js"></script>
<script src="./axios.min.js"></script>
<script src="./web3.min.js"></script>
<script src="./jdenticon.min.js"></script>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script type="text/javascript" src="./translate.js"></script>
    <link rel="icon" type="image/x-icon" href="./favicon.ico">
    <title t-id="1">BitBay Decentralized Markets</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            font-size: 14px;
        }
        #languageSelect {
          padding: 10px;
          font-size: 16px;
        }
        #selectedFlag {
          width: 30px;
          height: 30px;
          margin-right: 5px;
        }
        .container {
            display: flex;
            flex-direction: row;
            height: 100vh;
        }
        .sidebar {
            width: 100px;
            background-color: #f2f2f2;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 10px;
            padding-bottom: 30px;
        }
        .sidebar button {
            width: 80px;
            height: 80px;
            margin-bottom: 10px;
            border: none;
            border-radius: 5px;
            background-color: transparent;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .sidebar button:hover {
            box-shadow: 0 0 10px #7c7c7c;
        }
        .sidebar button img {
            margin-top: 10px;
            width: 30px;
            height: 30px;
        }
        .sidebar button span {
            line-height: 1; /* Set line-height to 1 to avoid vertical shifting */
        }
        .main {
            flex: 1;
            padding: 20px;
            display: none;
        }
        .main.show {
            display: block;
        }
        .header {
            height: 50px;
            background-color: #f2f2f2;
            display: flex;
            flex-direction: row;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 2px 5px #ccc;
        }
        .header2 {
            height: 50px;
            background-color: #f2f2f2;
            display: flex;
            flex-direction: row;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 2px 5px #ccc;
        }
        .header2 a {
            text-decoration: none; /* Remove underlining */
            color: #333; /* Change link color */
            margin-right: 10px; /* Add some spacing between links */
            font-size: 8.5px;
        }
        /* Change link color on hover */
        .header2 a:hover {
            color: #007bff; /* Change link color on hover */            
        }
        .header h1 {
            font-size: 12px;
            margin: 0;
            margin-left: 10px;
            flex: 1;
        }
        @media screen and (min-width: 600px) {
          .header2 a {
            font-size: 11px;
            margin-right: 20px;
          }
        }
        @media screen and (min-width: 800px) {
          .header h1 {
            font-size: 20px; /* Adjust the font size for larger screens */
          }
          .header2 a {
            font-size: 14px;
            margin-right: 30px;
          }
        }
        .header button {
            padding: 10px;
            background-color: #ccc;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
        }
        .connect {
            display: flex;
            flex-direction: row;
            align-items: center;
            margin-left: auto;
        }
        .connect button {
            background-color: #4caf50;
            color: #fff;
            margin-right: 10px;
        }
        .footer {
            position: fixed;
            left: 0;
            bottom: 0;
            height: 50px;
            width: 100%;
            background-color: #f2f2f2;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            box-shadow: 0 -2px 5px #ccc;
        }
        .footer img {
            width: 30px;
            height: 30px;
            margin: 0 10px;
            cursor: pointer;
        }
        .main.markets {
            min-height: calc(100% - 100px); /* Subtract footer height */
            max-height: calc(100% - 100px); /* Subtract footer height */
            overflow-y: auto; /* Enable vertical scrolling if content overflows */
            margin-bottom: 50px;
        }
        .main.offers {
            min-height: calc(100% - 100px); /* Subtract footer height */
            max-height: calc(100% - 100px); /* Subtract footer height */
            overflow-y: auto; /* Enable vertical scrolling if content overflows */
        }
        .main.contracts {
            min-height: calc(100% - 100px); /* Subtract footer height */
            max-height: calc(100% - 100px); /* Subtract footer height */
            overflow-y: auto; /* Enable vertical scrolling if content overflows */
        }
        .main.account {
            min-height: calc(100% - 100px); /* Subtract footer height */
            max-height: calc(100% - 100px); /* Subtract footer height */
            overflow-y: auto; /* Enable vertical scrolling if content overflows */
        }
        .main.about {
            min-height: calc(100% - 100px); /* Subtract footer height */
            max-height: calc(100% - 100px); /* Subtract footer height */
            overflow-y: auto; /* Enable vertical scrolling if content overflows */
        }
    </style>
</head>
<body>
    <div class="header">
        <img src="bitbay.png" alt="Logo" height="20px" width="20px">
        <h1 t-id="2">BitBay Decentralized Markets</h1>
        <img id="selectedFlag" src="english.png" alt="Selected Flag">
        <select id="languageSelect" style="margin-right: 20px; font-size: 10px; width: 75px;">
          <option value="default" disabled selected>Default</option>
        </select>
        <div class="connect">
            <button t-id="3" onclick="login()">Connect Metamask</button>
            <div id="connectionstatus" class="connectionstatus" t-id="4">Not connected</div>
        </div>
    </div>
    <div class="container">
        <div class="sidebar">
            <button onclick="showMain('markets')" id="marketsButton"><img src="markets.png" alt="Markets" style="display: block;"><span class="text" t-id="5">Markets</span></button>
            <button onclick="showMain('offers')" id="offersButton"><img src="ethalo.png" alt="Offers" style="display: block;"><span class="text" t-id="6">Offers</span></button>
            <button onclick="showMain('contracts')" id="contractsButton"><img src="contracts.png" alt="Contracts" style="display: block;"><span class="text" t-id="7">Contracts</span></button>
            <button onclick="showMain('account')" id="accountButton"><img src="account.png" alt="Account" style="display: block;"><span class="text" t-id="8">Account</span></button>
            <button onclick="showMain('about')" id="aboutButton"><img src="about.png" alt="About" style="display: block;"><span class="text" t-id="9">About</span></button>
        </div>
    <div class="main markets">
        <div class="header2">
            <a href="#" t-id="10" onclick="changeSearchText('goods')">Goods</a>
            <a href="#" t-id="11" onclick="changeSearchText('services')">Services</a>
            <a href="#" t-id="12" onclick="changeSearchText('barter')">Barter</a>
            <a href="#" t-id="13" onclick="changeSearchText('p2p-trading')">P2P Trading</a>
            <a href="#" t-id="14" onclick="changeSearchText('commodities')">Commodities</a>
        </div>
        <h2 t-id="15">Markets</h2>
        <div class="top-bar">
            <button onclick="createContract()" t-id="16">Create Contract/Offer</button>
            <div class="search">
                <img src="search.png" height="20px" width="20px" alt="Search">
                <input type="text" id="searchText" placeholder="Search" onkeyup="searchListings(this.value)">
                <button onclick="searchListings(getElementById('searchText').value, 1)" t-id="17">Search</button><div id="loadingStatus"></div>
                <div class="pagination">
                    <br>
                    <button onclick="previousPage()" t-id="18">Previous</button>
                    <button onclick="nextPage()" t-id="19">Next</button>
                    <select id="SortBy">
                      <option value="default" t-id="20">Sort: Default</option>
                      <option value="price-low" t-id="21">Sort: Best price</option>
                      <option value="price-high" t-id="22">Sort: High price</option>
                    </select>
                </div>
            </div>
        </div>
        <div class="listings">
            <!-- populated by JavaScript -->
        </div>
    </div>
    <div class="main offers">
        <h2 t-id="23">Offers</h2>
        <div id="myoffers" class="myoffers"></div>
    </div>
    <div class="main contracts">
        <h2 t-id="24">Contracts</h2>
        <div id="mycontracts" class="mycontracts"></div>
    </div>
    <div class="main account">
        <h2 t-id="25">Account</h2>
        <p id="account" t-id="26">Please connect metamask</p>
        <button onclick="deposit()" t-id="27">Deposit tokens</button>
        <button onclick="withdraw()" t-id="28">Withdraw tokens</button><br><br>
        <label for="myContactInfo" t-id="29">Contact Information(email/signal/telegram):</label><br>
        <input id="myContactInfo"></input><br><br>
        <button onclick="registerEmail(document.getElementById('myContactInfo').value)" t-id="30">Register contact information to my address(optional)</button><br>
        <div id="publicemail"></div><br><br>
        <label for="clearCompleted" t-id="31">Automatically clear completed contracts</label>
        <input id="clearCompleted" type="checkbox"></input><br><br>
        <button onclick="RefreshContracts()" t-id="32">Refresh/restore previously cleared contracts</button><br><br>
        <label for="offerExpiration" t-id="33">Private offers expire: </label>
        <select id="offerExpiration">
          <option value="never" t-id="34">Never</option>
          <option value="two-weeks" t-id="35">Two weeks</option>
          <option value="one-month" t-id="36">One month</option>
        </select>
        <br><br>
        <button onclick="backupLocalStorage()" t-id="37">Backup cached site/user data</button>
        <button onclick="loadLocalStorage()" t-id="38">Load site/user data from file</button><br><br>
        <select id="connectMethod">
          <option value="0" t-id="39">Use default IPFS Pinata Gateway</option>
        </select>
        <br><br>
    </div>
    <div class="main about">
        <h2 t-id="40">About</h2>
        <p t-id="41">Welcome to the world of unbreakable contracts. These are two party escrow(double deposit) contracts that cannot be broken and require no 3rd party arbiters. Both users place a customizable deposit along with a payment into a joint account. If the deal goes well they both sign off on it. If one party tries to defraud the other the deal will eventually expire and blow up making it so that nobody wins and theft is profitless. This forces the users to be honest and follow through with their agreements since they either win together or they lose together.</p><br><br><a href="https://www.youtube.com/watch?v=fge5inFWlkc"><img src="two-party-escrow.jpg" style="width: 100%; max-width: 700px; align-items: center; display: block; margin-left: auto; margin-right: auto;"></a><p t-id="42">The markets themselves run on top of Solidity chains such as Ethereum and Polygon. Offers can range from goods, services, barter and p2p trading. Since this webpage is fully open source and runs on the client side, the user can also download this code from github and run it locally for even greater security. This protocol which was pioneered by BitHalo back in 2014 predated Ethereum and was the worlds first smart contracts. This is a web based interface for fully decentralized markets.</p><br><br><p t-id="43">For selling goods, users will definitely want to consider a drop shipping service or a service that provides discount shipping to compete with the shipping rates typically found in major companies. To do this, you should sign up for a 3rd party shipping account which should allow you to save well over 75% in shipping. Sellers may also charge buyers for shipping while in escrow and buyers should be careful to make sure the amount doesn't exceed the deposits or that they buy the shipping label themselves. Users should try to keep in communication with each other through the escrow process and it's recommended to have a backup of your keys so both parties are protected during escrow. Although these markets could be moderated through AI(such as webgpt) and community driven moderation, users are entirely responsible for the risks of what they post and for their own escrows. With that in mind, it's strongly recommended to not post content that is illegal in the country you reside. For deals that involve cash users should do their own due dilligence and their own "know your customer" if needed. It's in everyones best interest to use double deposit escrow to get rid of deception in the world of international commerce and services. It is an advantage when users administrate contracts themselves because arbiters are unable to know the truth of a deal ruling unfairly and can collude causing great losses and they also incur a greater cost. Users are forced to work with each other to achieve a desirable outcome. Users are also the ones who host the offers using IPFS. So it's good practice to run your own IPFS node to archive the markets. It's recommended that you register your contact information to the blockchain. This makes it guaranteed that counter-parties in the contract know how to contact you for any questions about the negotiations. The code may be run locally and can also be audited by visiting the github page where the code and website are hosted. BitBay does not take any fees for the escrows. This system is entirely free to use. For more information on how all of this works you may visit: </p><a href="https://bitbay.market" target="_blank">https://bitbay.market</a>
    </div>
</div>
<div class="footer">
    <a href="https://bitbay.market" target="_blank"><img src="bitbay.png" text="BitBay"></a>
    <a href="https://t.me/bitbayofficial" target="_blank"><img src="telegram.png" alt="Telegram"></a>
    <a href="https://medium.com/bitbay-blog" target="_blank"><img src="medium.png" alt="Medium"></a>
    <a href="https://github.com/bitbaymarket" target="_blank"><img src="github.png" alt="Github"></a>
</div>
<script>
    function populateLanguageSelect() {
      const languageSelect = document.getElementById("languageSelect");

      langOptions.forEach((lang) => {
        const option = document.createElement("option");
        option.value = lang.substring(0, 2).toLowerCase();
        option.textContent = lang;
        
        // Create and append flag image
        const flagImg = document.createElement("img");
        flagImg.src = `${lang.toLowerCase()}.png`;
        flagImg.alt = lang;
        option.appendChild(flagImg);

        languageSelect.appendChild(option);
      });
      languageSelect.selectedIndex = 0;
    }

    document.getElementById("languageSelect").addEventListener('change', function() {
        const languageSelect = document.getElementById("languageSelect");
        const selectedFlagImg = document.getElementById("selectedFlag");
        selectedFlagImg.src = languageSelect.options[languageSelect.selectedIndex].getElementsByTagName('img')[0].src;
        translateDocument(languageSelect.options[languageSelect.selectedIndex].value);
    });

    function translateThis() {
      const selectedLanguageCode = document.getElementById("languageSelect").value;
      console.log("Selected Language Code:", selectedLanguageCode);
      translateDocument(selectedLanguageCode);
    }
    window.onload = populateLanguageSelect;

    function translate(text, lang, x) {
        if(lang in languages && x in languages[lang]) {
            return languages[lang][x]["#"+lang];
        } else {
            return text;
        }
    }

    function translateDocument(lang) {
        document.querySelectorAll('[t-id]').forEach(element => {
            const tId = element.getAttribute('t-id');
            const nonTextContent = Array.from(element.childNodes).filter(node => node.nodeType !== 3);
            const textContent = element.textContent;
            languages[tId] = { "#e": textContent };

            // Translate the text content
            const translatedText = translate(textContent, lang, tId);

            // Update the text content
            element.textContent = translatedText;

            // Reinsert the non-text content
            nonTextContent.forEach(node => element.appendChild(node));
        });
    }

    var loadedFiles = {};
    // Open or create the IndexedDB database
    var request = indexedDB.open('fileDatabase', 1);

    // Setup the database structure if it doesn't exist
    request.onupgradeneeded = async function(event) {
      db = event.target.result;
      var objectStore = db.createObjectStore('files', { keyPath: 'hash' });
      objectStore.createIndex('hash', 'hash', { unique: true });
    };

    // Assign the database reference once it's successfully opened
    request.onsuccess = function (event) {
      return new Promise(async function (resolve) {
        db = event.target.result;

        // Initialize loadedFiles from IndexedDB
        var transaction = db.transaction(['files'], 'readonly');
        var objectStore = transaction.objectStore('files');

        objectStore.getAll().onsuccess = function (event) {
          loadedFiles = event.target.result.reduce(function(obj, file) {
            obj[file.hash] = file.data;
            return obj;
          }, {});

          resolve(); // Resolve the promise once the asynchronous operation is done
        };
      });
    };

    // Function to open the IndexedDB database
    async function openDatabase() {
      return new Promise(function(resolve, reject) {
        var request = indexedDB.open('fileDatabase', 1);

        request.onupgradeneeded = function(event) {
          db = event.target.result;
          var objectStore = db.createObjectStore('files', { keyPath: 'hash' });
          objectStore.createIndex('hash', 'hash', { unique: true });
        };

        request.onsuccess = function(event) {
          db = event.target.result;
          resolve();
        };

        request.onerror = function(event) {
          reject(event.target.error);
        };
      });
    }

    // Function to initialize loadedFiles from IndexedDB
    async function initializeLoadedFiles() {
      return new Promise(function(resolve, reject) {
        var transaction = db.transaction(['files'], 'readonly');
        var objectStore = transaction.objectStore('files');

        objectStore.getAll().onsuccess = function(event) {
          loadedFiles = event.target.result.reduce(function(obj, file) {
            obj[file.hash] = file.data;
            return obj;
          }, {});
          resolve();
        };

        transaction.onerror = function(event) {
          reject(event.target.error);
        };
      });
    }

    // Function to get file from IndexedDB
    async function getFile(hash) {
      return new Promise(function (resolve, reject) {
        if(hash=='') {
          resolve(['']);
        }
        // Check if the file hash is in loadedFiles
        if (!(hash in loadedFiles)) {
          // If not, fetch it from IndexedDB
          var transaction = db.transaction(['files'], 'readonly');
          var objectStore = transaction.objectStore('files');

          var request = objectStore.get(hash);

          request.onsuccess = async function (event) {
            var file = event.target.result;
            if (file) {
              loadedFiles[hash] = file.data;
              resolve(loadedFiles[hash]); // Resolve the promise with the file data
            } else {
              resolve(['']); //Image not found in IndexedDB
            }
          };

          request.onerror = async function (event) {
            resolve(['']); //event.target.error
          };
        } else {
          resolve(loadedFiles[hash]); // Resolve the promise with the cached file data
        }
      });
    }


    // Function to store image/file in IndexedDB
    async function storeFile(hash, data) {
      // Open a read-write transaction
      var transaction = db.transaction(['files'], 'readwrite');
      var objectStore = transaction.objectStore('files');
      // Put the file data into the object store
      objectStore.put({ hash: hash, data: data });
      loadedFiles[hash] = data;
    }

    async function storeFiles(files) {
      // Open a read-write transaction
      var transaction = db.transaction(['files'], 'readwrite');
      var objectStore = transaction.objectStore('files');

      for (var hash in files) {
        objectStore.put({ hash: hash, data: files[hash] });
      }
      loadedFiles = files;
    }

    function changeSearchText(newText) {
        document.getElementById('searchText').value = newText;
        searchListings(newText, 1);
    }

    document.getElementById('SortBy').addEventListener('change', function () {
        populateListings();
    });

    showMain('markets');
    var web3 = [];
    var DDEcontract = "";
    var DDEaddy = "";
    var myaccounts = "";
    var balances = {};
    var baseBalance = 0;
    var myContactInfo = document.getElementById("myContactInfo");
    var offerExpiration = document.getElementById("offerExpiration");
    var AESkey = Crypto.SHA256("shared key")
    var currentMarketsLength = 0;
    var gasPrice = "";
    var CurrentTimeStamp = new Date().getTime();
    var tokens = [
        {
            address: "0xdfFd57fa61eC2ad0fa260Fa8368ff7F2EEF4407E",
            token: "ETH",
            image: "eth.png",
            decimals: "18"
        },
        {
            address: "0xb3460166784fd07A022E51547379352De4E98dF5",
            token: "WALRUS",
            image: "walrus.png",
            decimals: "8"
        }
    ];
    var tokennames = {"0xdfFd57fa61eC2ad0fa260Fa8368ff7F2EEF4407E":"ETH","0xb3460166784fd07A022E51547379352De4E98dF5":"WALRUS"}
    web3 = new Web3("https://rpc.ankr.com/eth_goerli");
    DDEaddy = "0x08576389321C1999d1A66db093CDd8655615b4cE"; //Goerli testnet is default market view
    var DDEcontract2 = new web3.eth.Contract(DDEabi, DDEaddy);
    var marketOffers = {'indices':[], 'results':[]};
    //web3[0] = new Web3("https://cloudflare-eth.com");
    //web3[1] = new Web3("https://bsc-dataseed.binance.org");
    //web3[2] = new Web3("https://api-goerli.etherscan.io/");
    var isConnected = false;
    window.addEventListener('ethereum#initialized', login, {
        once: true,
    });

    window.addEventListener("load", async function() {
      if (window.ethereum) {
        // detect Metamask account change
        window.ethereum.on('accountsChanged', async function (newaccounts) {
          console.log('accountsChanges',newaccounts);
          defaultvars();
          await login();
        });
         // detect Network account change
        window.ethereum.on('chainChanged', async function(thenetworkId){
          console.log('chainChanged',thenetworkId);
          marketOffers = {'indices':[], 'results':[]};
          defaultvars();
          await login();
        });
      }
    });    
    defaultvars();
    function defaultvars() {
        DDEcontract = "";
        myaccounts = "";
        DDEaddy = "";
        balances = {};
        baseBalance = 0;
        gasPrice = "";
        document.getElementById("account").innerHTML = "Not connected.";
        document.getElementById("myContactInfo").value = '';
        document.getElementById("myoffers").innerHTML = ""; // clear the container first
        document.getElementById("mycontracts").innerHTML = ""; // clear the container first
        document.getElementById('publicemail').innerHTML = "";
        offerExpiration.selectedIndex = 0;
        currentMarketsLength = 0;
    }

    async function login() {
        if (window.ethereum) { //Note: for mobile this only works if the webpage has <head> tag
            console.log("connecting");
            await window.ethereum.request({method: 'eth_requestAccounts'});
            web3 = new Web3(window.ethereum);
            console.log("success");
            isConnected = true;
            document.getElementById("connectionstatus").innerHTML = "Connected."            
            await loadUser(1);
            await populateListings();            
        } else {
            isConnected = false;
            document.getElementById("connectionstatus").innerHTML = "Not connected."
        }
    }

    async function loadUser(login=0) {
        if (!isConnected) {
            return;
        }
        var myaccounts2 = await web3.eth.getAccounts();
        if (myaccounts2.length == 0) {
            document.getElementById("connectionstatus").innerHTML = "Please unlock Metamask so it can connect.";
            return;
        }
        currentChainId = DOMPurify.sanitize(await web3.eth.net.getId());
        var netname = "unknown";
        var netname2 = "ETH";
        if (currentChainId == 5) {
            netname = "Goerli Testnet";
            netname2 = "ETH";
            DDEaddy = "0x08576389321C1999d1A66db093CDd8655615b4cE";            
        }
        if (netname == "unknown") {
            document.getElementById("connectionstatus").innerHTML = "Unsupported network";
            return;
        }
        document.getElementById("connectionstatus").innerHTML = "Connected to " + netname;
        web3.eth.getGasPrice().then(function (theGasPrice) {
            gasPrice = DOMPurify.sanitize(theGasPrice);
        });
        myaccounts = DOMPurify.sanitize(myaccounts2[0]);
        var cached = await getContactInfo(myaccounts);
        document.getElementById("myContactInfo").value = cached;
        cached = await getExpirationInfo(myaccounts);
        var offerExpirationSelect = document.getElementById("offerExpiration");
        if (cached != '') {
            for (let i = 0; i < offerExpirationSelect.options.length; i++) {
              if (offerExpirationSelect.options[i].value === cached) {
                offerExpirationSelect.selectedIndex = i;
                break;
              }
            }
        } else {
            offerExpirationSelect.selectedIndex = 0;
        }
        loadAutoClearState();
        const currentBlockNumber = await web3.eth.getBlockNumber();
        const currentBlock = await web3.eth.getBlock(currentBlockNumber);
        CurrentTimeStamp = DOMPurify.sanitize(currentBlock.timestamp);
        DDEcontract = new web3.eth.Contract(DDEabi, DDEaddy);
        balances = {};
        var btext = [];
        for (var i = 0; i < tokens.length; i++) {
            await DDEcontract.methods.userBalance(myaccounts,tokens[i].address).call().then(function (liquid1) {            
                    balances[tokens[i].address]=({token:tokens[i].token, decimals: tokens[i].decimals, amount: DOMPurify.sanitize(liquid1)});
                    btext+="<br>"+balances[tokens[i].address].token+" balance deposited to markets: "+displayDecimals(tokens[i].address, balances[tokens[i].address].amount);
            });
        }
        await window.web3.eth.getBalance(myaccounts, function(err, result1) {
            if (err) {
                console.log(err);
                return;
            } else {
                baseBalance = DOMPurify.sanitize(result1);//window.web3.utils.fromWei(result1, "ether");
                document.getElementById("account").innerHTML = DOMPurify.sanitize("Current Network: "+ netname + "<br>" + myaccounts + "<br>" + netname2 + " wallet balance:" + window.web3.utils.fromWei(baseBalance, "ether") + btext);
            }
        });
        var contact2 = '';
        var datalen = 0;
        try {
            datalen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(myaccounts, 3).call());
            if(datalen > 0) {
                contact2 = DOMPurify.sanitize(await DDEcontract.methods.userdata(myaccounts, datalen-1).call());
                document.getElementById('publicemail').innerHTML = "Registered contact information: " + contact2;
            } else {
                document.getElementById('publicemail').innerHTML = "";
            }
        } catch(e) {
            console.log(e);
        }
        if(login == 1) {
            await getUserAPI(currentChainId);
            await loadMarkets(1, 50);
        } else {
            await checkMarketUpdate();
        }
        await populateOffers();
    }

    myContactInfo.addEventListener('blur', async function(event) {
        await saveContactInfo(document.getElementById("myContactInfo").value);
    });

    function backupLocalStorage() {
      const localStorageData = JSON.stringify(localStorage);
      const blob = new Blob([localStorageData], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const anchor = document.createElement('a');
      anchor.href = url;
      anchor.download = window.prompt('Choose a file name for the backup:', 'localStorageBackup.json');
      anchor.click();
      URL.revokeObjectURL(url);
    }

    function loadLocalStorage() {
      const reader = new FileReader();
      reader.onload = function(event) {
        try {
          const fileData = JSON.parse(event.target.result);
          Object.keys(fileData).forEach(function(key) {
            localStorage.setItem(key, fileData[key]);
          });
          console.log('Local storage data overwritten with data from file.');
        } catch (error) {
          console.error('Error parsing file data:', error);
        }
      };
      reader.onerror = function(event) {
        console.error('Error loading file:', event.target.error);
      };
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';

      input.onchange = function(event) {
        const file = event.target.files[0];
        reader.readAsText(file);
      };
      // Trigger a click event on the input element to prompt the user to select a file
      input.click();
    }

    async function RefreshContracts() {
        if(myaccounts != '') {
            localStorage.setItem(myaccounts+":readmessages3", JSON.stringify({}));
            await populateOffers();
        }
    }

    async function saveContactInfo(text) {
        if(myaccounts != '') {
            localStorage.setItem(myaccounts+":contact", text);
        }
    }

    async function getContactInfo(account) {
        const cached = localStorage.getItem(account+":contact");
        if (cached) {
            return cached;
        } else {
            return '';
        }
    }

    const selectAPI = document.getElementById('connectMethod');    

    selectAPI.addEventListener('blur', async function(event) {
      await saveAPI();
    });

    async function saveAPI() {
        const myCurrentChainId = DOMPurify.sanitize(await web3.eth.net.getId());
        localStorage.setItem(myaccounts+myCurrentChainId+":api", document.getElementById('connectMethod').value);
        await getUserAPI(myCurrentChainId);
    }

    async function getUserAPI(mychainid) {
        mylen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(myaccounts, 4).call());
        const mySelectElement = document.getElementById('connectMethod');

        mySelectElement.innerHTML = '';
        const option1 = document.createElement('option');
        option1.value = 'a';
        option1.text = 'Use default IPFS Pinata Gateway';
        mySelectElement.add(option1);

        // Add additional elements with values based on the size of mylen
        for (let i = 0; i < mylen; i++) {
          const option = document.createElement('option');
          option.value = i.toString();
          option.text = `Use gateway #${i}`;
          mySelectElement.add(option);
        }

        var selectedAPI = "6";
        const cached = localStorage.getItem(myaccounts+mychainid+":api");        
        if (cached) {
            const index = Array.from(mySelectElement.options).findIndex(option => option.value === cached.toString());
            mySelectElement.selectedIndex = index;
            selectedAPI = cached.toString();
            if (selectedAPI == 'a') {
                selectedAPI = "6";
            }
        }
        await getAPI(selectedAPI);
    }

    offerExpiration.addEventListener('change', async function(event) {
        await saveExpirationInfo(document.getElementById("offerExpiration").value);
    });

    async function saveExpirationInfo(text) {
        if(myaccounts != '') {
            localStorage.setItem(myaccounts+":expiration", text);
        }
    }

    async function getExpirationInfo(account) {
        const cached = localStorage.getItem(account+":expiration");
        if (cached) {
            return cached;
        } else {
            return '';
        }
    }

    const autoClearCheckbox = document.getElementById("clearCompleted");

    autoClearCheckbox.addEventListener("change", () => {
      localStorage.setItem(myaccounts + ":autoclear", autoClearCheckbox.checked);
    });

    function loadAutoClearState() {
      const autoClearState = localStorage.getItem(myaccounts + ":autoclear");
      if (autoClearState === "true") {
        autoClearCheckbox.checked = true;
      } else {
        autoClearCheckbox.checked = false;
      }
    }

    async function registerEmail(myemail) {
        if (myemail && myemail !== "") {
            try {
                await DDEcontract.methods.adduserdata(myemail).send({"from":myaccounts,"gasLimit": 3000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
                await Swal.fire("Data added!");
              } catch (error) {
                console.error(error);
            }
        }
    }

    async function postOfferData(text) {
        // Hash the text using web3 keccak
        const hash = web3.utils.keccak256(text);

        // Check if the hash is already stored in localStorage
        const cached = await getFile(hash);
        if (!Array.isArray(cached)) {
            return JSON.parse(cached).ipfsHash;
        }

        // If not, pin the text to Pinata IPFS and get the IPFS hash
        const ipfsHash = await pinToPinataIPFS(text);
        console.log("Offer posted to IPFS");
        console.log(ipfsHash);
        if(ipfsHash == "error") {
            return "error";
        }

        // Store the hashed text and IPFS hash in localStorage
        const data = JSON.stringify({ text: text, ipfsHash: ipfsHash });
        await storeFile(hash, data);
        await storeFile(ipfsHash, hash);

        return ipfsHash;
    }

    async function getOfferData(hash) {
        // Check if the hash is an IPFS hash or a text hash
        let ipfsHash = hash;
        var cached = '';
        var text = '';
        if (hash.length !== 46) { // IPFS hashes are 46 characters long
            // Look up the hash in localStorage
            cached = await getFile(hash);
            if (!Array.isArray(cached)) {
                text = JSON.parse(cached).text;
                return text;
            }
        } else {
            cached = await getFile(hash);
            if (!Array.isArray(cached)) {
                cached = await getFile(cached);
                if (!Array.isArray(cached)) {
                    text = JSON.parse(cached).text;
                    try {
                        const mytest = JSON.parse(text);
                        return text;
                    } catch {
                        console.log("Fetching data")
                    }                    
                }
            }
        }
        // Get the text from Pinata IPFS using the IPFS hash
        text = await retrieveFromPinataIPFS(ipfsHash);
        if(text == "error") {
            return "error";
        }

        // Hash the text using web3 keccak and check if it matches the stored text hash
        hash = web3.utils.keccak256(text);
        // Store the hashed text and IPFS hash in localStorage
        const data = JSON.stringify({ text: text, ipfsHash: ipfsHash });
        await storeFile(hash, data);
        await storeFile(ipfsHash, hash);
        return text;
    }

    var pinataApiKey = '';    
    var pinataSecretApiKey = '';
    var pinataGateway = 'https://azure-faithful-anteater-219.mypinata.cloud/ipfs/';
    var pinataToken = 'vgbqHzLAN_A5OI0suZED_RyzKacw5SfNjq25y45oB_CMVoOa1T4IfNrDJOkGysCP';
    // Function to post a file to Pinata IPFS
    async function pinToPinataIPFS (text) {
        const url = 'https://api.pinata.cloud/pinning/pinFILEToIPFS';

        const formData = new FormData();
        const blob = new Blob([text], { type: 'text/plain' });
        formData.append('file', blob, 'file.txt');
        try {
            const response = await axios.post(url, formData, {
                headers: {
                    'Content-Type': `multipart/form-data; boundary=${formData._boundary}`,
                    'pinata_api_key': pinataApiKey,
                    'pinata_secret_api_key': pinataSecretApiKey
                }
            });
            console.log(response.data.IpfsHash);
            return DOMPurify.sanitize(response.data.IpfsHash);
        } catch (error) {
            console.log(error);
            return 'error';
        }
    };

    // Function to retrieve a file from Pinata IPFS
    const retrieveFromPinataIPFS = async (hash) => {        
        var url = pinataGateway + hash;
        if(pinataGateway != "https://gateway.pinata.cloud/ipfs/") {
            if(pinataToken == '') {
                url = "https://gateway.pinata.cloud/ipfs/" + hash;
            } else {
                url += "?pinataGatewayToken=" + pinataToken;
            }
        }
        const response = await fetch(url);
        var result = await response.text();
        result = DOMPurify.sanitize(result);
        return result;
    };

    async function checkMarketUpdate() {
      const ONE_HOUR_IN_MS = 900000; // 15 minutes in milliseconds
      const lastTimestamp = localStorage.getItem('lastTimestamp');
      var marketsLength = 0;
      await DDEcontract.methods.marketslength().call().then(async function (result) {
        marketsLength = DOMPurify.sanitize(result);
      });
      const currentTimestamp2 = new Date().getTime();

      if (!lastTimestamp) {
        localStorage.setItem('lastTimestamp', currentTimestamp2.toString());
      } else if (currentTimestamp2 - lastTimestamp >= ONE_HOUR_IN_MS) {
        localStorage.setItem('lastTimestamp', currentTimestamp2.toString());
        await loadMarkets(1, 50);
        currentMarketsLength = marketsLength;
        return;
      }

      if (parseInt(currentMarketsLength) !== parseInt(marketsLength)) {
        await loadMarkets(1, 50);
      }
    }    
    //Currently everything is loaded at once with a basic search. There is the option to post key words to the chain
    //although this could get expensive depending on the blockchain. Costs can be reduced by using a p2p search index.
    //Searches check different key words and then they can further check each listing for it's relevant key words.
    //When the markets get larger, searches can be randomized to vary what orders are shown.
    //AI such as WebGPT can be used for content filtration with settings tweaked by the user ideally. If the user doesn't have
    //the graphics card to moderate, they can call a list of volunteer services who run AI WebGPT to filter it(and maybe recommend tags)
    //for them based on their criteria. One way to enforce a search protocol is have those who post to markets do so from a separate contract.
    //This way they can also be the ones required to remove the search tags and the contract manages everything.
    async function loadMarkets(low = 1, high = 1, searchText = '') {        
        var DDEcontract3 = DDEcontract;
        if(DDEcontract == '') {
            DDEcontract3 = DDEcontract2;
        }
        var mlength = 1;
        await DDEcontract3.methods.marketslength().call().then(async function (result) {
            currentMarketsLength = DOMPurify.sanitize(result);
            mlength = result;
        });
        var index = 1;
        if(high > 1 && low != 0 && high <= mlength && low <= high) {
            index = low;
            mlength = high;
        }
        var jsondata = {};
        var sortHits = 0;
        marketOffers['results'] = [];
        if (searchText !== '') {
            sortHits = 1;
            const keywords = searchText.split(/[,\s]+/); // Split by commas and one or more whitespace characters            
            await Promise.all(keywords.map(async keyword => {
                // Perform operations on each keyword
                if (keyword.length === 0) {
                    return; // Skip further execution for empty keyword
                }
                let keywordIndex = 0; // Declare a separate index for each keyword iteration
                let keywordLength = 0;
                await DDEcontract3.methods.taglength(keyword.toLowerCase()).call().then(async function (result) {
                    keywordIndex = 0;
                    keywordLength = parseInt(DOMPurify.sanitize(result));
                    if(high > 1 && low >= 0 && high <= keywordLength && low <= high) {
                        keywordIndex = low;
                        keywordLength = high;
                    }
                    for (keywordIndex; keywordIndex < keywordLength; keywordIndex++) {
                        try {
                            await DDEcontract3.methods.hashtag(keyword.toLowerCase(), keywordIndex).call().then(async function (hash) {
                                hash = DOMPurify.sanitize(hash);
                                if(hash == "0x0000000000000000000000000000000000000000000000000000000000000000") {
                                    return;
                                }
                                if(hash in marketOffers) {
                                    if (!marketOffers[hash]['searchTerms'].includes(keyword.toLowerCase())) {
                                        marketOffers[hash]['searchTerms'].push(keyword.toLowerCase())
                                    }
                                    jsondata = marketOffers[hash];
                                } else {
                                    jsondata = await getOrderHash(hash);
                                    if(parseInt(jsondata.timelimit[1]) != 0) {
                                        if(parseInt(jsondata.timelimit[1]) > parseInt(CurrentTimeStamp)) {
                                            marketOffers[hash] = jsondata;
                                        }
                                    }
                                }
                                if(!marketOffers['results'].includes(hash)) {
                                    marketOffers.results.push(hash);
                                }
                            });                            
                            await populateListings("", 1);
                        } catch (e) {
                            console.log("Error loading offer: ",e);
                        }
                    }
                });
            }));            
        } else {
            var searchThis = [];
            for (index; index < mlength; index++) {
                searchThis = [];
                try {
                    await DDEcontract3.methods.markets(index).call().then(async function (hash) {
                        hash = DOMPurify.sanitize(hash);
                        jsondata = await getOrderHash(hash);
                        if(!marketOffers.hasOwnProperty(index)) {
                            marketOffers.indices.push(index);
                        }
                        if(parseInt(jsondata.timelimit[1]) != 0) {
                            if(parseInt(jsondata.timelimit[1]) > parseInt(CurrentTimeStamp)) {
                                marketOffers[index] = hash;
                                if(hash in marketOffers) {
                                    searchThis = marketOffers[hash]['searchTerms'];
                                }
                                marketOffers[hash] = jsondata;
                                marketOffers[hash]['searchTerms'] = searchThis;
                            }
                        } else {
                            marketOffers[index] = hash;
                            if(hash in marketOffers) {
                                searchThis = marketOffers[hash]['searchTerms'];
                            }
                            marketOffers[hash] = jsondata;
                            marketOffers[hash]['searchTerms'] = searchThis;
                        }
                        if(!marketOffers['results'].includes(hash)) {
                            marketOffers.results.push(hash);
                        }
                    });
                    await populateListings();
                } catch (e) {
                    console.log("Error loading offer: ",e);
                }
            }
        }
        if(DDEcontract == '') {
            await populateListings("", sortHits);
        }
    }

    function sortByHits() {
      marketOffers['results'].sort((hashA, hashB) => {
        const hitsA = marketOffers[hashA]['searchTerms'].length;
        const hitsB = marketOffers[hashB]['searchTerms'].length;
        return hitsB - hitsA; // Sort in descending order based on the number of hits
      });
    }
    function sortByAmountHigh() {
      marketOffers['results'].sort((hashA, hashB) => {
        const amountA = marketOffers[hashA]['amount'];
        const amountB = marketOffers[hashB]['amount'];
        return amountB - amountA; // Sort in descending order based on the 'amount' key
      });
    }
    function sortByAmountLow() {
      marketOffers['results'].sort((hashA, hashB) => {
        const amountA = marketOffers[hashA]['amount'];
        const amountB = marketOffers[hashB]['amount'];
        return amountA - amountB; // Sort in ascending order based on the 'amount' key
      });
    }

    async function getOrderHash(hash) {
        var jsondata = {};
        var DDEcontract3 = DDEcontract;
        if(DDEcontract == '') {
            DDEcontract3 = DDEcontract2;
        }
        await DDEcontract3.methods.getContract(DOMPurify.sanitize(hash)).call().then(async function (data) {
          var text = '';
          try {
            text = await getOfferData(DOMPurify.sanitize(data.message));
          } catch (e) {
            console.log(e);
          }
          jsondata = {
            sender: DOMPurify.sanitize(data.sender),
            recipient: DOMPurify.sanitize(data.recipient),
            token: DOMPurify.sanitize(data.token),
            amount: DOMPurify.sanitize(data.amount),
            depositSender: DOMPurify.sanitize(data.depositSender),
            depositRecipient: DOMPurify.sanitize(data.depositRecipient),
            quantity: DOMPurify.sanitize(data.quantity),
            timelimit: [
              DOMPurify.sanitize(data.timelimit[0]),
              DOMPurify.sanitize(data.timelimit[1]),
              DOMPurify.sanitize(data.timelimit[2]),
            ],
            status: [
              DOMPurify.sanitize(data.status[0]),
              DOMPurify.sanitize(data.status[1]),
            ],
            message:DOMPurify.sanitize(text)
          };
          if(text != '') {
              try {
                  var messageData = JSON.parse(jsondata.message);
                  var myimg = Array.isArray(messageData.image) ? messageData.image : [''];
                  storeFile(Crypto.SHA256(JSON.stringify(myimg)), myimg);
                  jsondata.image = Crypto.SHA256(JSON.stringify(myimg));
                  jsondata.message = messageData.message;
                  jsondata.contact = messageData.contact;
              } catch (e) {
                  console.log("Error loading data");
                  jsondata.image = [''];
                  jsondata.message = '';
                  jsondata.contact = '';
              }
          } else {
              jsondata.image = [''];
              jsondata.message = '';
          }
          jsondata.hash = hash;
        });
        return jsondata;
    }

    async function populateOffers() {
      var list = document.createElement("ul");
      var readMessages = JSON.parse(localStorage.getItem(myaccounts+":readmessages")) || {};
      var notifications = JSON.parse(localStorage.getItem(myaccounts+":notifications")) || {};
      var mylen = 0;
      var notify = 0;
      var myhash = '';
      try {
        mylen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(myaccounts, 0).call());
      } catch(error) {
        console.log(error);
      }
      for (var i = 0; i < mylen; i++) {
        if (readMessages[i]) {
          continue;
        }
        try {          
          const offerHash = DOMPurify.sanitize(await DDEcontract.methods.openOffers(myaccounts, i).call());
          const offerID = DOMPurify.sanitize(await DDEcontract.methods.userMarketID(offerHash).call());
          if (offerID == 0) {
            readMessages[i] = true;
            localStorage.setItem(myaccounts+":readmessages", JSON.stringify(readMessages));
            continue;
          }
          const offerData = await getOrderHash(offerHash);
          if(parseInt(offerData.timelimit[1]) != 0) {
            if(parseInt(offerData.timelimit[1]) <= parseInt(CurrentTimeStamp)) {
              if(offerData.sender != "0x0000000000000000000000000000000000000000" && offerData.recipient != "0x0000000000000000000000000000000000000000") {
                readMessages[i] = true;
                localStorage.setItem(myaccounts+":readmessages", JSON.stringify(readMessages));
                continue;
              }
            }
          }
          const li = document.createElement("listElement");
          const counterpartyAddress = offerData.sender === myaccounts ? offerData.recipient : offerData.sender;
          const counterpartyLabel = counterpartyAddress === "0x0000000000000000000000000000000000000000" ? "Market Offer" : counterpartyAddress;
          const svgString = jdenticon.toSvg(offerHash, 25);
          const base64String = btoa(svgString);
          const dataUrl = `data:image/svg+xml;base64,${base64String}`;
          li.innerHTML = `
            <div>Order hash: <img src="${dataUrl}" width="25" height="25"></img> ${offerHash}</div>
            <div>Counter-Party Address: ${counterpartyLabel}</div>
            <div>Token: ${offerData.token}</div>
            <div>Amount: ${displayDecimals(offerData.token, offerData.amount)}</div>
            <div>Quantity: ${offerData.quantity}</div>
            <div>Time Limit: ${parseInt(offerData.timelimit[0]) / (60 * 60 * 24 * 7)} weeks</div>
            <div>Message: ${offerData.message.slice(0, 20)}...</div><br>
          `;
          myhash = web3.utils.keccak256(li.innerHTML);
          if(offerHash in notifications) {
            if(notifications[offerHash] != myhash) {
                notifications[offerHash] = myhash;
                notify = 1;
            }
          } else {
            notifications[offerHash] = myhash;
            notify = 1;
          }
          li.onclick = function() {
            document.getElementById("offersButton").style.backgroundColor = "transparent";
            showListing(offerData, 1);
          };
          list.appendChild(li);
        } catch (error) {
          break;
        }
      }
      if(notify == 1) {
        document.getElementById("offersButton").style.backgroundColor = "silver";
      }
      localStorage.setItem(myaccounts+":notifications", JSON.stringify(notifications));
      notify = 0;
      notifications = JSON.parse(localStorage.getItem(myaccounts+":notifications2")) || {};
      var list2 = document.createElement("ul");
      readMessages = JSON.parse(localStorage.getItem(myaccounts+":readmessages2")) || {};
      try {
        mylen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(myaccounts, 1).call());
      } catch(error) {
        console.log(error);
      }
      for (i = 0; i < mylen; i++) {
        if (readMessages[i]) {
          continue;
        }
        try {
          const offerHash2 = DOMPurify.sanitize(await DDEcontract.methods.privateOffers(myaccounts, i).call());
          const offerData2 = await getOrderHash(offerHash2);
          if (offerData2.status[0] > 0 && offerData2.status[1] > 0) {
            readMessages[i] = true;
            localStorage.setItem(myaccounts+":readmessages2", JSON.stringify(readMessages));
            continue;
          }
          if(parseInt(offerData2.timelimit[1]) != 0) {
            if(parseInt(offerData2.timelimit[1]) <= parseInt(CurrentTimeStamp)) {
              readMessages[i] = true;
              localStorage.setItem(myaccounts+":readmessages2", JSON.stringify(readMessages));
              continue;
            }
          }
          const li2 = document.createElement("listElement");
          const counterpartyAddress2 = offerData2.sender === myaccounts ? offerData2.recipient : offerData2.sender;
          const counterpartyLabel2 = counterpartyAddress2;
          const svgString2 = jdenticon.toSvg(offerHash2, 25);
          const base64String2 = btoa(svgString2);
          const dataUrl2 = `data:image/svg+xml;base64,${base64String2}`;
          li2.innerHTML = `
            <div>Order hash: <img src="${dataUrl2}" width="25" height="25"></img> ${offerHash2}</div>
            <div>Counter-Party Address: ${counterpartyLabel2}</div>
            <div>Token: ${offerData2.token}</div>
            <div>Amount: ${displayDecimals(offerData2.token, offerData2.amount)}</div>
            <div>Quantity: ${offerData2.quantity}</div>
            <div>Time Limit: ${parseInt(offerData2.timelimit[0]) / (60 * 60 * 24 * 7)} weeks</div>
            <div>Message: ${offerData2.message.slice(0, 20)}...</div><br>
          `;          
          myhash = web3.utils.keccak256(li2.innerHTML);
          if(offerHash2 in notifications) {
            if(notifications[offerHash2] != myhash) {
                notifications[offerHash2] = myhash;
                notify = 1;
            }
          } else {
            notifications[offerHash2] = myhash;
            notify = 1;
          }
          offerData2.index = i;
          if(myaccounts == offerData2.sender && offerData2.status[0] == 1) {
            li2.onclick = function() {
              document.getElementById("offersButton").style.backgroundColor = "transparent";
              showListing(offerData2, 1);
            };
            list.appendChild(li2);
          }
          if(myaccounts == offerData2.sender && offerData2.status[0] == 0) {
            li2.onclick = function() {
              document.getElementById("offersButton").style.backgroundColor = "transparent";
              showListing(offerData2, 2);
            };
            list2.appendChild(li2);
          }
          if(myaccounts == offerData2.recipient && offerData2.status[1] == 1) {
            li2.onclick = function() {
              document.getElementById("offersButton").style.backgroundColor = "transparent";
              showListing(offerData2, 1);
            };
            list.appendChild(li2);
          }
          if(myaccounts == offerData2.recipient && offerData2.status[1] == 0) {
            li2.onclick = function() {
              document.getElementById("offersButton").style.backgroundColor = "transparent";
              showListing(offerData2, 2);
            };
            list2.appendChild(li2);
          }
        } catch (error) {
          break;
        }
      }
      if(notify == 1) {
        document.getElementById("offersButton").style.backgroundColor = "silver";
      }
      localStorage.setItem(myaccounts+":notifications2", JSON.stringify(notifications));
      notify = 0;
      notifications = JSON.parse(localStorage.getItem(myaccounts+":notifications3")) || {};
      const offersContainer = document.getElementById("myoffers");
      offersContainer.innerHTML = ""; // clear the container first
      offersContainer.classList.add("offers-container");

      const sentOffersHeader = document.createElement("div");
      sentOffersHeader.classList.add("offers-header");
      sentOffersHeader.textContent = "Sent Offers";
      //offersContainer.appendChild(sentOffersHeader);
      list.setAttribute("style", "border: 1px solid black; padding: 1rem; margin-bottom: 1rem; cursor: pointer; background-color: #f8f8f8;");
      //offersContainer.appendChild(list);

      const receivedOffersHeader = document.createElement("div");
      receivedOffersHeader.classList.add("offers-header");
      receivedOffersHeader.textContent = "Received Offers";
      //offersContainer.appendChild(receivedOffersHeader);
      list2.setAttribute("style", "border: 1px solid black; padding: 1rem; margin-bottom: 1rem; cursor: pointer; background-color: #f8f8f8;");
      //offersContainer.appendChild(list2);

      const sentContainer = document.createElement("div");
      sentContainer.id = "senttab";
      sentContainer.classList.add("tabcontent");
      sentContainer.appendChild(sentOffersHeader);
      sentContainer.appendChild(list);

      const receivedContainer = document.createElement("div");
      receivedContainer.id = "receivedtab";
      receivedContainer.classList.add("tabcontent");
      receivedContainer.appendChild(receivedOffersHeader);
      receivedContainer.appendChild(list2);

      const tabContainer = document.createElement("div");
      tabContainer.innerHTML = `
        <div class="offers-tab-container">
          <button class="tablinks" onclick="openTab(event, 'senttab')">Sent Offers</button>
          <button class="tablinks" onclick="openTab(event, 'receivedtab')">Received Offers</button>
          <br><br>
        </div>
      `;
      tabContainer.appendChild(sentContainer);
      tabContainer.appendChild(receivedContainer);
      offersContainer.appendChild(tabContainer);

      var list3 = document.createElement("ul");
      readMessages = JSON.parse(localStorage.getItem(myaccounts+":readmessages3")) || {};
      try {
        mylen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(myaccounts, 2).call());
      } catch(error) {
        console.log(error);
      }
      for (i = 0; i < mylen; i++) {
        if (readMessages[i]) {
          continue;
        }
        try {
          const offerHash3 = DOMPurify.sanitize(await DDEcontract.methods.escrows(myaccounts, i).call());
          const offerData3 = await getOrderHash(offerHash3);
          if (offerData3.status[0] == 4 || offerData3.status[1] == 4) {
            if (autoClearCheckbox.checked) {
                readMessages[i] = true;
                localStorage.setItem(myaccounts+":readmessages3", JSON.stringify(readMessages));
                continue;
            }
          }
          const li3 = document.createElement("listElement");
          const counterpartyAddress3 = offerData3.sender === myaccounts ? offerData3.recipient : offerData3.sender;
          const counterpartyLabel3 = counterpartyAddress3;
          const svgString3 = jdenticon.toSvg(offerHash3, 25);
          const base64String3 = btoa(svgString3);
          const dataUrl3 = `data:image/svg+xml;base64,${base64String3}`;

          const currentBlockNumber = await web3.eth.getBlockNumber();
          const currentBlock = await web3.eth.getBlock(currentBlockNumber);
          const blockTimestamp = DOMPurify.sanitize(currentBlock.timestamp);
          const timeRemaining = (parseFloat(parseInt(offerData3.timelimit[0]) - parseInt(blockTimestamp)) / parseFloat(60 * 60 * 24)).toFixed(2);

          li3.innerHTML = `
            <div>Order hash: <img src="${dataUrl3}" width="25" height="25"></img> ${offerHash3}</div>
            <div>Counter-Party Address: ${counterpartyLabel3}</div>
            <div>Token: ${offerData3.token}</div>
            <div>Amount: ${displayDecimals(offerData3.token, offerData3.amount)}</div>
            <div>Quantity: ${offerData3.quantity}</div>
            <div>Time Until Funds Expire: ${timeRemaining} days</div>            
          `;
          offerData3.timeRemaining = timeRemaining;
          var escrowInfo = '';
          if (offerData3.status[0] != 4 && offerData3.status[1] != 4) {
              if(parseFloat(timeRemaining) < parseFloat(2)) {
                escrowInfo += `<div>WARNING: Funds are about to expire. Resolve the escrow with your counter-party or all funds risk being burned.</div>`
              }
              if(parseFloat(timeRemaining) <= parseFloat(0)) {
                escrowInfo += `<div>The time limit has expired and the funds have been burned. This contract is no longer available.</div>`
                offerData3.expired = 1;
              }
          }
          var skipthis = 0;
          if(offerData3.timelimit[0] == offerData3.timelimit[1] && offerData3.timelimit[1] == offerData3.timelimit[2]) {
            skipthis = 1;
          }
          if(offerData3.timelimit[1] != 0 && skipthis != 1) {            
            const timeExtension = Math.abs(parseFloat(parseInt(offerData3.timelimit[1]) - parseInt(offerData3.timelimit[0])) / parseFloat(60 * 60 * 24)).toFixed(2);
            escrowInfo += `<div>Sender has requested a time extention for: ${timeExtension} days</div>`;
          }
          if(offerData3.timelimit[2] != 0 && skipthis != 1) {            
            const timeExtension2 = Math.abs(parseFloat(parseInt(offerData3.timelimit[2]) - parseInt(offerData3.timelimit[0])) / parseFloat(60 * 60 * 24)).toFixed(2);
            escrowInfo += `<div>Recipient has requested a time extention for: ${timeExtension2} days</div>`;
          }
          if (skipthis == 1) {
            escrowInfo += `<div>Time extension granted.</div>`;
          }
          if (offerData3.status[0] == 2) {
            if(myaccounts == offerData3.sender) {
                escrowInfo += `<div>Completion request sent!</div>`;
            } else {
                escrowInfo += `<div>Completion request received!</div>`;
            }
          }
          if (offerData3.status[0] == 3) {
            if(myaccounts == offerData3.sender) {
                escrowInfo += `<div>Completion request received!</div>`;
            } else {
                escrowInfo += `<div>Completion request sent!</div>`;
            }
          }
          if (offerData3.status[1] == 2) {
            if(myaccounts == offerData3.sender) {
                escrowInfo += `<div>Cancellation request sent!</div>`;
            } else {
                escrowInfo += `<div>Cancellation request received!</div>`;
            }
          }
          if (offerData3.status[1] == 3) {
            if(myaccounts == offerData3.sender) {
                escrowInfo += `<div>Cancellation request received!</div>`;
            } else {
                escrowInfo += `<div>Cancellation request sent!</div>`;
            }
          }
          if (offerData3.status[0] == 4 || offerData3.status[1] == 4) {
            if(offerData3.status[0] == 4) {
                escrowInfo += `<div>Contract completed!</div>`;
            }
            if(offerData3.status[1] == 4) {
                escrowInfo += `<div>Contract cancelled!</div>`;
            }
            offerData3.expired = 1;
          }
          offerData3.escrowInfo = escrowInfo;
          li3.innerHTML += escrowInfo;
          li3.innerHTML += `<div>Message: ${offerData3.message.slice(0, 20)}...</div><br>`
          const lineToExcludeRegex = /<div>Time Until Funds Expire: .* days<\/div>/;
          const inputString = li3.innerHTML.replace(lineToExcludeRegex, '');
          myhash = web3.utils.keccak256(inputString);
          if(offerHash3 in notifications) {
            if(notifications[offerHash3] != myhash) {
                notifications[offerHash3] = myhash;
                notify = 1;
            }
          } else {
            notifications[offerHash3] = myhash;
            notify = 1;
          }
          offerData3.index = i;          
          li3.onclick = function() {
            document.getElementById("contractsButton").style.backgroundColor = "transparent";
            showListing(offerData3, 4);
          };
          list3.appendChild(li3);          
        } catch (error) {
          console.log(error)
          break;
        }
      }
      if(notify == 1) {
        document.getElementById("contractsButton").style.backgroundColor = "silver";
      }
      localStorage.setItem(myaccounts+":notifications3", JSON.stringify(notifications));
      const escrowContainer = document.getElementById("mycontracts");
      escrowContainer.innerHTML = ""; // clear the container first
      escrowContainer.classList.add("escrow-container");

      const escrowOffersHeader = document.createElement("div");
      escrowOffersHeader.classList.add("escrow-header");
      escrowOffersHeader.textContent = "Sent Offers";
      escrowContainer.appendChild(escrowOffersHeader);
      list3.setAttribute("style", "border: 1px solid black; padding: 1rem; margin-bottom: 1rem; cursor: pointer; background-color: #f8f8f8;");
      escrowContainer.appendChild(list3);
    }
    function openTab(evt, tabName) {
      // Declare all variables
      let i, tabcontent, tablinks;
      // Get all elements with class="tabcontent" and hide them
      tabcontent = document.getElementsByClassName("tabcontent");
      for (i = 0; i < tabcontent.length; i++) {
        tabcontent[i].style.display = "none";
      }
      // Get all elements with class="tablinks" and remove the class "active"
      tablinks = document.getElementsByClassName("tablinks");
      for (i = 0; i < tablinks.length; i++) {
        tablinks[i].classList.remove("active");
      }
      // Show the current tab, and add an "active" class to the button that opened the tab
      document.getElementById(tabName).style.display = "block";
      evt.currentTarget.classList.add("active");
    }

    function showMain(menu) {
        // hide all main divs
        var mains = document.querySelectorAll('.main');
        for (var i = 0; i < mains.length; i++) {
            mains[i].classList.remove('show');
        }

        // show the main div for the selected menu
        var main = document.querySelector('.main.' + menu);
        main.classList.add('show');
    }
    //**************MARKETS TAB//**************
    // global variables for pagination
    var currentPage = 1;
    var listingsPerPage = 10;

    async function populateListings(searchText = "", sortHits = 0) {
        if(sortHits == 1) {
            sortByHits();
        } else {
            var sortBy = document.getElementById("SortBy").value;
            if(sortBy == "price-low") {
                sortByAmountLow();
            }
            if(sortBy == "price-high") {
                sortByAmountHigh();
            } 
        }
        var listingsDiv = document.querySelector('.main.markets .listings');
        listingsDiv.innerHTML = '';

        var startIndex = (currentPage - 1) * listingsPerPage;
        var endIndex = startIndex + listingsPerPage;
        if (endIndex > marketOffers.indices.length) {
            endIndex = marketOffers.indices.length;
        }
        searchText = searchText.toLowerCase();
        if (searchText !== "") {
            endIndex = marketOffers.indices.length;
        }
        var shown = 0;
        var offer;
        var myhashes = {};

        var gridContainer = document.createElement('div');
        gridContainer.classList.add('listings-grid');

        for (var i = startIndex; i < endIndex; i++) {
            if (shown == listingsPerPage) {
                break;
            }
            if (!marketOffers.hasOwnProperty(marketOffers.indices[i])) {
                continue;
            }
            if (parseInt(marketOffers.indices[i]) >= parseInt(currentMarketsLength)) {
                continue;
            }
            if (searchText !== "") {
                if (i < marketOffers.results.length) {
                    offer = marketOffers[marketOffers.results[i]];
                } else {
                    offer = marketOffers[marketOffers[marketOffers.indices[i]]];
                }
                const keywords = searchText.split(/[,\s]+/);
                let foundKeyword = false;

                for (const keyword of keywords) {
                    if (keyword.length === 0) {
                        continue;
                    }
                    if (offer.message.toLowerCase().includes(keyword.toLowerCase())) {
                        foundKeyword = true;
                        break;
                    }
                    if (offer['searchTerms'].includes(keyword.toLowerCase())) {
                        foundKeyword = true;
                        break;
                    }
                }
                if (!foundKeyword) {
                    continue;
                }
            } else {
                if(marketOffers.results.length > 0) {
                    if (i < marketOffers.results.length) {
                        offer = marketOffers[marketOffers.results[i]];
                    } else {
                        offer = marketOffers[marketOffers[marketOffers.indices[i]]];
                    }
                } else {
                    offer = marketOffers[marketOffers[marketOffers.indices[i]]];
                }
            }
            if (offer.hash in myhashes) {
                continue;
            } else {
                myhashes[offer.hash] = 1;
            }

            var gridItem = document.createElement('div');
            gridItem.classList.add('listing-grid-item');
            var tempimg = '';
            var myimg = await getFile(offer.image);
            if (myimg.length > 0 && myimg != '' && myimg[0] != '') {
                tempimg = '<img src="' + myimg[0] + '" alt="./blank-image.jpg">';
            } else {
                tempimg = '<img src="./blank-image.jpg" alt="">';
            }
            gridItem.innerHTML = `
                <div class="listing-image">${tempimg}</div>
                <div class="listing-details">
                    <div class="token">Currency: ${tokennames[offer.token]}</div>
                    <div class="amount">Amount: ${displayDecimals(offer.token, offer.amount)}</div>
                    <div class="message">Details: ${offer.message.slice(0, 20) + (offer.message.length > 20 ? "..." : "")}</div>
                </div>
            `;

            // create a closure to bind the offer variable to the onclick function
            (function (offer) {
                gridItem.onclick = function () {
                    showListing(offer);
                };
            })(offer);

            gridContainer.appendChild(gridItem);
            shown++;
        }

        listingsDiv.appendChild(gridContainer);

        // Inject CSS styles into a style tag
        var style = document.createElement('style');
        style.textContent = `
            .listings-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(210px, 1fr));
                grid-gap: 20px;
            }

            .listing-grid-item {
                border: 1px solid #ccc;
                padding: 10px;
                text-align: center;
            }

            .listing-image img {
                max-width: 200px;
                height: auto;
            }
        `;
        document.head.appendChild(style);
    }

    function displayDecimals(token, amount) {
        var text = '';
        for (var i = 0; i < tokens.length; i++) {
            if(tokens[i].address == token) {
                text = parseFloat(amount / (10 ** tokens[i].decimals));
                break;
            }
        }
        return text
    }

    // function for searching the listings
    async function searchListings(searchText, deep=0) {
        // filter the marketOffers array based on the searchText
        // and update the currentPage to 1
        currentPage = 1;
        if(deep == 1) {
            document.getElementById("loadingStatus").innerHTML = "Loading..."
            await loadMarkets(0, 50, searchText);
            document.getElementById("loadingStatus").innerHTML = ""
        }
        await populateListings(searchText);
    }

    // function for showing the next page of listings
    async function nextPage() {
        if (currentPage < Math.ceil(marketOffers.indices.length / listingsPerPage)) {
            currentPage++;
            await populateListings();
        } else {
            document.getElementById("loadingStatus").innerHTML = "Loading..."
            await loadMarkets(marketOffers.indices.length, marketOffers.indices.length + 50);
            document.getElementById("loadingStatus").innerHTML = ""
            currentPage++;
            await populateListings();
        }
    }

    // function for showing the previous page of listings
    async function previousPage() {
        if (currentPage > 1) {
            currentPage--;
            await populateListings();
        }
    }
    populateListings();

    // Function to show the details popup for a listing
    async function showListing(listing, mode=0) {
      const popupContainer = document.createElement('div');
      popupContainer.classList.add('popup-container');

      const popup = document.createElement('div');
      popup.classList.add('popup');

      const closeButton = document.createElement('span');
      closeButton.innerHTML = '&times;';
      closeButton.classList.add('close-button');
      closeButton.onclick = function() { popupContainer.remove(); };

      const imageContainer = document.createElement('div');
      imageContainer.classList.add('image-container');
      const leftArrow = document.createElement('span');
      leftArrow.innerHTML = '&#10094;';
      leftArrow.classList.add('arrow', 'left-arrow');
      leftArrow.onclick = function() { plusSlides(-1); };
      const rightArrow = document.createElement('span');
      rightArrow.innerHTML = '&#10095;';
      rightArrow.classList.add('arrow', 'right-arrow');
      rightArrow.onclick = function() { plusSlides(1); };
      let slideIndex = 1;

      function plusSlides(n) {
        showSlides(slideIndex += n);
      }

      function showSlides(n) {
        const slides = document.getElementsByClassName('popup-image');
        if (n > slides.length) {
          slideIndex = 1;
        }
        if (n < 1) {
          slideIndex = slides.length;
        }
        for (let i = 0; i < slides.length; i++) {
          slides[i].style.display = 'none';
        }
        slides[slideIndex - 1].style.display = 'block';
      }
      const imageList = document.createElement('ul');
      const arrowsContainer = document.createElement('div');
      var myimgs = await getFile(listing.image);
      if(myimgs.length > 0) {          
          imageList.classList.add('image-list');
          imageList.style.listStyle = 'none'; // remove the dot
          imageList.onclick = function() { plusSlides(1); };
          for (let i = 0; i < myimgs.length; i++) {
            const li = document.createElement('li');
            const img = document.createElement('img');
            img.src = myimgs[i];
            img.classList.add('popup-image');
            li.appendChild(img);
            imageList.appendChild(li);
          }
          
          arrowsContainer.classList.add('arrows-container');
          arrowsContainer.style.position = 'relative';
          leftArrow.style.position = 'absolute';
          leftArrow.style.top = '50%';
          leftArrow.style.left = '0';
          leftArrow.style.transform = 'translateY(-50%)';

          rightArrow.style.position = 'absolute';
          rightArrow.style.top = '50%';
          rightArrow.style.right = '0';
          rightArrow.style.transform = 'translateY(-50%)';

          arrowsContainer.appendChild(leftArrow);
          arrowsContainer.appendChild(rightArrow);

          imageContainer.appendChild(imageList);
          imageContainer.appendChild(arrowsContainer);
      }
      const details = document.createElement('div');
      details.classList.add('popup-details');
      
      const sender = document.createElement('p');
      var text = "Sender: ";
      if(listing.sender == "0x0000000000000000000000000000000000000000") {
        if(myaccounts != listing.recipient) {
            text = "You are the one paying/sending the funds.";
        } else {
            text = "You are the one receiving the funds.";
        }
        sender.innerHTML = "<br>" + text;
      } else {
        sender.innerHTML = "<br>" + text + listing.sender;
      }

      const recipient = document.createElement('p');
      var text2 = "Recipient: ";
      if(listing.recipient == "0x0000000000000000000000000000000000000000") {
        if(myaccounts != listing.sender) {
            text2 = "You are the one receiving the funds.";            
        } else {
            text2 = "You are the one paying/sending the funds.";
        }
        recipient.innerHTML = text2;
      } else {
        recipient.innerHTML = text2 + listing.recipient;
      }

      const token = document.createElement('p');
      token.innerHTML = 'Token: ' + tokennames[listing.token];

      const amount = document.createElement('p');
      amount.innerHTML = 'Amount: ' + displayDecimals(listing.token,listing.amount);
      
      const depositSender = document.createElement('p');
      depositSender.innerHTML = 'Deposit Sender: ' + displayDecimals(listing.token,listing.depositSender);
      
      const depositRecipient = document.createElement('p');
      depositRecipient.innerHTML = 'Deposit Recipient: ' + displayDecimals(listing.token,listing.depositRecipient);
      
      const quantity = document.createElement('p');
      quantity.innerHTML = 'Quantity: ' + listing.quantity;
      
      const timelimit = document.createElement('p');
      timelimit.innerHTML = 'Time limit: ' + Math.floor(parseInt(listing.timelimit[0]) / (60 * 60 * 24 * 7)) + ' weeks';

      const message = document.createElement('p');
      message.innerHTML = '<br>Details: <br>' + listing.message;
      if (typeof listing.contact !== 'undefined') {
          message.innerHTML += '<br><br>Contact information: <br>' + listing.contact;
      }
      var contact2 = '';
      var datalen = 0;
      if(myaccounts != listing.recipient && listing.recipient != "0x0000000000000000000000000000000000000000" && DDEcontract != '') {
          try {
              datalen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(listing.recipient, 3).call());
              if(datalen > 0) {
                  contact2 = DOMPurify.sanitize(await DDEcontract.methods.userdata(listing.recipient, datalen-1).call());
                  if(listing.contact != contact2) {
                      message.innerHTML += '<br><br>Recipients contact information: <br>' + contact2;
                  }
              }
          } catch(e) {
              console.log(e);
          }
      }
      if(myaccounts != listing.sender && listing.sender != "0x0000000000000000000000000000000000000000" && DDEcontract != '') {
          try {
              datalen = DOMPurify.sanitize(await DDEcontract.methods.getArrayLength(listing.sender, 3).call());
              if(datalen > 0) {
                  contact2 = DOMPurify.sanitize(await DDEcontract.methods.userdata(listing.sender, datalen-1).call());
                  if(listing.contact != contact2) {
                      message.innerHTML += '<br><br>Senders contact information: <br>' + contact2;
                  }
              }
          } catch(e) {
              console.log(e);
          }
      }

      const buttonContainer = document.createElement('div');
      buttonContainer.classList.add('button-container');

      if(mode == 0 || mode == 2) {
          const acceptButton = document.createElement('button');
          acceptButton.innerHTML = 'Accept offer';
          acceptButton.onclick = () => acceptOffer(listing);

          const counterButton = document.createElement('button');
          counterButton.innerHTML = 'Counter-offer';
          counterButton.onclick = () => counterOffer(listing);

          buttonContainer.appendChild(acceptButton);
          buttonContainer.appendChild(counterButton);
      }
      if(mode == 1) {
          if(listing.sender == "0x0000000000000000000000000000000000000000" || listing.recipient == "0x0000000000000000000000000000000000000000" ) {
            const quantityButton = document.createElement('button');
            quantityButton.innerHTML = 'Update Quantity';
            quantityButton.onclick = () => updateQuantity(listing);
            buttonContainer.appendChild(quantityButton);
          }
          const cancelButton = document.createElement('button');
          cancelButton.innerHTML = 'Cancel offer';
          cancelButton.onclick = () => cancelOffer(listing);
          buttonContainer.appendChild(cancelButton);
      }
      if(mode == 2) {
          const cancelButton = document.createElement('button');
          cancelButton.innerHTML = 'Cancel offer';
          cancelButton.onclick = () => cancelOffer(listing, 1);
          buttonContainer.appendChild(cancelButton);
      }
      if(mode == 3) {
          imageContainer.style.display = 'none';
          arrowsContainer.style.display = 'none';
          const confirmButton = document.createElement('button');
          confirmButton.innerHTML = 'Confirm';
          confirmButton.id = 'confirmButton';
          buttonContainer.appendChild(confirmButton);
          const cancelButton = document.createElement('button');
          cancelButton.innerHTML = 'Cancel';
          cancelButton.id = 'cancelButton';
          buttonContainer.appendChild(cancelButton);
      }
      if(mode == 4) {
          if(listing.expired == 1) {
              const clearButton = document.createElement('button');
              clearButton.innerHTML = 'Clear Contract';
              clearButton.id = 'clearButton';
              buttonContainer.appendChild(clearButton);
              clearButton.onclick = async function() {
                const readMessages = JSON.parse(localStorage.getItem(myaccounts+":readmessages3")) || {};
                readMessages[listing.index] = true;
                localStorage.setItem(myaccounts+":readmessages3", JSON.stringify(readMessages));
                await loadUser();
                popupContainer.remove();
              };
          } else {
              var skipthis = 0;
              if(listing.timelimit[0] == listing.timelimit[1] && listing.timelimit[1] == listing.timelimit[2]) {
                skipthis = 1
              }
              if(listing.timelimit[1] != 0 && skipthis != 1) {
                if(myaccounts != listing.sender) {
                  const acceptTime = document.createElement('button');
                  acceptTime.innerHTML = 'Accept Time Extension Request';
                  acceptTime.id = 'acceptTime';                  
                  acceptTime.onclick = async function() {
                    try {
                      await DDEcontract.methods.requestExtension(listing.hash, listing.timelimit[1]).send({"from":myaccounts,"gasLimit": 1000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
                      await Swal.fire("Time extended!");
                      await loadUser();
                      popupContainer.remove();
                    } catch (error) {
                      console.error(error);
                    }
                  }
                  buttonContainer.appendChild(acceptTime);
                }
              }
              if(listing.timelimit[2] != 0 && skipthis != 1) {
                if(myaccounts == listing.sender) {
                  const acceptTime = document.createElement('button');
                  acceptTime.innerHTML = 'Accept Time Extension Request';
                  acceptTime.id = 'acceptTime';
                  acceptTime.onclick = async function() {
                    try {
                      await DDEcontract.methods.requestExtension(listing.hash, listing.timelimit[2]).send({"from":myaccounts,"gasLimit": 1000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
                      await Swal.fire("Time extended!");
                      await loadUser();
                      popupContainer.remove();
                    } catch (error) {
                      console.error(error);
                    }
                  }
                  buttonContainer.appendChild(acceptTime);
                }
              }
              const extendTime = document.createElement('button');
              extendTime.innerHTML = 'Request Time Extension';
              extendTime.id = 'extendTime';                  
              extendTime.onclick = async function() {
                  try {
                      const dialog = document.createElement("div");
                      dialog.innerHTML = `
                        <div>Please enter the number of days you wish to extend:<br></div>
                          <input id="new-time" type="number"></input><br><br>
                        <div>
                          <button id="confirm-btn">Confirm</button>&nbsp;&nbsp;
                          <button id="cancel-btn">Cancel</button>
                        </div>
                      `;
                      dialog.style.display = "block";
                      dialog.style.position = "fixed";
                      dialog.style.zIndex = 9999;
                      dialog.style.backgroundColor = "white";
                      dialog.style.padding = "20px";
                      dialog.style.borderRadius = "10px";
                      dialog.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.3)";
                      dialog.style.top = "50%";
                      dialog.style.left = "50%";
                      dialog.style.transform = "translate(-50%, -50%)";

                      document.body.appendChild(dialog);

                      const confirmBtn = dialog.querySelector("#confirm-btn");
                      const cancelBtn = dialog.querySelector("#cancel-btn");
                      cancelBtn.addEventListener("click", async () => {
                        dialog.remove();
                      });

                      confirmBtn.addEventListener("click", async () => {                        
                        const newtime = parseInt(listing.timelimit[0]) + parseInt(parseInt(dialog.querySelector("#new-time").value) * 24 * 60 * 60);
                        dialog.remove();
                        await DDEcontract.methods.requestExtension(listing.hash, newtime).send({"from":myaccounts,"gasLimit": 1000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
                        await Swal.fire("Time extension requested!");
                        await loadUser();
                        popupContainer.remove();
                      });
                  } catch (error) {
                    console.error(error);
                  }
              }              
              buttonContainer.appendChild(extendTime);
              const cancelButton = document.createElement('button');
              cancelButton.innerHTML = 'Cancel Contract';
              cancelButton.id = 'cancelButton';
              cancelButton.onclick = async function() {
                try {
                  if(myaccounts == listing.sender) {
                    if(listing.status[1] == 2) {
                      await Swal.fire("Contract cancellation request was already sent!");
                      return;
                    }
                  } else {
                    if(listing.status[1] == 3) {
                      await Swal.fire("Contract cancellation request was already sent!");
                      return;
                    }
                  }
                  await DDEcontract.methods.cancelEscrow(listing.hash).send({"from":myaccounts,"gasLimit": 1000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
                  if(listing.status[1] == 1) {
                    await Swal.fire("Contract cancellation request sent!");
                  } else {
                    await Swal.fire("Contract cancelled!");
                  }
                  await loadUser();
                  popupContainer.remove();
                } catch (error) {
                  console.error(error);
                }
              }
              buttonContainer.appendChild(cancelButton);
              const confirmButton = document.createElement('button');
              confirmButton.innerHTML = 'Complete Contract';
              confirmButton.id = 'confirmButton';
              confirmButton.onclick = async function() {
                try {
                  if(myaccounts == listing.sender) {
                    if(listing.status[0] == 2) {
                      await Swal.fire("Contract completion request was already sent!");
                      return;
                    }
                  } else {
                    if(listing.status[0] == 3) {
                      await Swal.fire("Contract completion request was already sent!");
                      return;
                    }
                  }
                  await DDEcontract.methods.completeEscrow(listing.hash).send({"from":myaccounts,"gasLimit": 1000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
                  if(listing.status[1] == 1) {
                    await Swal.fire("Contract completion request sent!");
                  } else {
                    await Swal.fire("Contract completed!");
                  }
                  await loadUser();
                  popupContainer.remove();
                } catch (error) {
                  console.error(error);
                }
              }
              buttonContainer.appendChild(confirmButton);
          }
      }

      details.appendChild(sender);
      details.appendChild(recipient);
      details.appendChild(token);
      details.appendChild(amount);

      details.appendChild(depositSender);
      details.appendChild(depositRecipient);
      details.appendChild(quantity);
      details.appendChild(timelimit);

      if(mode == 4) {
        timelimit.innerHTML = 'Time Until Funds Expire: ' + listing.timeRemaining + ' days';
        const extra = document.createElement('p');
        extra.innerHTML = '<br>Notifications: <br>' + listing.escrowInfo;
        details.appendChild(extra)
      }
      details.appendChild(message);

      popup.appendChild(closeButton);
      popup.appendChild(imageContainer);
      popup.appendChild(details);
      popup.appendChild(buttonContainer);
      popupContainer.appendChild(popup);

      document.body.appendChild(popupContainer);

      // Add CSS rules
      const style = document.createElement('style');
      style.type = 'text/css';
      style.innerHTML = `
        .popup-container {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.4);
          display: flex;
          justify-content: center;
          align-items: center;
        }

        .popup {
          position: relative;
          background-color: white;
          padding: 20px;
          max-width: 600px;
          max-height: 80%;
          overflow-y: auto;
        }

        .popup-image {
          display: block;
          margin: 0 auto;
          max-width: 200px;
          max-height: 200px;
          object-fit: contain;
          margin-bottom: 10px;
        }

        .popup-details p {
          margin: 5px 0;
        }

        .button-container {
          display: flex;
          justify-content: center;
          margin-top: 20px;
        }

        .button-container button {
          margin: 0 10px;
          padding: 10px;
          border-radius: 5px;
          border: none;
          cursor: pointer;
        }

        .button-container button:hover {
          background-color: #F5F5F5;
        }

        .close-button {
          position: absolute;
          top: 10px;
          right: 10px;
          font-size: 28px;
          font-weight: bold;
          cursor: pointer;
        }
      `;
      document.head.appendChild(style);
      if(myimgs.length !== 0) {
        showSlides(1);
      }
      if(mode == 3) {
        return new Promise(resolve => {
          const confirmButton = buttonContainer.querySelector("#confirmButton");
          const cancelButton = buttonContainer.querySelector("#cancelButton");          

          confirmButton.addEventListener("click", () => {
            popupContainer.remove();
            resolve(true);
          });

          cancelButton.addEventListener("click", () => {
            popupContainer.remove();
            resolve(false);
          });
        });
      }
    }

    async function deposit() {
      // Create the popup container
      const popupContainer = document.createElement('div');
      popupContainer.classList.add('popup-container');
      //popupContainer.onclick = function() { popupContainer.remove(); };

      const popup = document.createElement('div');
      popup.classList.add('popup');

      const closeButton = document.createElement('span');
      closeButton.innerHTML = '&times;';
      closeButton.classList.add('close-button');
      closeButton.onclick = function() { popupContainer.remove(); };

      // Create the form element
      var form = document.createElement('form');
      form.classList.add('popup-form');
      form.innerHTML = `
        <h2>Deposit tokens to your balance</h2>
        <div class="form-group">
          <label for="token-select">Select token:</label>
          <select id="token-select" name="token-select"></select>
        </div>
        <div class="form-group">
          <label for="amount-input">Amount:</label>
          <input type="number" step="0.000000000000000001" id="amount-input" name="amount-input" required>
        </div>
        <div class="form-group">
          <button type="submit" class="btn">Deposit</button>
        </div>
      `;

      // Populate the token select dropdown
      var tokenSelect = form.querySelector('#token-select');
      for (var i = 0; i < tokens.length; i++) {
        var option = document.createElement('option');
        option.value = i;
        option.text = tokens[i].token;
        tokenSelect.appendChild(option);
      }

      // Add the form submit event listener
      form.addEventListener('submit', async function(event) {
        event.preventDefault();

        var selectedIndex = parseInt(tokenSelect.value);
        var token = tokens[selectedIndex].token;
        var tokenAddress = tokens[selectedIndex].address;
        var decimals = parseInt(tokens[selectedIndex].decimals);
        var amount = parseFloat(document.getElementById('amount-input').value);

        if (token === "ETH") {
          // If the selected token is ETH, deposit WETH instead
          try {
            var value = web3.utils.toWei(amount.toString(), 'ether');
            await DDEcontract.methods.depositWETH().send({"from":myaccounts,"value":value,"gasLimit": 1000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
            await Swal.fire("Deposit success!");
            await loadUser();
            popupContainer.remove();
          } catch (error) {
            console.error(error);
          }
        } else {
          // If the selected token is not ETH, deposit the selected token
          try {
            var tokenContract = new web3.eth.Contract(ERC20abi, tokenAddress);
            var allowance = DOMPurify.sanitize(await tokenContract.methods.allowance(myaccounts, DDEaddy).call());
            var value = (new BigNumber(amount.toString()).times(new BigNumber(10).pow(decimals))).toString()

            if (web3.utils.toBN(allowance).lt(web3.utils.toBN(value))) {
              await Swal.fire("Waiting for approval...");
              await tokenContract.methods.approve(DDEaddy, web3.utils.toHex(web3.utils.toBN(2).pow(web3.utils.toBN(256)).sub(web3.utils.toBN(1)))).send({"from":myaccounts,"gasLimit": 1000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
            }

            await DDEcontract.methods.deposit(tokenAddress, value).send({"from":myaccounts,"gasLimit": 1000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
            await Swal.fire("Deposit success!");
            await loadUser();
            popupContainer.remove();
          } catch (error) {
            console.error(error);
          }
        }
      });

      // Append the form to the popup container
      popupContainer.appendChild(popup);
      popup.appendChild(form);
      popup.appendChild(closeButton);

      // Append the popup container to the page body
      document.body.appendChild(popupContainer);

      // Add CSS rules
      const style = document.createElement('style');
      style.type = 'text/css';
      style.innerHTML = `
        .popup-container {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.4);
          display: flex;
          justify-content: center;
          align-items: center;
        }

        .popup {
          position: relative;
          background-color: white;
          padding: 20px;
          max-width: 600px;
          max-height: 80%;
          overflow-y: auto;
        }

        .close-button {
          position: absolute;
          top: 10px;
          right: 10px;
          font-size: 28px;
          font-weight: bold;
          cursor: pointer;
        }
      `;
      document.head.appendChild(style);
    }

    async function withdraw() {
      // Create the popup container
      const popupContainer = document.createElement('div');
      popupContainer.classList.add('popup-container');
      //popupContainer.onclick = function() { popupContainer.remove(); };

      const popup = document.createElement('div');
      popup.classList.add('popup');

      const closeButton = document.createElement('span');
      closeButton.innerHTML = '&times;';
      closeButton.classList.add('close-button');
      closeButton.onclick = function() { popupContainer.remove(); };

      // Create the form element
      var form = document.createElement('form');
      form.classList.add('popup-form');
      form.innerHTML = `
        <h2>Withdraw tokens from your balance</h2>
        <div class="form-group">
          <label for="token-select">Select token:</label>
          <select id="token-select" name="token-select"></select>
        </div>
        <div class="form-group">
          <label for="amount-input">Amount:</label>
          <input type="number" step="0.000000000000000001" id="amount-input" name="amount-input" required>
        </div>
        <div class="form-group">
          <button type="submit" class="btn">Withdraw</button>
        </div>
      `;

      // Populate the token select dropdown
      var tokenSelect = form.querySelector('#token-select');
      for (var i = 0; i < tokens.length; i++) {
        var option = document.createElement('option');
        option.value = i;
        option.text = tokens[i].token;
        tokenSelect.appendChild(option);
      }

      // Add the form submit event listener
      form.addEventListener('submit', async function(event) {
          event.preventDefault();
          var selectedIndex = parseInt(tokenSelect.value);
          var tokenAddress = tokens[selectedIndex].address;
          var decimals = parseInt(tokens[selectedIndex].decimals);
          var amount = parseFloat(document.getElementById('amount-input').value);          
          var value = (new BigNumber(amount.toString()).times(new BigNumber(10).pow(decimals))).toFixed(0);
          try {
            await DDEcontract.methods.withdraw(tokenAddress, value).send({"from":myaccounts,"gasLimit": 1000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
            await Swal.fire("Withdraw success!");
            await loadUser();
            popupContainer.remove();
          } catch (error) {
            console.error(error);
          }
      });

      // Append the form to the popup container
      popupContainer.appendChild(popup);
      popup.appendChild(form);
      popup.appendChild(closeButton);

      // Append the popup container to the page body
      document.body.appendChild(popupContainer);

      // Add CSS rules
      const style = document.createElement('style');
      style.type = 'text/css';
      style.innerHTML = `
        .popup-container {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.4);
          display: flex;
          justify-content: center;
          align-items: center;
        }

        .popup {
          position: relative;
          background-color: white;
          padding: 20px;
          max-width: 600px;
          max-height: 80%;
          overflow-y: auto;
        }

        .close-button {
          position: absolute;
          top: 10px;
          right: 10px;
          font-size: 28px;
          font-weight: bold;
          cursor: pointer;
        }
      `;
      document.head.appendChild(style);
    }

    async function resizeImage(file) {
      // Check if the file is an image
      if (!file.type.startsWith('image/')) {
        return null;
      }

      // Load the image data into an image object
      const img = new Image();

      const base64 = await new Promise((resolve) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
      });

      img.src = base64;

      // Wait for the image to load
      await new Promise((resolve) => {
        img.onload = resolve;
      });

      // Check if the image is too large
      const maxSize = 100 * 1024; // 100 KB
      const size = img.width * img.height * 3; // 3 bytes per pixel
      if (size <= maxSize) {
        return img.src;
      }

      // Resize the image using the Canvas API
      const canvas = document.createElement('canvas');
      const scale = Math.sqrt(maxSize / size);
      canvas.width = img.width * scale;
      canvas.height = img.height * scale;
      canvas.getContext('2d').drawImage(img, 0, 0, canvas.width, canvas.height);
      return canvas.toDataURL(file.type, 0.8); // Reduce quality to reduce size
    }

    async function createContract(publicoffer=true, counterdata={}) {
        // Create the popup container
        const popupContainer = document.createElement('div');
        popupContainer.classList.add('popup-container');
        //popupContainer.onclick = function() { popupContainer.remove(); };

        const popup = document.createElement('div');
        popup.classList.add('popup');

        const closeButton = document.createElement('span');
        closeButton.innerHTML = '&times;';
        closeButton.classList.add('close-button');
        closeButton.onclick = function() { popupContainer.remove(); };

        var myterms = [];
        var expiration = 0;

        // Create the form element
        var form = document.createElement('form');
        form.classList.add('popup-form');
        form.innerHTML = `<div id="createContractModal" class="modal">
          <div class="modal-content">
            <h2>Create Contract</h2>
            <form id="createContractForm">
              <label for="contractType">Contract Type:</label>
              <select id="contractType">
                <option value="public">Public Offer</option>
                <option value="private">Private Offer</option>
              </select><br>
              <div id="counterPartyAddressField" style="display:none;">
                <label for="counterPartyAddress">Counter-Party Address:</label>
                <input type="text" id="counterPartyInput">
              </div><br>
              <label for="senderReceiver">Sender or Receiver:</label>
              <select id="senderReceiver">
                <option value="receiver">I'm the one receiving the funds</option>
                <option value="sender">I'm the one sending the funds</option>                
              </select><br>
              <label for="token">Token:</label>
              <select id="token-select">
                <!-- options added dynamically through javascript -->
              </select><br>
              <label for="quantity">Quantity:</label>
              <input type="number" id="order-quantity" value="1"><br>
              <label for="amount">Amount:</label>
              <input type="number" id="amount-input" step="0.000000000000000001"><br>
              <label for="depositSettings">Deposit Settings:</label>
              <select id="depositSettings">
                <option value="recommended">Use recommended deposit settings</option>
                <option value="custom">Custom deposits</option>
              </select><br>
              <div id="senderDepositField" style="display:none;">
                <label for="senderDeposit">Sender Deposit:</label>
                <input type="number" id="sender-deposit-input" step="0.000000000000000001">
              </div><br>
              <div id="receiverDepositField" style="display:none;">
                <label for="receiverDeposit">Receiver Deposit:</label>
                <input type="number" id="recipient-deposit-input" step="0.000000000000000001">
              </div><br>
              <label for="timeLimit">Time Limit (in weeks):</label>
              <input type="number" id="timeLimit" value="4"><br>
              <p id="timeLimitWarning" style="display:none;">Notice: Fast expiration times can cause users to lose funds if they lose access to their computers. The default time of one month or longer is recommended for this reason.</p><br>
              <label for="contractDetails">Contract Details:</label><br>
              <textarea id="contractDetails"></textarea><br>
              <label for="contractImage">Contract Images:</label>
              <input type="file" id="contractImage" multiple><br><br>
              <button type="button" id="changefile" style="display:none;">Change Images</button>
              <label for="contactInfo">Contact Information(email/signal/telegram):</label><br>
              <input id="contactInfo"></textarea><br>
              <label for="key-words" id="key-label">Search key words(optional):</label>
              <button type="button" id="key-words">Add search terms</button><br>
              <label for="autoaccept">Automatically accept matching offers  </label>
              <input type="checkbox" id="autoaccept" checked><br><br>
              <button type="submit">Submit</button>
            </form>
          </div>
        </div>
        `;

        // Populate the token select dropdown
        var tokenSelect = form.querySelector('#token-select');
        for (var i = 0; i < tokens.length; i++) {
            var option = document.createElement('option');
            option.value = i;
            option.text = tokens[i].token;
            tokenSelect.appendChild(option);
        }

        form.querySelector("#contactInfo").value = document.getElementById("myContactInfo").value;

        // Get necessary DOM elements
        var contractType = form.querySelector('#contractType');
        var counterPartyAddressField = form.querySelector('#counterPartyAddressField');        
        var depositSelect = form.querySelector('#depositSettings');
        var senderDepositInput = form.querySelector('#senderDepositField');
        var recipientDepositInput = form.querySelector('#receiverDepositField');
        var imageInput = form.querySelector('#contractImage');
        var auto = form.querySelector('#autoaccept');
        var adjusttime = form.querySelector('#timeLimit');
        var addWord = form.querySelector("#key-words");
        var addWordLabel = form.querySelector("#key-label");

        // Hide counterparty input initially
        counterPartyAddressField.style.display = 'none';

        // Hide deposit inputs initially
        senderDepositInput.style.display = 'none';
        recipientDepositInput.style.display = 'none';

        // Event listener for type select
        contractType.addEventListener('change', () => {
          if (contractType.value === 'private') {
            counterPartyAddressField.style.display = 'block';
            auto.style.display = 'none';
            myterms = [];
            addWord.style.display = 'none';
            addWordLabel.style.display = 'none';
          } else {
            counterPartyAddressField.style.display = 'none';
            auto.style.display = 'block';
            addWord.style.display = 'block';
            addWordLabel.style.display = 'block';
          }
        });

        adjusttime.addEventListener('change', () => {
            if(adjusttime.value<4) {
                timeLimitWarning.style.display = 'block';
            } else {
                timeLimitWarning.style.display = 'none';
            }
        });

        // Event listener for deposit select
        depositSelect.addEventListener('change', () => {
          if (depositSelect.value === 'custom') {
            senderDepositInput.style.display = 'block';
            recipientDepositInput.style.display = 'block';
          } else {
            senderDepositInput.style.display = 'none';
            recipientDepositInput.style.display = 'none';
          }
        });
        var image = [];
        // Event listener for image input
        imageInput.addEventListener('change', async () => {
          if(imageInput.files.length > 10) {
            await Swal.fire("Please add less than the maximum of 10 images");
            return false;
          }
          for (let i = 0; i < imageInput.files.length; i++) {
            const file = imageInput.files[i];
            const myimage = await resizeImage(file);
            if (myimage) {
              image.push(myimage);
            } else {
              console.warn(`File ${file.name} is not an image`);
            }
          }
        });

        if(Object.keys(counterdata).length !== 0) {
          form.querySelector('#contractType').selectedIndex = 1;
          counterPartyAddressField.style.display = 'block';
          auto.style.display = 'none';
          if(myaccounts === counterdata.recipient) {
            form.querySelector("#senderReceiver").selectedIndex = 0;
            form.querySelector("#counterPartyInput").value = counterdata.sender;
          } else {
            form.querySelector("#senderReceiver").selectedIndex = 1;
            form.querySelector("#counterPartyInput").value = counterdata.recipient;
          }
          form.querySelector("#order-quantity").value = 1;
          form.querySelector("#amount-input").value = displayDecimals(counterdata.token, counterdata.amount);
          if(counterdata.amount == counterdata.depositSender && counterdata.amount == counterdata.depositRecipient) {
            form.querySelector("#depositSettings").selectedIndex = 0;
          } else {
            form.querySelector("#depositSettings").selectedIndex = 1;
            senderDepositInput.style.display = 'block';
            recipientDepositInput.style.display = 'block';
            form.querySelector("#sender-deposit-input").value = displayDecimals(counterdata.token, counterdata.depositSender);
            form.querySelector("#recipient-deposit-input").value = displayDecimals(counterdata.token, counterdata.depositRecipient);
          }
          form.querySelector("#timeLimit").value = parseInt(counterdata.timelimit[0]) / (60 * 60 * 24 * 7);
          form.querySelector("#contractDetails").value = counterdata.message;
          var selectedIndex = -1;

          for (var inx = 0; inx < tokens.length; inx++) {
            if (tokens[inx].address === counterdata.token) {
              selectedIndex = inx;
              break;
            }
          }

          if (selectedIndex !== -1) {
            tokenSelect.selectedIndex = selectedIndex;
          } else {
            await Swal.fire('Token not found in default coin list!');
            popupContainer.remove();
            return;
          }
          image = await(getFile(counterdata.image));
          form.querySelector("#contractImage").style.display = 'none';
          const changefile = form.querySelector("#changefile")
          changefile.style.display = 'block';
          changefile.onclick = () => { 
            changefile.style.display = 'none';
            form.querySelector("#contractImage").style.display = 'block';
            image = [];
          }
        }

        addWord.onclick = async function() {
            myterms = await addWords();
        }

        // Add the form submit event listener
        form.addEventListener('submit', async function(event) {
          event.preventDefault();
          // Get form values
          var counterPartyInput = document.getElementById("counterPartyInput").value;
          var sender = "0x0000000000000000000000000000000000000000";
          var recipient = "0x0000000000000000000000000000000000000000";
          if (contractType.value === 'private') {
                sender = counterPartyInput;
                recipient = myaccounts;
                var offerExpirationSelect = document.getElementById("offerExpiration");
                var selectedValue = offerExpirationSelect.value;
                const currentBlockNumber = await web3.eth.getBlockNumber();
                const currentBlock = await web3.eth.getBlock(currentBlockNumber);
                const blockTimestamp = DOMPurify.sanitize(currentBlock.timestamp);
                if (selectedValue === "never") {
                  expiration = 0; // Set the time limit to 0 seconds for "Never" option
                } else if (selectedValue === "two-weeks") {
                  expiration = parseInt(blockTimestamp + (2 * 7 * 24 * 60 * 60)); // Set the time limit to 2 weeks in seconds
                } else if (selectedValue === "one-month") {
                  expiration = parseInt(blockTimestamp + (30 * 24 * 60 * 60)); // Set the time limit to 1 month in seconds
                }
          } else {
                expiration = 0;
                recipient = myaccounts;
          }
          var senderReceiver = document.getElementById("senderReceiver").value;
          var quantity = parseInt(document.getElementById('order-quantity').value);
          var amount = document.getElementById("amount-input").value;
          var depositType = form.querySelector("#depositSettings").value;
          var depositSender = document.getElementById("sender-deposit-input").value;
          var depositRecipient = document.getElementById("recipient-deposit-input").value;
          var timeLimit = document.getElementById("timeLimit").value;
          var contactinfo = document.getElementById("contactInfo").value;
          var message = JSON.stringify({message: document.getElementById("contractDetails").value, contact: contactinfo, image: image});
          if (contactinfo != '') {
            document.getElementById("myContactInfo").value = contactinfo;
            await saveContactInfo(contactinfo);
          }          
          if(message == "error") {
            await Swal.fire("Error posting IPFS data, please try again later");
            return false;
          }
          if (amount === "") {
            await Swal.fire("Please enter the amount");
            return false;
          }
          if (depositType === "custom") {
            if (depositSender === "" || depositRecipient === "") {
              await Swal.fire("Please enter the custom deposits");
              return false;
            }
          }
          if (timeLimit === "") {
            await Swal.fire("Please enter the time limit");
            return false;
          }
          timeLimit = parseInt(timeLimit);
          if (timeLimit === 0) {
            await Swal.fire("Time limit must be greater than zero")
          }
          if (document.getElementById("contractDetails").value === "") {
            await Swal.fire("Please enter the description");
            return false;
          }
          var sender2 = (senderReceiver === "receiver" ? sender : recipient);
          var recipient2 = (senderReceiver === "receiver" ? recipient : sender);
          var selectedIndex = parseInt(tokenSelect.value);
          var tokenAddress = tokens[selectedIndex].address;
          var decimals = parseInt(tokens[selectedIndex].decimals);

          amount = (new BigNumber(amount.toString()).times(new BigNumber(10).pow(decimals))).toFixed(0);
          depositSender = (depositType === "recommended" ? amount : (new BigNumber(depositSender.toString()).times(new BigNumber(10).pow(decimals))).toFixed(0));
          depositRecipient = (depositType === "recommended" ? amount : (new BigNumber(depositRecipient.toString()).times(new BigNumber(10).pow(decimals))).toFixed(0));
          var style = 0;
          if(publicoffer) {
            if(document.getElementById("autoaccept").checked == false) {
                style = 1;
            }
          }
          var multiplier = 1;
          if(style == 0) {
            multiplier = quantity;
          }
          if(myaccounts == sender2) {
            if (web3.utils.toBN(balances[tokenAddress].amount).lt(web3.utils.toBN(amount).add(web3.utils.toBN(depositSender)).mul(web3.utils.toBN(multiplier)))) {
                await Swal.fire("You don't have enough funds if someone were to accept this offer. Please deposit funds first before proceeding.");
                return false;
            }
          }
          if(myaccounts == recipient2) {
            if (web3.utils.toBN(balances[tokenAddress].amount).lt(web3.utils.toBN(depositRecipient).mul(web3.utils.toBN(multiplier)))) {
                await Swal.fire("You don't have enough funds if someone were to accept this offer. Please deposit funds first before proceeding.");
                return false;
            }
          }
          result = await postOfferData(message);
          if(result == "error") {
              await Swal.fire("Error posting message data to IPFS.");
              return false;
          }
          if(result.length > 100) {
              await Swal.fire("Error message length was unusually long. Please check IPFS hash result.");
              return false;
          }
          message = result;
          // Construct data object
          const data = {
            sender: sender2,
            recipient: recipient2,
            token: tokenAddress,
            amount: amount,
            depositSender: depositSender,
            depositRecipient: depositRecipient,
            quantity: quantity,
            timelimit: parseInt(timeLimit * 7 * 24 * 60 * 60),
            message: message
          };
          data2 = JSON.parse(JSON.stringify(data));
          data2.image = [];
          data2.message = "IPFS link: " + data2.message;
          data2.timelimit = [data2.timelimit];
          //if(Object.keys(counterdata).length !== 0) {
          //  data2.amount *= quantity;
          //  data2.depositSender *= quantity;
          //  data2.depositRecipient *= quantity;
          //}
          console.log(data2);
          //May eventually want to check for duplicate contract hash submission
          var result = await showListing(data2, 3)
          if(result == false) {
            popupContainer.remove();
            return;
          }
          try {
              // Call solidity function to create contract
              await DDEcontract.methods.createContract(
                data.sender,
                data.recipient,
                data.token,
                data.amount,
                data.depositSender,
                data.depositRecipient,
                data.quantity,
                [data.timelimit, expiration],
                style,
                data.message,
                myterms
              ).send({"from":myaccounts,"gasLimit": 4000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
                await Swal.fire("Contract creation success!");
                await loadUser();
                popupContainer.remove();
              } catch (error) {
                console.error(error);
          }
        });

        // Append the form to the popup container
        popupContainer.appendChild(popup);
        popup.appendChild(form);
        popup.appendChild(closeButton);

        // Append the popup container to the page body
        document.body.appendChild(popupContainer);

        // Add CSS rules
        const style = document.createElement('style');
        style.type = 'text/css';
        style.innerHTML = `
        .popup-container {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.4);
          display: flex;
          justify-content: center;
          align-items: center;
        }

        .popup {
          position: relative;
          background-color: white;
          padding: 20px;
          max-width: 600px;
          max-height: 80%;
          overflow-y: auto;
        }

        .close-button {
          position: absolute;
          top: 10px;
          right: 10px;
          font-size: 28px;
          font-weight: bold;
          cursor: pointer;
        }
        `;
        document.head.appendChild(style);
    }

    async function addWords() {
      return new Promise((resolve) => {
        const dialog = document.createElement("div");
        const addedTerms = [];

        // Predefined list of popular key words
        const popularKeywords = ["goods", "services", "barter", "crypto", "real estate", "electronics", "metals"];

        dialog.innerHTML = `
          <div>Please enter some key words so users can find your order easier:<br></div>
            <input id="hashtag" type="text"></input><button id="add-btn">Add</button><br><br>
          <div id="term-list"></div>
          <div>
            <div>Popular key words:</div>
            <div id="popular-keywords"></div>
            <br>
            <button id="confirm-btn">Confirm</button>&nbsp;&nbsp;
            <button id="cancel-btn">Cancel</button>
          </div>
        `;
        dialog.style.display = "block";
        dialog.style.position = "fixed";
        dialog.style.zIndex = 9999;
        dialog.style.backgroundColor = "white";
        dialog.style.padding = "20px";
        dialog.style.borderRadius = "10px";
        dialog.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.3)";
        dialog.style.top = "50%";
        dialog.style.left = "50%";
        dialog.style.transform = "translate(-50%, -50%)";

        document.body.appendChild(dialog);

        const termList = dialog.querySelector("#term-list");
        const confirmBtn = dialog.querySelector("#confirm-btn");
        const cancelBtn = dialog.querySelector("#cancel-btn");
        const addBtn = dialog.querySelector("#add-btn");
        const popularKeywordsContainer = dialog.querySelector("#popular-keywords");

        // Display the added terms list
        function displayAddedTerms() {
          termList.innerHTML = "";
          addedTerms.forEach(term => {
            const termElement = document.createElement("div");
            termElement.textContent = term;
            termList.appendChild(termElement);
          });
        }

        // Add a term to the list when Add button is clicked
        addBtn.addEventListener("click", async () => {
          const hashtagInput = dialog.querySelector("#hashtag");
          const term = hashtagInput.value.trim();
          if (term.includes(" ") || term.includes(",")) {
            await Swal.fire("Key words should not contain spaces or commas");
            return;
          }
          const encoder = new TextEncoder();
          const utf8Bytes = encoder.encode(term);
          const byteLength = utf8Bytes.length;
          if (byteLength > 32) {
            await Swal.fire("String exceeds limit of 32 bytes");
            return;
          }
          if (term !== "") {
            addedTerms.push(term);
            displayAddedTerms();
            hashtagInput.value = "";
          }
        });

        // Add a popular keyword to the list when a bubble button is clicked
        popularKeywords.forEach(keyword => {
          const keywordButton = document.createElement("button");
          keywordButton.textContent = keyword;
          keywordButton.addEventListener("click", async () => {
            if (addedTerms.length < 11) {
              addedTerms.push(keyword.toLowerCase());
              displayAddedTerms();
            } else {
              await Swal.fire('The maximum number of keywords is 10');
            }
          });
          popularKeywordsContainer.appendChild(keywordButton);
        });

        // Remove the dialog when Cancel button is clicked
        cancelBtn.addEventListener("click", async () => {
          dialog.remove();
        });

        // Resolve the promise with the added terms when Confirm button is clicked
        confirmBtn.addEventListener("click", async () => {
          dialog.remove();
          resolve(addedTerms);
        });
      });
    }
    async function readFileAsDataURL(file) {
      return new Promise((resolve, reject) => {
        let reader = new FileReader();
        reader.onload = () => {
          resolve(reader.result.split(',')[1]);
        };
        reader.readAsDataURL(file);
      });
    }

    async function acceptOffer(listing) {
        try {
              mylisting = JSON.parse(JSON.stringify(listing));
              var quantity = 1;
              var accepttimelimit = 0;
              var offerExpirationSelect = document.getElementById("offerExpiration");
              var selectedValue = offerExpirationSelect.value;
              const currentBlockNumber = await web3.eth.getBlockNumber();
              const currentBlock = await web3.eth.getBlock(currentBlockNumber);
              const blockTimestamp = DOMPurify.sanitize(currentBlock.timestamp);
              if (selectedValue === "never") {
                accepttimelimit = 0; // Set the time limit to 0 seconds for "Never" option
              } else if (selectedValue === "two-weeks") {
                accepttimelimit = parseInt(blockTimestamp + (2 * 7 * 24 * 60 * 60)); // Set the time limit to 2 weeks in seconds
              } else if (selectedValue === "one-month") {
                accepttimelimit = parseInt(blockTimestamp + (30 * 24 * 60 * 60)); // Set the time limit to 1 month in seconds
              }
              if(mylisting.sender == "0x0000000000000000000000000000000000000000" || mylisting.recipient == "0x0000000000000000000000000000000000000000" ) {
                const offerID = DOMPurify.sanitize(await DDEcontract.methods.userMarketID(mylisting.hash).call());
                if(offerID == 0) {
                  await Swal.fire("Offer no longer available!");
                  return;
                }
                if(listing.status[0]==0 || listing.status[1]==0) {
                  const dialog = document.createElement("div");
                  dialog.innerHTML = `
                    <div>Please enter the quantity you wish to purchase:<br></div>
                      <input id="new-quantity" type="number"></input><br><br>
                    <div>
                      <button id="confirm-btn">Confirm</button>&nbsp;&nbsp;
                      <button id="cancel-btn">Cancel</button>
                    </div>
                  `;
                  dialog.style.display = "block";
                  dialog.style.position = "fixed";
                  dialog.style.zIndex = 9999;
                  dialog.style.backgroundColor = "white";
                  dialog.style.padding = "20px";
                  dialog.style.borderRadius = "10px";
                  dialog.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.3)";
                  dialog.style.top = "50%";
                  dialog.style.left = "50%";
                  dialog.style.transform = "translate(-50%, -50%)";

                  document.body.appendChild(dialog);

                  const confirmBtn = dialog.querySelector("#confirm-btn");
                  const cancelBtn = dialog.querySelector("#cancel-btn");
                  cancelBtn.addEventListener("click", async () => {
                    dialog.remove();
                  });

                  confirmBtn.addEventListener("click", async () => {
                    quantity = parseInt(document.getElementById('new-quantity').value);
                    if(quantity > mylisting.quantity) {
                      await Swal.fire("Quantity exceeds what is available!");
                      return;                        
                    }
                    dialog.remove();
                    mylisting.quantity = quantity;
                    var counterparty = mylisting.sender;
                    if(mylisting.sender == "0x0000000000000000000000000000000000000000") {
                        counterparty = mylisting.recipient;
                    }
                    var counterbalance = "";
                    await DDEcontract.methods.userBalance(counterparty,mylisting.token).call().then(function (bal) {            
                            counterbalance = DOMPurify.sanitize(bal);
                    });
                    if(mylisting.sender == "0x0000000000000000000000000000000000000000") {
                      if (web3.utils.toBN(balances[mylisting.token].amount).lt(web3.utils.toBN(mylisting.amount).add(web3.utils.toBN(mylisting.depositSender)).mul(web3.utils.toBN(quantity)))) {
                          await Swal.fire("You don't have enough funds. Please deposit funds first before proceeding.");
                          return false;
                      }
                      if (web3.utils.toBN(counterbalance).lt(web3.utils.toBN(mylisting.depositRecipient).mul(web3.utils.toBN(quantity)))) {
                          await Swal.fire("The counter-party does not have enough funds in their account to proceed. Please notify the counter-party.");
                          return false;
                      }
                    }
                    if(mylisting.recipient == "0x0000000000000000000000000000000000000000") {
                      if (web3.utils.toBN(balances[mylisting.token].amount).lt(web3.utils.toBN(mylisting.depositRecipient).mul(web3.utils.toBN(quantity)))) {
                          await Swal.fire("You don't have enough funds. Please deposit funds first before proceeding.");
                          return false;
                      }
                      if (web3.utils.toBN(counterbalance).lt(web3.utils.toBN(mylisting.amount).add(web3.utils.toBN(mylisting.depositSender)).mul(web3.utils.toBN(quantity)))) {
                          await Swal.fire("The counter-party does not have enough funds in their account to proceed. Please notify the counter-party.");
                          return false;
                      }
                    }
                    //If one wants to show a grand total
                    //mylisting.amount *= quantity;
                    //mylisting.depositSender *= quantity;
                    //mylisting.depositRecipient *= quantity;
                    var result = await showListing(mylisting, 3)
                    if(result == false) {
                      return;
                    }
                    await DDEcontract.methods.acceptOffer(
                      mylisting.hash,
                      quantity,
                      accepttimelimit
                    ).send({"from":myaccounts,"gasLimit": 4000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
                      await Swal.fire("Contract accepted!");
                      await loadUser();                      
                    });
                }
              } else {
                quantity = mylisting.quantity;
                var counterparty = mylisting.sender;
                if(mylisting.sender == myaccounts) {
                    counterparty = mylisting.recipient;
                }
                var counterbalance = "";
                await DDEcontract.methods.userBalance(counterparty,mylisting.token).call().then(function (bal) {            
                        counterbalance = DOMPurify.sanitize(bal);
                });
                if(mylisting.sender == myaccounts) {
                  if (web3.utils.toBN(balances[mylisting.token].amount).lt(web3.utils.toBN(mylisting.amount).add(web3.utils.toBN(mylisting.depositSender)).mul(web3.utils.toBN(quantity)))) {
                      await Swal.fire("You don't have enough funds. Please deposit funds first before proceeding.");
                      return false;
                  }
                  if (web3.utils.toBN(counterbalance).lt(web3.utils.toBN(mylisting.depositRecipient).mul(web3.utils.toBN(quantity)))) {
                      await Swal.fire("The counter-party does not have enough funds in their account to proceed. Please notify the counter-party.");
                      return false;
                  }
                }
                if(mylisting.recipient == myaccounts) {
                  if (web3.utils.toBN(balances[mylisting.token].amount).lt(web3.utils.toBN(mylisting.depositRecipient).mul(web3.utils.toBN(quantity)))) {
                      await Swal.fire("You don't have enough funds. Please deposit funds first before proceeding.");
                      return false;
                  }
                  if (web3.utils.toBN(counterbalance).lt(web3.utils.toBN(mylisting.amount).add(web3.utils.toBN(mylisting.depositSender)).mul(web3.utils.toBN(quantity)))) {
                      await Swal.fire("The counter-party does not have enough funds in their account to proceed. Please notify the counter-party.");
                      return false;
                  }
                }
                //If one wants to show a grand total
                //mylisting.amount *= quantity;
                //mylisting.depositSender *= quantity;
                //mylisting.depositRecipient *= quantity;
                var result = await showListing(mylisting, 3)
                if(result == false) {
                  return;
                }
                await DDEcontract.methods.acceptOffer(
                  mylisting.hash,
                  quantity,
                  accepttimelimit
                ).send({"from":myaccounts,"gasLimit": 4000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
                  await Swal.fire("Contract accepted!");
                  await loadUser();
              }
        } catch (error) {
            console.error(error);
        }
    }
    async function counterOffer(listing) {
        await createContract(false, listing);
    }
    async function cancelOffer(listing, hide=0) {
      if(hide == 1) {
          const dialog = document.createElement("div");
          dialog.innerHTML = `
            <div>Would you like to hide this offer or cancel it?<br>Hiding just removes it from the list.<br>Cancelling will also notify the other party.<br><br></div>
            <div>
              <button id="hide-btn">Hide</button>&nbsp;&nbsp;
              <button id="cancel-btn">Cancel</button>
            </div>
          `;
          dialog.style.display = "block";
          dialog.style.position = "fixed";
          dialog.style.zIndex = 9999;
          dialog.style.backgroundColor = "white";
          dialog.style.padding = "20px";
          dialog.style.borderRadius = "10px";
          dialog.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.3)";
          dialog.style.top = "50%";
          dialog.style.left = "50%";
          dialog.style.transform = "translate(-50%, -50%)";

          document.body.appendChild(dialog);

          const hideBtn = dialog.querySelector("#hide-btn");
          const cancelBtn = dialog.querySelector("#cancel-btn");

          hideBtn.addEventListener("click", async () => {
            var readMessages = JSON.parse(localStorage.getItem(myaccounts+":readmessages2")) || {};
            readMessages[listing.index] = true;
            localStorage.setItem(myaccounts+":readmessages2", JSON.stringify(readMessages));            
            await loadUser();
            dialog.remove();           
          });

          cancelBtn.addEventListener("click", async () => {
            try {
                  dialog.remove();
                  await DDEcontract.methods.cancelPrivateOffer(
                    listing.hash
                  ).send({"from":myaccounts,"gasLimit": 1000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
                  await Swal.fire("Contract removed!");
                  await loadUser();                
            } catch (error) {
                console.error(error);
            }
          });
      } else {
          try {
                if(listing.sender == "0x0000000000000000000000000000000000000000" || listing.recipient == "0x0000000000000000000000000000000000000000" ) {
                  await DDEcontract.methods.removeMarketOffer(
                    listing.hash
                  ).send({"from":myaccounts,"gasLimit": 1000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
                  await Swal.fire("Contract removed!");
                  await loadUser();
                } else {
                  await DDEcontract.methods.cancelPrivateOffer(
                    listing.hash
                  ).send({"from":myaccounts,"gasLimit": 1000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
                  await Swal.fire("Contract removed!");
                  await loadUser();
                }
            } catch (error) {
                console.error(error);
            }
      }      
    }
    async function updateQuantity(listing) {
      const dialog = document.createElement("div");
      dialog.innerHTML = `
        <div>Please enter the updated quantity:<br></div>
          <input id="new-quantity" type="number"></input><br><br>
        <div>
          <button id="confirm-btn">Confirm</button>&nbsp;&nbsp;
          <button id="cancel-btn">Cancel</button>
        </div>
      `;
      dialog.style.display = "block";
      dialog.style.position = "fixed";
      dialog.style.zIndex = 9999;
      dialog.style.backgroundColor = "white";
      dialog.style.padding = "20px";
      dialog.style.borderRadius = "10px";
      dialog.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.3)";
      dialog.style.top = "50%";
      dialog.style.left = "50%";
      dialog.style.transform = "translate(-50%, -50%)";

      document.body.appendChild(dialog);

      const confirmBtn = dialog.querySelector("#confirm-btn");
      const cancelBtn = dialog.querySelector("#cancel-btn");

      cancelBtn.addEventListener("click", async () => {
        dialog.remove();
        return;
      });

      confirmBtn.addEventListener("click", async () => {
        try {
              var quantity = parseInt(document.getElementById('new-quantity').value);
              if(quantity == 0) {
                await Swal.fire("Quantity can not be changed to zero!");
                dialog.remove();
                return;
              }
              await DDEcontract.methods.updateQuantity(
                listing.hash,
                quantity
              ).send({"from":myaccounts,"gasLimit": 1000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
                await Swal.fire("Quantity updated!");
                await loadUser();
        } catch (error) {
            console.error(error);
        }
        dialog.remove();
      });
    }

    async function addAPI(text) {
        var data = CryptoJS.AES.encrypt(JSON.stringify(text), AESkey).toString();
        console.log(data)
        try {
            await DDEcontract.methods.adddata(data).send({"from":myaccounts,"gasLimit": 3000000,"gasPrice":null,"maxPriorityFeePerGas":null,"maxFeePerGas":null});
            await Swal.fire("Data added!");
          } catch (error) {
            console.error(error);
        }
    }
    async function getAPI(index) {
        await DDEcontract.methods.publicdata(index).call().then(function (data) {
                data=JSON.parse(DOMPurify.sanitize(CryptoJS.AES.decrypt(data, AESkey).toString(CryptoJS.enc.Utf8)));
                if (data.length === 2) { //using public gateway
                    pinataApiKey = data[0];
                    pinataSecretApiKey = data[1];
                    pinataGateway = 'https://gateway.pinata.cloud/ipfs/';
                } else {
                    if (!Array.isArray(data)) {
                        data = JSON.parse(data);
                    }
                    if(data.length === 3) {
                        pinataApiKey = data[0];
                        pinataSecretApiKey = data[1];
                        pinataGateway = data[2];
                    } else {
                        pinataApiKey = data[0];
                        pinataSecretApiKey = data[1];
                        pinataGateway = data[2];
                        pinataToken = data[3];
                    }
                }
        });
    }
    setInterval(loadUser, 90000);
    loadMarkets(1, 50);    
</script>
</body>
</html>